{"ast":null,"code":"\"use client\";import{jsx,Fragment}from'react/jsx-runtime';import{useMemo,useRef,useState,useContext}from'react';import{LayoutGroupContext}from'../../context/LayoutGroupContext.mjs';import{useConstant}from'../../utils/use-constant.mjs';import{useIsomorphicLayoutEffect}from'../../utils/use-isomorphic-effect.mjs';import{PresenceChild}from'./PresenceChild.mjs';import{usePresence}from'./use-presence.mjs';import{onlyElements,getChildKey}from'./utils.mjs';/**\n * `AnimatePresence` enables the animation of components that have been removed from the tree.\n *\n * When adding/removing more than a single child, every child **must** be given a unique `key` prop.\n *\n * Any `motion` components that have an `exit` property defined will animate out when removed from\n * the tree.\n *\n * ```jsx\n * import { motion, AnimatePresence } from 'framer-motion'\n *\n * export const Items = ({ items }) => (\n *   <AnimatePresence>\n *     {items.map(item => (\n *       <motion.div\n *         key={item.id}\n *         initial={{ opacity: 0 }}\n *         animate={{ opacity: 1 }}\n *         exit={{ opacity: 0 }}\n *       />\n *     ))}\n *   </AnimatePresence>\n * )\n * ```\n *\n * You can sequence exit animations throughout a tree using variants.\n *\n * If a child contains multiple `motion` components with `exit` props, it will only unmount the child\n * once all `motion` components have finished animating out. Likewise, any components using\n * `usePresence` all need to call `safeToRemove`.\n *\n * @public\n */const AnimatePresence=_ref=>{let{children,custom,initial=true,onExitComplete,presenceAffectsLayout=true,mode=\"sync\",propagate=false,anchorX=\"left\"}=_ref;const[isParentPresent,safeToRemove]=usePresence(propagate);/**\n     * Filter any children that aren't ReactElements. We can only track components\n     * between renders with a props.key.\n     */const presentChildren=useMemo(()=>onlyElements(children),[children]);/**\n     * Track the keys of the currently rendered children. This is used to\n     * determine which children are exiting.\n     */const presentKeys=propagate&&!isParentPresent?[]:presentChildren.map(getChildKey);/**\n     * If `initial={false}` we only want to pass this to components in the first render.\n     */const isInitialRender=useRef(true);/**\n     * A ref containing the currently present children. When all exit animations\n     * are complete, we use this to re-render the component with the latest children\n     * *committed* rather than the latest children *rendered*.\n     */const pendingPresentChildren=useRef(presentChildren);/**\n     * Track which exiting children have finished animating out.\n     */const exitComplete=useConstant(()=>new Map());/**\n     * Save children to render as React state. To ensure this component is concurrent-safe,\n     * we check for exiting children via an effect.\n     */const[diffedChildren,setDiffedChildren]=useState(presentChildren);const[renderedChildren,setRenderedChildren]=useState(presentChildren);useIsomorphicLayoutEffect(()=>{isInitialRender.current=false;pendingPresentChildren.current=presentChildren;/**\n         * Update complete status of exiting children.\n         */for(let i=0;i<renderedChildren.length;i++){const key=getChildKey(renderedChildren[i]);if(!presentKeys.includes(key)){if(exitComplete.get(key)!==true){exitComplete.set(key,false);}}else{exitComplete.delete(key);}}},[renderedChildren,presentKeys.length,presentKeys.join(\"-\")]);const exitingChildren=[];if(presentChildren!==diffedChildren){let nextChildren=[...presentChildren];/**\n         * Loop through all the currently rendered components and decide which\n         * are exiting.\n         */for(let i=0;i<renderedChildren.length;i++){const child=renderedChildren[i];const key=getChildKey(child);if(!presentKeys.includes(key)){nextChildren.splice(i,0,child);exitingChildren.push(child);}}/**\n         * If we're in \"wait\" mode, and we have exiting children, we want to\n         * only render these until they've all exited.\n         */if(mode===\"wait\"&&exitingChildren.length){nextChildren=exitingChildren;}setRenderedChildren(onlyElements(nextChildren));setDiffedChildren(presentChildren);/**\n         * Early return to ensure once we've set state with the latest diffed\n         * children, we can immediately re-render.\n         */return null;}if(process.env.NODE_ENV!==\"production\"&&mode===\"wait\"&&renderedChildren.length>1){console.warn(\"You're attempting to animate multiple children within AnimatePresence, but its mode is set to \\\"wait\\\". This will lead to odd visual behaviour.\");}/**\n     * If we've been provided a forceRender function by the LayoutGroupContext,\n     * we can use it to force a re-render amongst all surrounding components once\n     * all components have finished animating out.\n     */const{forceRender}=useContext(LayoutGroupContext);return jsx(Fragment,{children:renderedChildren.map(child=>{const key=getChildKey(child);const isPresent=propagate&&!isParentPresent?false:presentChildren===renderedChildren||presentKeys.includes(key);const onExit=()=>{if(exitComplete.has(key)){exitComplete.set(key,true);}else{return;}let isEveryExitComplete=true;exitComplete.forEach(isExitComplete=>{if(!isExitComplete)isEveryExitComplete=false;});if(isEveryExitComplete){forceRender===null||forceRender===void 0?void 0:forceRender();setRenderedChildren(pendingPresentChildren.current);propagate&&(safeToRemove===null||safeToRemove===void 0?void 0:safeToRemove());onExitComplete&&onExitComplete();}};return jsx(PresenceChild,{isPresent:isPresent,initial:!isInitialRender.current||initial?undefined:false,custom:custom,presenceAffectsLayout:presenceAffectsLayout,mode:mode,onExitComplete:isPresent?undefined:onExit,anchorX:anchorX,children:child},key);})});};export{AnimatePresence};","map":{"version":3,"names":["jsx","Fragment","useMemo","useRef","useState","useContext","LayoutGroupContext","useConstant","useIsomorphicLayoutEffect","PresenceChild","usePresence","onlyElements","getChildKey","AnimatePresence","_ref","children","custom","initial","onExitComplete","presenceAffectsLayout","mode","propagate","anchorX","isParentPresent","safeToRemove","presentChildren","presentKeys","map","isInitialRender","pendingPresentChildren","exitComplete","Map","diffedChildren","setDiffedChildren","renderedChildren","setRenderedChildren","current","i","length","key","includes","get","set","delete","join","exitingChildren","nextChildren","child","splice","push","process","env","NODE_ENV","console","warn","forceRender","isPresent","onExit","has","isEveryExitComplete","forEach","isExitComplete","undefined"],"sources":["/home/antisyn/portfolio/src/components/node_modules/framer-motion/dist/es/components/AnimatePresence/index.mjs"],"sourcesContent":["\"use client\";\nimport { jsx, Fragment } from 'react/jsx-runtime';\nimport { useMemo, useRef, useState, useContext } from 'react';\nimport { LayoutGroupContext } from '../../context/LayoutGroupContext.mjs';\nimport { useConstant } from '../../utils/use-constant.mjs';\nimport { useIsomorphicLayoutEffect } from '../../utils/use-isomorphic-effect.mjs';\nimport { PresenceChild } from './PresenceChild.mjs';\nimport { usePresence } from './use-presence.mjs';\nimport { onlyElements, getChildKey } from './utils.mjs';\n\n/**\n * `AnimatePresence` enables the animation of components that have been removed from the tree.\n *\n * When adding/removing more than a single child, every child **must** be given a unique `key` prop.\n *\n * Any `motion` components that have an `exit` property defined will animate out when removed from\n * the tree.\n *\n * ```jsx\n * import { motion, AnimatePresence } from 'framer-motion'\n *\n * export const Items = ({ items }) => (\n *   <AnimatePresence>\n *     {items.map(item => (\n *       <motion.div\n *         key={item.id}\n *         initial={{ opacity: 0 }}\n *         animate={{ opacity: 1 }}\n *         exit={{ opacity: 0 }}\n *       />\n *     ))}\n *   </AnimatePresence>\n * )\n * ```\n *\n * You can sequence exit animations throughout a tree using variants.\n *\n * If a child contains multiple `motion` components with `exit` props, it will only unmount the child\n * once all `motion` components have finished animating out. Likewise, any components using\n * `usePresence` all need to call `safeToRemove`.\n *\n * @public\n */\nconst AnimatePresence = ({ children, custom, initial = true, onExitComplete, presenceAffectsLayout = true, mode = \"sync\", propagate = false, anchorX = \"left\", }) => {\n    const [isParentPresent, safeToRemove] = usePresence(propagate);\n    /**\n     * Filter any children that aren't ReactElements. We can only track components\n     * between renders with a props.key.\n     */\n    const presentChildren = useMemo(() => onlyElements(children), [children]);\n    /**\n     * Track the keys of the currently rendered children. This is used to\n     * determine which children are exiting.\n     */\n    const presentKeys = propagate && !isParentPresent ? [] : presentChildren.map(getChildKey);\n    /**\n     * If `initial={false}` we only want to pass this to components in the first render.\n     */\n    const isInitialRender = useRef(true);\n    /**\n     * A ref containing the currently present children. When all exit animations\n     * are complete, we use this to re-render the component with the latest children\n     * *committed* rather than the latest children *rendered*.\n     */\n    const pendingPresentChildren = useRef(presentChildren);\n    /**\n     * Track which exiting children have finished animating out.\n     */\n    const exitComplete = useConstant(() => new Map());\n    /**\n     * Save children to render as React state. To ensure this component is concurrent-safe,\n     * we check for exiting children via an effect.\n     */\n    const [diffedChildren, setDiffedChildren] = useState(presentChildren);\n    const [renderedChildren, setRenderedChildren] = useState(presentChildren);\n    useIsomorphicLayoutEffect(() => {\n        isInitialRender.current = false;\n        pendingPresentChildren.current = presentChildren;\n        /**\n         * Update complete status of exiting children.\n         */\n        for (let i = 0; i < renderedChildren.length; i++) {\n            const key = getChildKey(renderedChildren[i]);\n            if (!presentKeys.includes(key)) {\n                if (exitComplete.get(key) !== true) {\n                    exitComplete.set(key, false);\n                }\n            }\n            else {\n                exitComplete.delete(key);\n            }\n        }\n    }, [renderedChildren, presentKeys.length, presentKeys.join(\"-\")]);\n    const exitingChildren = [];\n    if (presentChildren !== diffedChildren) {\n        let nextChildren = [...presentChildren];\n        /**\n         * Loop through all the currently rendered components and decide which\n         * are exiting.\n         */\n        for (let i = 0; i < renderedChildren.length; i++) {\n            const child = renderedChildren[i];\n            const key = getChildKey(child);\n            if (!presentKeys.includes(key)) {\n                nextChildren.splice(i, 0, child);\n                exitingChildren.push(child);\n            }\n        }\n        /**\n         * If we're in \"wait\" mode, and we have exiting children, we want to\n         * only render these until they've all exited.\n         */\n        if (mode === \"wait\" && exitingChildren.length) {\n            nextChildren = exitingChildren;\n        }\n        setRenderedChildren(onlyElements(nextChildren));\n        setDiffedChildren(presentChildren);\n        /**\n         * Early return to ensure once we've set state with the latest diffed\n         * children, we can immediately re-render.\n         */\n        return null;\n    }\n    if (process.env.NODE_ENV !== \"production\" &&\n        mode === \"wait\" &&\n        renderedChildren.length > 1) {\n        console.warn(`You're attempting to animate multiple children within AnimatePresence, but its mode is set to \"wait\". This will lead to odd visual behaviour.`);\n    }\n    /**\n     * If we've been provided a forceRender function by the LayoutGroupContext,\n     * we can use it to force a re-render amongst all surrounding components once\n     * all components have finished animating out.\n     */\n    const { forceRender } = useContext(LayoutGroupContext);\n    return (jsx(Fragment, { children: renderedChildren.map((child) => {\n            const key = getChildKey(child);\n            const isPresent = propagate && !isParentPresent\n                ? false\n                : presentChildren === renderedChildren ||\n                    presentKeys.includes(key);\n            const onExit = () => {\n                if (exitComplete.has(key)) {\n                    exitComplete.set(key, true);\n                }\n                else {\n                    return;\n                }\n                let isEveryExitComplete = true;\n                exitComplete.forEach((isExitComplete) => {\n                    if (!isExitComplete)\n                        isEveryExitComplete = false;\n                });\n                if (isEveryExitComplete) {\n                    forceRender?.();\n                    setRenderedChildren(pendingPresentChildren.current);\n                    propagate && safeToRemove?.();\n                    onExitComplete && onExitComplete();\n                }\n            };\n            return (jsx(PresenceChild, { isPresent: isPresent, initial: !isInitialRender.current || initial\n                    ? undefined\n                    : false, custom: custom, presenceAffectsLayout: presenceAffectsLayout, mode: mode, onExitComplete: isPresent ? undefined : onExit, anchorX: anchorX, children: child }, key));\n        }) }));\n};\n\nexport { AnimatePresence };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}