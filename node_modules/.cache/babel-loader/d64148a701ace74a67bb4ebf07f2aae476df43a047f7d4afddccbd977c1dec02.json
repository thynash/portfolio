{"ast":null,"code":"import{Feature}from'../Feature.mjs';import{observeIntersection}from'./observers.mjs';const thresholdNames={some:0,all:1};class InViewFeature extends Feature{constructor(){super(...arguments);this.hasEnteredView=false;this.isInView=false;}startObserver(){this.unmount();const{viewport={}}=this.node.getProps();const{root,margin:rootMargin,amount=\"some\",once}=viewport;const options={root:root?root.current:undefined,rootMargin,threshold:typeof amount===\"number\"?amount:thresholdNames[amount]};const onIntersectionUpdate=entry=>{const{isIntersecting}=entry;/**\n             * If there's been no change in the viewport state, early return.\n             */if(this.isInView===isIntersecting)return;this.isInView=isIntersecting;/**\n             * Handle hasEnteredView. If this is only meant to run once, and\n             * element isn't visible, early return. Otherwise set hasEnteredView to true.\n             */if(once&&!isIntersecting&&this.hasEnteredView){return;}else if(isIntersecting){this.hasEnteredView=true;}if(this.node.animationState){this.node.animationState.setActive(\"whileInView\",isIntersecting);}/**\n             * Use the latest committed props rather than the ones in scope\n             * when this observer is created\n             */const{onViewportEnter,onViewportLeave}=this.node.getProps();const callback=isIntersecting?onViewportEnter:onViewportLeave;callback&&callback(entry);};return observeIntersection(this.node.current,options,onIntersectionUpdate);}mount(){this.startObserver();}update(){if(typeof IntersectionObserver===\"undefined\")return;const{props,prevProps}=this.node;const hasOptionsChanged=[\"amount\",\"margin\",\"root\"].some(hasViewportOptionChanged(props,prevProps));if(hasOptionsChanged){this.startObserver();}}unmount(){}}function hasViewportOptionChanged(_ref){let{viewport={}}=_ref;let{viewport:prevViewport={}}=arguments.length>1&&arguments[1]!==undefined?arguments[1]:{};return name=>viewport[name]!==prevViewport[name];}export{InViewFeature};","map":{"version":3,"names":["Feature","observeIntersection","thresholdNames","some","all","InViewFeature","constructor","arguments","hasEnteredView","isInView","startObserver","unmount","viewport","node","getProps","root","margin","rootMargin","amount","once","options","current","undefined","threshold","onIntersectionUpdate","entry","isIntersecting","animationState","setActive","onViewportEnter","onViewportLeave","callback","mount","update","IntersectionObserver","props","prevProps","hasOptionsChanged","hasViewportOptionChanged","_ref","prevViewport","length","name"],"sources":["/home/antisyn/portfolio/src/components/node_modules/framer-motion/dist/es/motion/features/viewport/index.mjs"],"sourcesContent":["import { Feature } from '../Feature.mjs';\nimport { observeIntersection } from './observers.mjs';\n\nconst thresholdNames = {\n    some: 0,\n    all: 1,\n};\nclass InViewFeature extends Feature {\n    constructor() {\n        super(...arguments);\n        this.hasEnteredView = false;\n        this.isInView = false;\n    }\n    startObserver() {\n        this.unmount();\n        const { viewport = {} } = this.node.getProps();\n        const { root, margin: rootMargin, amount = \"some\", once } = viewport;\n        const options = {\n            root: root ? root.current : undefined,\n            rootMargin,\n            threshold: typeof amount === \"number\" ? amount : thresholdNames[amount],\n        };\n        const onIntersectionUpdate = (entry) => {\n            const { isIntersecting } = entry;\n            /**\n             * If there's been no change in the viewport state, early return.\n             */\n            if (this.isInView === isIntersecting)\n                return;\n            this.isInView = isIntersecting;\n            /**\n             * Handle hasEnteredView. If this is only meant to run once, and\n             * element isn't visible, early return. Otherwise set hasEnteredView to true.\n             */\n            if (once && !isIntersecting && this.hasEnteredView) {\n                return;\n            }\n            else if (isIntersecting) {\n                this.hasEnteredView = true;\n            }\n            if (this.node.animationState) {\n                this.node.animationState.setActive(\"whileInView\", isIntersecting);\n            }\n            /**\n             * Use the latest committed props rather than the ones in scope\n             * when this observer is created\n             */\n            const { onViewportEnter, onViewportLeave } = this.node.getProps();\n            const callback = isIntersecting ? onViewportEnter : onViewportLeave;\n            callback && callback(entry);\n        };\n        return observeIntersection(this.node.current, options, onIntersectionUpdate);\n    }\n    mount() {\n        this.startObserver();\n    }\n    update() {\n        if (typeof IntersectionObserver === \"undefined\")\n            return;\n        const { props, prevProps } = this.node;\n        const hasOptionsChanged = [\"amount\", \"margin\", \"root\"].some(hasViewportOptionChanged(props, prevProps));\n        if (hasOptionsChanged) {\n            this.startObserver();\n        }\n    }\n    unmount() { }\n}\nfunction hasViewportOptionChanged({ viewport = {} }, { viewport: prevViewport = {} } = {}) {\n    return (name) => viewport[name] !== prevViewport[name];\n}\n\nexport { InViewFeature };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}