{"ast":null,"code":"import{fillWildcards}from'./utils/fill-wildcards.mjs';import{removeNonTranslationalTransform}from'./utils/unit-conversion.mjs';import{frame}from'../../frameloop/frame.mjs';const toResolve=new Set();let isScheduled=false;let anyNeedsMeasurement=false;let isForced=false;function measureAllKeyframes(){if(anyNeedsMeasurement){const resolversToMeasure=Array.from(toResolve).filter(resolver=>resolver.needsMeasurement);const elementsToMeasure=new Set(resolversToMeasure.map(resolver=>resolver.element));const transformsToRestore=new Map();/**\n         * Write pass\n         * If we're measuring elements we want to remove bounding box-changing transforms.\n         */elementsToMeasure.forEach(element=>{const removedTransforms=removeNonTranslationalTransform(element);if(!removedTransforms.length)return;transformsToRestore.set(element,removedTransforms);element.render();});// Read\nresolversToMeasure.forEach(resolver=>resolver.measureInitialState());// Write\nelementsToMeasure.forEach(element=>{element.render();const restore=transformsToRestore.get(element);if(restore){restore.forEach(_ref=>{var _element$getValue;let[key,value]=_ref;(_element$getValue=element.getValue(key))===null||_element$getValue===void 0?void 0:_element$getValue.set(value);});}});// Read\nresolversToMeasure.forEach(resolver=>resolver.measureEndState());// Write\nresolversToMeasure.forEach(resolver=>{if(resolver.suspendedScrollY!==undefined){window.scrollTo(0,resolver.suspendedScrollY);}});}anyNeedsMeasurement=false;isScheduled=false;toResolve.forEach(resolver=>resolver.complete(isForced));toResolve.clear();}function readAllKeyframes(){toResolve.forEach(resolver=>{resolver.readKeyframes();if(resolver.needsMeasurement){anyNeedsMeasurement=true;}});}function flushKeyframeResolvers(){isForced=true;readAllKeyframes();measureAllKeyframes();isForced=false;}class KeyframeResolver{constructor(unresolvedKeyframes,onComplete,name,motionValue,element){let isAsync=arguments.length>5&&arguments[5]!==undefined?arguments[5]:false;this.state=\"pending\";/**\n         * Track whether this resolver is async. If it is, it'll be added to the\n         * resolver queue and flushed in the next frame. Resolvers that aren't going\n         * to trigger read/write thrashing don't need to be async.\n         */this.isAsync=false;/**\n         * Track whether this resolver needs to perform a measurement\n         * to resolve its keyframes.\n         */this.needsMeasurement=false;this.unresolvedKeyframes=[...unresolvedKeyframes];this.onComplete=onComplete;this.name=name;this.motionValue=motionValue;this.element=element;this.isAsync=isAsync;}scheduleResolve(){this.state=\"scheduled\";if(this.isAsync){toResolve.add(this);if(!isScheduled){isScheduled=true;frame.read(readAllKeyframes);frame.resolveKeyframes(measureAllKeyframes);}}else{this.readKeyframes();this.complete();}}readKeyframes(){const{unresolvedKeyframes,name,element,motionValue}=this;// If initial keyframe is null we need to read it from the DOM\nif(unresolvedKeyframes[0]===null){const currentValue=motionValue===null||motionValue===void 0?void 0:motionValue.get();// TODO: This doesn't work if the final keyframe is a wildcard\nconst finalKeyframe=unresolvedKeyframes[unresolvedKeyframes.length-1];if(currentValue!==undefined){unresolvedKeyframes[0]=currentValue;}else if(element&&name){const valueAsRead=element.readValue(name,finalKeyframe);if(valueAsRead!==undefined&&valueAsRead!==null){unresolvedKeyframes[0]=valueAsRead;}}if(unresolvedKeyframes[0]===undefined){unresolvedKeyframes[0]=finalKeyframe;}if(motionValue&&currentValue===undefined){motionValue.set(unresolvedKeyframes[0]);}}fillWildcards(unresolvedKeyframes);}setFinalKeyframe(){}measureInitialState(){}renderEndStyles(){}measureEndState(){}complete(){let isForcedComplete=arguments.length>0&&arguments[0]!==undefined?arguments[0]:false;this.state=\"complete\";this.onComplete(this.unresolvedKeyframes,this.finalKeyframe,isForcedComplete);toResolve.delete(this);}cancel(){if(this.state===\"scheduled\"){toResolve.delete(this);this.state=\"pending\";}}resume(){if(this.state===\"pending\")this.scheduleResolve();}}export{KeyframeResolver,flushKeyframeResolvers};","map":{"version":3,"names":["fillWildcards","removeNonTranslationalTransform","frame","toResolve","Set","isScheduled","anyNeedsMeasurement","isForced","measureAllKeyframes","resolversToMeasure","Array","from","filter","resolver","needsMeasurement","elementsToMeasure","map","element","transformsToRestore","Map","forEach","removedTransforms","length","set","render","measureInitialState","restore","get","_ref","_element$getValue","key","value","getValue","measureEndState","suspendedScrollY","undefined","window","scrollTo","complete","clear","readAllKeyframes","readKeyframes","flushKeyframeResolvers","KeyframeResolver","constructor","unresolvedKeyframes","onComplete","name","motionValue","isAsync","arguments","state","scheduleResolve","add","read","resolveKeyframes","currentValue","finalKeyframe","valueAsRead","readValue","setFinalKeyframe","renderEndStyles","isForcedComplete","delete","cancel","resume"],"sources":["/home/antisyn/portfolio/src/components/node_modules/motion-dom/dist/es/animation/keyframes/KeyframesResolver.mjs"],"sourcesContent":["import { fillWildcards } from './utils/fill-wildcards.mjs';\nimport { removeNonTranslationalTransform } from './utils/unit-conversion.mjs';\nimport { frame } from '../../frameloop/frame.mjs';\n\nconst toResolve = new Set();\nlet isScheduled = false;\nlet anyNeedsMeasurement = false;\nlet isForced = false;\nfunction measureAllKeyframes() {\n    if (anyNeedsMeasurement) {\n        const resolversToMeasure = Array.from(toResolve).filter((resolver) => resolver.needsMeasurement);\n        const elementsToMeasure = new Set(resolversToMeasure.map((resolver) => resolver.element));\n        const transformsToRestore = new Map();\n        /**\n         * Write pass\n         * If we're measuring elements we want to remove bounding box-changing transforms.\n         */\n        elementsToMeasure.forEach((element) => {\n            const removedTransforms = removeNonTranslationalTransform(element);\n            if (!removedTransforms.length)\n                return;\n            transformsToRestore.set(element, removedTransforms);\n            element.render();\n        });\n        // Read\n        resolversToMeasure.forEach((resolver) => resolver.measureInitialState());\n        // Write\n        elementsToMeasure.forEach((element) => {\n            element.render();\n            const restore = transformsToRestore.get(element);\n            if (restore) {\n                restore.forEach(([key, value]) => {\n                    element.getValue(key)?.set(value);\n                });\n            }\n        });\n        // Read\n        resolversToMeasure.forEach((resolver) => resolver.measureEndState());\n        // Write\n        resolversToMeasure.forEach((resolver) => {\n            if (resolver.suspendedScrollY !== undefined) {\n                window.scrollTo(0, resolver.suspendedScrollY);\n            }\n        });\n    }\n    anyNeedsMeasurement = false;\n    isScheduled = false;\n    toResolve.forEach((resolver) => resolver.complete(isForced));\n    toResolve.clear();\n}\nfunction readAllKeyframes() {\n    toResolve.forEach((resolver) => {\n        resolver.readKeyframes();\n        if (resolver.needsMeasurement) {\n            anyNeedsMeasurement = true;\n        }\n    });\n}\nfunction flushKeyframeResolvers() {\n    isForced = true;\n    readAllKeyframes();\n    measureAllKeyframes();\n    isForced = false;\n}\nclass KeyframeResolver {\n    constructor(unresolvedKeyframes, onComplete, name, motionValue, element, isAsync = false) {\n        this.state = \"pending\";\n        /**\n         * Track whether this resolver is async. If it is, it'll be added to the\n         * resolver queue and flushed in the next frame. Resolvers that aren't going\n         * to trigger read/write thrashing don't need to be async.\n         */\n        this.isAsync = false;\n        /**\n         * Track whether this resolver needs to perform a measurement\n         * to resolve its keyframes.\n         */\n        this.needsMeasurement = false;\n        this.unresolvedKeyframes = [...unresolvedKeyframes];\n        this.onComplete = onComplete;\n        this.name = name;\n        this.motionValue = motionValue;\n        this.element = element;\n        this.isAsync = isAsync;\n    }\n    scheduleResolve() {\n        this.state = \"scheduled\";\n        if (this.isAsync) {\n            toResolve.add(this);\n            if (!isScheduled) {\n                isScheduled = true;\n                frame.read(readAllKeyframes);\n                frame.resolveKeyframes(measureAllKeyframes);\n            }\n        }\n        else {\n            this.readKeyframes();\n            this.complete();\n        }\n    }\n    readKeyframes() {\n        const { unresolvedKeyframes, name, element, motionValue } = this;\n        // If initial keyframe is null we need to read it from the DOM\n        if (unresolvedKeyframes[0] === null) {\n            const currentValue = motionValue?.get();\n            // TODO: This doesn't work if the final keyframe is a wildcard\n            const finalKeyframe = unresolvedKeyframes[unresolvedKeyframes.length - 1];\n            if (currentValue !== undefined) {\n                unresolvedKeyframes[0] = currentValue;\n            }\n            else if (element && name) {\n                const valueAsRead = element.readValue(name, finalKeyframe);\n                if (valueAsRead !== undefined && valueAsRead !== null) {\n                    unresolvedKeyframes[0] = valueAsRead;\n                }\n            }\n            if (unresolvedKeyframes[0] === undefined) {\n                unresolvedKeyframes[0] = finalKeyframe;\n            }\n            if (motionValue && currentValue === undefined) {\n                motionValue.set(unresolvedKeyframes[0]);\n            }\n        }\n        fillWildcards(unresolvedKeyframes);\n    }\n    setFinalKeyframe() { }\n    measureInitialState() { }\n    renderEndStyles() { }\n    measureEndState() { }\n    complete(isForcedComplete = false) {\n        this.state = \"complete\";\n        this.onComplete(this.unresolvedKeyframes, this.finalKeyframe, isForcedComplete);\n        toResolve.delete(this);\n    }\n    cancel() {\n        if (this.state === \"scheduled\") {\n            toResolve.delete(this);\n            this.state = \"pending\";\n        }\n    }\n    resume() {\n        if (this.state === \"pending\")\n            this.scheduleResolve();\n    }\n}\n\nexport { KeyframeResolver, flushKeyframeResolvers };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}