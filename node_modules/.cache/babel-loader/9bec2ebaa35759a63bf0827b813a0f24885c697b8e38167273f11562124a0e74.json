{"ast":null,"code":"import{isHTMLElement}from'motion-dom';function calcInset(element,container){const inset={x:0,y:0};let current=element;while(current&&current!==container){if(isHTMLElement(current)){inset.x+=current.offsetLeft;inset.y+=current.offsetTop;current=current.offsetParent;}else if(current.tagName===\"svg\"){/**\n             * This isn't an ideal approach to measuring the offset of <svg /> tags.\n             * It would be preferable, given they behave like HTMLElements in most ways\n             * to use offsetLeft/Top. But these don't exist on <svg />. Likewise we\n             * can't use .getBBox() like most SVG elements as these provide the offset\n             * relative to the SVG itself, which for <svg /> is usually 0x0.\n             */const svgBoundingBox=current.getBoundingClientRect();current=current.parentElement;const parentBoundingBox=current.getBoundingClientRect();inset.x+=svgBoundingBox.left-parentBoundingBox.left;inset.y+=svgBoundingBox.top-parentBoundingBox.top;}else if(current instanceof SVGGraphicsElement){const{x,y}=current.getBBox();inset.x+=x;inset.y+=y;let svg=null;let parent=current.parentNode;while(!svg){if(parent.tagName===\"svg\"){svg=parent;}parent=current.parentNode;}current=svg;}else{break;}}return inset;}export{calcInset};","map":{"version":3,"names":["isHTMLElement","calcInset","element","container","inset","x","y","current","offsetLeft","offsetTop","offsetParent","tagName","svgBoundingBox","getBoundingClientRect","parentElement","parentBoundingBox","left","top","SVGGraphicsElement","getBBox","svg","parent","parentNode"],"sources":["/home/antisyn/portfolio/src/components/node_modules/framer-motion/dist/es/render/dom/scroll/offsets/inset.mjs"],"sourcesContent":["import { isHTMLElement } from 'motion-dom';\n\nfunction calcInset(element, container) {\n    const inset = { x: 0, y: 0 };\n    let current = element;\n    while (current && current !== container) {\n        if (isHTMLElement(current)) {\n            inset.x += current.offsetLeft;\n            inset.y += current.offsetTop;\n            current = current.offsetParent;\n        }\n        else if (current.tagName === \"svg\") {\n            /**\n             * This isn't an ideal approach to measuring the offset of <svg /> tags.\n             * It would be preferable, given they behave like HTMLElements in most ways\n             * to use offsetLeft/Top. But these don't exist on <svg />. Likewise we\n             * can't use .getBBox() like most SVG elements as these provide the offset\n             * relative to the SVG itself, which for <svg /> is usually 0x0.\n             */\n            const svgBoundingBox = current.getBoundingClientRect();\n            current = current.parentElement;\n            const parentBoundingBox = current.getBoundingClientRect();\n            inset.x += svgBoundingBox.left - parentBoundingBox.left;\n            inset.y += svgBoundingBox.top - parentBoundingBox.top;\n        }\n        else if (current instanceof SVGGraphicsElement) {\n            const { x, y } = current.getBBox();\n            inset.x += x;\n            inset.y += y;\n            let svg = null;\n            let parent = current.parentNode;\n            while (!svg) {\n                if (parent.tagName === \"svg\") {\n                    svg = parent;\n                }\n                parent = current.parentNode;\n            }\n            current = svg;\n        }\n        else {\n            break;\n        }\n    }\n    return inset;\n}\n\nexport { calcInset };\n"],"mappings":"AAAA,OAASA,aAAa,KAAQ,YAAY,CAE1C,QAAS,CAAAC,SAASA,CAACC,OAAO,CAAEC,SAAS,CAAE,CACnC,KAAM,CAAAC,KAAK,CAAG,CAAEC,CAAC,CAAE,CAAC,CAAEC,CAAC,CAAE,CAAE,CAAC,CAC5B,GAAI,CAAAC,OAAO,CAAGL,OAAO,CACrB,MAAOK,OAAO,EAAIA,OAAO,GAAKJ,SAAS,CAAE,CACrC,GAAIH,aAAa,CAACO,OAAO,CAAC,CAAE,CACxBH,KAAK,CAACC,CAAC,EAAIE,OAAO,CAACC,UAAU,CAC7BJ,KAAK,CAACE,CAAC,EAAIC,OAAO,CAACE,SAAS,CAC5BF,OAAO,CAAGA,OAAO,CAACG,YAAY,CAClC,CAAC,IACI,IAAIH,OAAO,CAACI,OAAO,GAAK,KAAK,CAAE,CAChC;AACZ;AACA;AACA;AACA;AACA;AACA,eACY,KAAM,CAAAC,cAAc,CAAGL,OAAO,CAACM,qBAAqB,CAAC,CAAC,CACtDN,OAAO,CAAGA,OAAO,CAACO,aAAa,CAC/B,KAAM,CAAAC,iBAAiB,CAAGR,OAAO,CAACM,qBAAqB,CAAC,CAAC,CACzDT,KAAK,CAACC,CAAC,EAAIO,cAAc,CAACI,IAAI,CAAGD,iBAAiB,CAACC,IAAI,CACvDZ,KAAK,CAACE,CAAC,EAAIM,cAAc,CAACK,GAAG,CAAGF,iBAAiB,CAACE,GAAG,CACzD,CAAC,IACI,IAAIV,OAAO,WAAY,CAAAW,kBAAkB,CAAE,CAC5C,KAAM,CAAEb,CAAC,CAAEC,CAAE,CAAC,CAAGC,OAAO,CAACY,OAAO,CAAC,CAAC,CAClCf,KAAK,CAACC,CAAC,EAAIA,CAAC,CACZD,KAAK,CAACE,CAAC,EAAIA,CAAC,CACZ,GAAI,CAAAc,GAAG,CAAG,IAAI,CACd,GAAI,CAAAC,MAAM,CAAGd,OAAO,CAACe,UAAU,CAC/B,MAAO,CAACF,GAAG,CAAE,CACT,GAAIC,MAAM,CAACV,OAAO,GAAK,KAAK,CAAE,CAC1BS,GAAG,CAAGC,MAAM,CAChB,CACAA,MAAM,CAAGd,OAAO,CAACe,UAAU,CAC/B,CACAf,OAAO,CAAGa,GAAG,CACjB,CAAC,IACI,CACD,MACJ,CACJ,CACA,MAAO,CAAAhB,KAAK,CAChB,CAEA,OAASH,SAAS","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}