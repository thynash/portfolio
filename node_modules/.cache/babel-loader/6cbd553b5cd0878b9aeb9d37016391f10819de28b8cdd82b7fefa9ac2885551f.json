{"ast":null,"code":"import{mixNumber}from'motion-dom';import{hasTransform}from'../utils/has-transform.mjs';/**\n * Scales a point based on a factor and an originPoint\n */function scalePoint(point,scale,originPoint){const distanceFromOrigin=point-originPoint;const scaled=scale*distanceFromOrigin;return originPoint+scaled;}/**\n * Applies a translate/scale delta to a point\n */function applyPointDelta(point,translate,scale,originPoint,boxScale){if(boxScale!==undefined){point=scalePoint(point,boxScale,originPoint);}return scalePoint(point,scale,originPoint)+translate;}/**\n * Applies a translate/scale delta to an axis\n */function applyAxisDelta(axis){let translate=arguments.length>1&&arguments[1]!==undefined?arguments[1]:0;let scale=arguments.length>2&&arguments[2]!==undefined?arguments[2]:1;let originPoint=arguments.length>3?arguments[3]:undefined;let boxScale=arguments.length>4?arguments[4]:undefined;axis.min=applyPointDelta(axis.min,translate,scale,originPoint,boxScale);axis.max=applyPointDelta(axis.max,translate,scale,originPoint,boxScale);}/**\n * Applies a translate/scale delta to a box\n */function applyBoxDelta(box,_ref){let{x,y}=_ref;applyAxisDelta(box.x,x.translate,x.scale,x.originPoint);applyAxisDelta(box.y,y.translate,y.scale,y.originPoint);}const TREE_SCALE_SNAP_MIN=0.999999999999;const TREE_SCALE_SNAP_MAX=1.0000000000001;/**\n * Apply a tree of deltas to a box. We do this to calculate the effect of all the transforms\n * in a tree upon our box before then calculating how to project it into our desired viewport-relative box\n *\n * This is the final nested loop within updateLayoutDelta for future refactoring\n */function applyTreeDeltas(box,treeScale,treePath){let isSharedTransition=arguments.length>3&&arguments[3]!==undefined?arguments[3]:false;const treeLength=treePath.length;if(!treeLength)return;// Reset the treeScale\ntreeScale.x=treeScale.y=1;let node;let delta;for(let i=0;i<treeLength;i++){node=treePath[i];delta=node.projectionDelta;/**\n         * TODO: Prefer to remove this, but currently we have motion components with\n         * display: contents in Framer.\n         */const{visualElement}=node.options;if(visualElement&&visualElement.props.style&&visualElement.props.style.display===\"contents\"){continue;}if(isSharedTransition&&node.options.layoutScroll&&node.scroll&&node!==node.root){transformBox(box,{x:-node.scroll.offset.x,y:-node.scroll.offset.y});}if(delta){// Incoporate each ancestor's scale into a culmulative treeScale for this component\ntreeScale.x*=delta.x.scale;treeScale.y*=delta.y.scale;// Apply each ancestor's calculated delta into this component's recorded layout box\napplyBoxDelta(box,delta);}if(isSharedTransition&&hasTransform(node.latestValues)){transformBox(box,node.latestValues);}}/**\n     * Snap tree scale back to 1 if it's within a non-perceivable threshold.\n     * This will help reduce useless scales getting rendered.\n     */if(treeScale.x<TREE_SCALE_SNAP_MAX&&treeScale.x>TREE_SCALE_SNAP_MIN){treeScale.x=1.0;}if(treeScale.y<TREE_SCALE_SNAP_MAX&&treeScale.y>TREE_SCALE_SNAP_MIN){treeScale.y=1.0;}}function translateAxis(axis,distance){axis.min=axis.min+distance;axis.max=axis.max+distance;}/**\n * Apply a transform to an axis from the latest resolved motion values.\n * This function basically acts as a bridge between a flat motion value map\n * and applyAxisDelta\n */function transformAxis(axis,axisTranslate,axisScale,boxScale){let axisOrigin=arguments.length>4&&arguments[4]!==undefined?arguments[4]:0.5;const originPoint=mixNumber(axis.min,axis.max,axisOrigin);// Apply the axis delta to the final axis\napplyAxisDelta(axis,axisTranslate,axisScale,originPoint,boxScale);}/**\n * Apply a transform to a box from the latest resolved motion values.\n */function transformBox(box,transform){transformAxis(box.x,transform.x,transform.scaleX,transform.scale,transform.originX);transformAxis(box.y,transform.y,transform.scaleY,transform.scale,transform.originY);}export{applyAxisDelta,applyBoxDelta,applyPointDelta,applyTreeDeltas,scalePoint,transformAxis,transformBox,translateAxis};","map":{"version":3,"names":["mixNumber","hasTransform","scalePoint","point","scale","originPoint","distanceFromOrigin","scaled","applyPointDelta","translate","boxScale","undefined","applyAxisDelta","axis","arguments","length","min","max","applyBoxDelta","box","_ref","x","y","TREE_SCALE_SNAP_MIN","TREE_SCALE_SNAP_MAX","applyTreeDeltas","treeScale","treePath","isSharedTransition","treeLength","node","delta","i","projectionDelta","visualElement","options","props","style","display","layoutScroll","scroll","root","transformBox","offset","latestValues","translateAxis","distance","transformAxis","axisTranslate","axisScale","axisOrigin","transform","scaleX","originX","scaleY","originY"],"sources":["/home/antisyn/portfolio/src/components/node_modules/framer-motion/dist/es/projection/geometry/delta-apply.mjs"],"sourcesContent":["import { mixNumber } from 'motion-dom';\nimport { hasTransform } from '../utils/has-transform.mjs';\n\n/**\n * Scales a point based on a factor and an originPoint\n */\nfunction scalePoint(point, scale, originPoint) {\n    const distanceFromOrigin = point - originPoint;\n    const scaled = scale * distanceFromOrigin;\n    return originPoint + scaled;\n}\n/**\n * Applies a translate/scale delta to a point\n */\nfunction applyPointDelta(point, translate, scale, originPoint, boxScale) {\n    if (boxScale !== undefined) {\n        point = scalePoint(point, boxScale, originPoint);\n    }\n    return scalePoint(point, scale, originPoint) + translate;\n}\n/**\n * Applies a translate/scale delta to an axis\n */\nfunction applyAxisDelta(axis, translate = 0, scale = 1, originPoint, boxScale) {\n    axis.min = applyPointDelta(axis.min, translate, scale, originPoint, boxScale);\n    axis.max = applyPointDelta(axis.max, translate, scale, originPoint, boxScale);\n}\n/**\n * Applies a translate/scale delta to a box\n */\nfunction applyBoxDelta(box, { x, y }) {\n    applyAxisDelta(box.x, x.translate, x.scale, x.originPoint);\n    applyAxisDelta(box.y, y.translate, y.scale, y.originPoint);\n}\nconst TREE_SCALE_SNAP_MIN = 0.999999999999;\nconst TREE_SCALE_SNAP_MAX = 1.0000000000001;\n/**\n * Apply a tree of deltas to a box. We do this to calculate the effect of all the transforms\n * in a tree upon our box before then calculating how to project it into our desired viewport-relative box\n *\n * This is the final nested loop within updateLayoutDelta for future refactoring\n */\nfunction applyTreeDeltas(box, treeScale, treePath, isSharedTransition = false) {\n    const treeLength = treePath.length;\n    if (!treeLength)\n        return;\n    // Reset the treeScale\n    treeScale.x = treeScale.y = 1;\n    let node;\n    let delta;\n    for (let i = 0; i < treeLength; i++) {\n        node = treePath[i];\n        delta = node.projectionDelta;\n        /**\n         * TODO: Prefer to remove this, but currently we have motion components with\n         * display: contents in Framer.\n         */\n        const { visualElement } = node.options;\n        if (visualElement &&\n            visualElement.props.style &&\n            visualElement.props.style.display === \"contents\") {\n            continue;\n        }\n        if (isSharedTransition &&\n            node.options.layoutScroll &&\n            node.scroll &&\n            node !== node.root) {\n            transformBox(box, {\n                x: -node.scroll.offset.x,\n                y: -node.scroll.offset.y,\n            });\n        }\n        if (delta) {\n            // Incoporate each ancestor's scale into a culmulative treeScale for this component\n            treeScale.x *= delta.x.scale;\n            treeScale.y *= delta.y.scale;\n            // Apply each ancestor's calculated delta into this component's recorded layout box\n            applyBoxDelta(box, delta);\n        }\n        if (isSharedTransition && hasTransform(node.latestValues)) {\n            transformBox(box, node.latestValues);\n        }\n    }\n    /**\n     * Snap tree scale back to 1 if it's within a non-perceivable threshold.\n     * This will help reduce useless scales getting rendered.\n     */\n    if (treeScale.x < TREE_SCALE_SNAP_MAX &&\n        treeScale.x > TREE_SCALE_SNAP_MIN) {\n        treeScale.x = 1.0;\n    }\n    if (treeScale.y < TREE_SCALE_SNAP_MAX &&\n        treeScale.y > TREE_SCALE_SNAP_MIN) {\n        treeScale.y = 1.0;\n    }\n}\nfunction translateAxis(axis, distance) {\n    axis.min = axis.min + distance;\n    axis.max = axis.max + distance;\n}\n/**\n * Apply a transform to an axis from the latest resolved motion values.\n * This function basically acts as a bridge between a flat motion value map\n * and applyAxisDelta\n */\nfunction transformAxis(axis, axisTranslate, axisScale, boxScale, axisOrigin = 0.5) {\n    const originPoint = mixNumber(axis.min, axis.max, axisOrigin);\n    // Apply the axis delta to the final axis\n    applyAxisDelta(axis, axisTranslate, axisScale, originPoint, boxScale);\n}\n/**\n * Apply a transform to a box from the latest resolved motion values.\n */\nfunction transformBox(box, transform) {\n    transformAxis(box.x, transform.x, transform.scaleX, transform.scale, transform.originX);\n    transformAxis(box.y, transform.y, transform.scaleY, transform.scale, transform.originY);\n}\n\nexport { applyAxisDelta, applyBoxDelta, applyPointDelta, applyTreeDeltas, scalePoint, transformAxis, transformBox, translateAxis };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}