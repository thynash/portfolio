{"ast":null,"code":"import{interpolate,defaultOffset}from'motion-dom';import{clamp}from'motion-utils';import{calcInset}from'./inset.mjs';import{resolveOffset}from'./offset.mjs';import{ScrollOffset}from'./presets.mjs';const point={x:0,y:0};function getTargetSize(target){return\"getBBox\"in target&&target.tagName!==\"svg\"?target.getBBox():{width:target.clientWidth,height:target.clientHeight};}function resolveOffsets(container,info,options){const{offset:offsetDefinition=ScrollOffset.All}=options;const{target=container,axis=\"y\"}=options;const lengthLabel=axis===\"y\"?\"height\":\"width\";const inset=target!==container?calcInset(target,container):point;/**\n     * Measure the target and container. If they're the same thing then we\n     * use the container's scrollWidth/Height as the target, from there\n     * all other calculations can remain the same.\n     */const targetSize=target===container?{width:container.scrollWidth,height:container.scrollHeight}:getTargetSize(target);const containerSize={width:container.clientWidth,height:container.clientHeight};/**\n     * Reset the length of the resolved offset array rather than creating a new one.\n     * TODO: More reusable data structures for targetSize/containerSize would also be good.\n     */info[axis].offset.length=0;/**\n     * Populate the offset array by resolving the user's offset definition into\n     * a list of pixel scroll offets.\n     */let hasChanged=!info[axis].interpolate;const numOffsets=offsetDefinition.length;for(let i=0;i<numOffsets;i++){const offset=resolveOffset(offsetDefinition[i],containerSize[lengthLabel],targetSize[lengthLabel],inset[axis]);if(!hasChanged&&offset!==info[axis].interpolatorOffsets[i]){hasChanged=true;}info[axis].offset[i]=offset;}/**\n     * If the pixel scroll offsets have changed, create a new interpolator function\n     * to map scroll value into a progress.\n     */if(hasChanged){info[axis].interpolate=interpolate(info[axis].offset,defaultOffset(offsetDefinition),{clamp:false});info[axis].interpolatorOffsets=[...info[axis].offset];}info[axis].progress=clamp(0,1,info[axis].interpolate(info[axis].current));}export{resolveOffsets};","map":{"version":3,"names":["interpolate","defaultOffset","clamp","calcInset","resolveOffset","ScrollOffset","point","x","y","getTargetSize","target","tagName","getBBox","width","clientWidth","height","clientHeight","resolveOffsets","container","info","options","offset","offsetDefinition","All","axis","lengthLabel","inset","targetSize","scrollWidth","scrollHeight","containerSize","length","hasChanged","numOffsets","i","interpolatorOffsets","progress","current"],"sources":["/home/antisyn/portfolio/src/components/node_modules/framer-motion/dist/es/render/dom/scroll/offsets/index.mjs"],"sourcesContent":["import { interpolate, defaultOffset } from 'motion-dom';\nimport { clamp } from 'motion-utils';\nimport { calcInset } from './inset.mjs';\nimport { resolveOffset } from './offset.mjs';\nimport { ScrollOffset } from './presets.mjs';\n\nconst point = { x: 0, y: 0 };\nfunction getTargetSize(target) {\n    return \"getBBox\" in target && target.tagName !== \"svg\"\n        ? target.getBBox()\n        : { width: target.clientWidth, height: target.clientHeight };\n}\nfunction resolveOffsets(container, info, options) {\n    const { offset: offsetDefinition = ScrollOffset.All } = options;\n    const { target = container, axis = \"y\" } = options;\n    const lengthLabel = axis === \"y\" ? \"height\" : \"width\";\n    const inset = target !== container ? calcInset(target, container) : point;\n    /**\n     * Measure the target and container. If they're the same thing then we\n     * use the container's scrollWidth/Height as the target, from there\n     * all other calculations can remain the same.\n     */\n    const targetSize = target === container\n        ? { width: container.scrollWidth, height: container.scrollHeight }\n        : getTargetSize(target);\n    const containerSize = {\n        width: container.clientWidth,\n        height: container.clientHeight,\n    };\n    /**\n     * Reset the length of the resolved offset array rather than creating a new one.\n     * TODO: More reusable data structures for targetSize/containerSize would also be good.\n     */\n    info[axis].offset.length = 0;\n    /**\n     * Populate the offset array by resolving the user's offset definition into\n     * a list of pixel scroll offets.\n     */\n    let hasChanged = !info[axis].interpolate;\n    const numOffsets = offsetDefinition.length;\n    for (let i = 0; i < numOffsets; i++) {\n        const offset = resolveOffset(offsetDefinition[i], containerSize[lengthLabel], targetSize[lengthLabel], inset[axis]);\n        if (!hasChanged && offset !== info[axis].interpolatorOffsets[i]) {\n            hasChanged = true;\n        }\n        info[axis].offset[i] = offset;\n    }\n    /**\n     * If the pixel scroll offsets have changed, create a new interpolator function\n     * to map scroll value into a progress.\n     */\n    if (hasChanged) {\n        info[axis].interpolate = interpolate(info[axis].offset, defaultOffset(offsetDefinition), { clamp: false });\n        info[axis].interpolatorOffsets = [...info[axis].offset];\n    }\n    info[axis].progress = clamp(0, 1, info[axis].interpolate(info[axis].current));\n}\n\nexport { resolveOffsets };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}