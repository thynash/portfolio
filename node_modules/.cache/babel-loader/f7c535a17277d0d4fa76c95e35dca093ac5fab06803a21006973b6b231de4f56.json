{"ast":null,"code":"import{complex,mixNumber}from'motion-dom';const correctBoxShadow={correct:(latest,_ref)=>{let{treeScale,projectionDelta}=_ref;const original=latest;const shadow=complex.parse(latest);// TODO: Doesn't support multiple shadows\nif(shadow.length>5)return original;const template=complex.createTransformer(latest);const offset=typeof shadow[0]!==\"number\"?1:0;// Calculate the overall context scale\nconst xScale=projectionDelta.x.scale*treeScale.x;const yScale=projectionDelta.y.scale*treeScale.y;shadow[0+offset]/=xScale;shadow[1+offset]/=yScale;/**\n         * Ideally we'd correct x and y scales individually, but because blur and\n         * spread apply to both we have to take a scale average and apply that instead.\n         * We could potentially improve the outcome of this by incorporating the ratio between\n         * the two scales.\n         */const averageScale=mixNumber(xScale,yScale,0.5);// Blur\nif(typeof shadow[2+offset]===\"number\")shadow[2+offset]/=averageScale;// Spread\nif(typeof shadow[3+offset]===\"number\")shadow[3+offset]/=averageScale;return template(shadow);}};export{correctBoxShadow};","map":{"version":3,"names":["complex","mixNumber","correctBoxShadow","correct","latest","_ref","treeScale","projectionDelta","original","shadow","parse","length","template","createTransformer","offset","xScale","x","scale","yScale","y","averageScale"],"sources":["/home/antisyn/portfolio/src/components/node_modules/framer-motion/dist/es/projection/styles/scale-box-shadow.mjs"],"sourcesContent":["import { complex, mixNumber } from 'motion-dom';\n\nconst correctBoxShadow = {\n    correct: (latest, { treeScale, projectionDelta }) => {\n        const original = latest;\n        const shadow = complex.parse(latest);\n        // TODO: Doesn't support multiple shadows\n        if (shadow.length > 5)\n            return original;\n        const template = complex.createTransformer(latest);\n        const offset = typeof shadow[0] !== \"number\" ? 1 : 0;\n        // Calculate the overall context scale\n        const xScale = projectionDelta.x.scale * treeScale.x;\n        const yScale = projectionDelta.y.scale * treeScale.y;\n        shadow[0 + offset] /= xScale;\n        shadow[1 + offset] /= yScale;\n        /**\n         * Ideally we'd correct x and y scales individually, but because blur and\n         * spread apply to both we have to take a scale average and apply that instead.\n         * We could potentially improve the outcome of this by incorporating the ratio between\n         * the two scales.\n         */\n        const averageScale = mixNumber(xScale, yScale, 0.5);\n        // Blur\n        if (typeof shadow[2 + offset] === \"number\")\n            shadow[2 + offset] /= averageScale;\n        // Spread\n        if (typeof shadow[3 + offset] === \"number\")\n            shadow[3 + offset] /= averageScale;\n        return template(shadow);\n    },\n};\n\nexport { correctBoxShadow };\n"],"mappings":"AAAA,OAASA,OAAO,CAAEC,SAAS,KAAQ,YAAY,CAE/C,KAAM,CAAAC,gBAAgB,CAAG,CACrBC,OAAO,CAAEA,CAACC,MAAM,CAAAC,IAAA,GAAqC,IAAnC,CAAEC,SAAS,CAAEC,eAAgB,CAAC,CAAAF,IAAA,CAC5C,KAAM,CAAAG,QAAQ,CAAGJ,MAAM,CACvB,KAAM,CAAAK,MAAM,CAAGT,OAAO,CAACU,KAAK,CAACN,MAAM,CAAC,CACpC;AACA,GAAIK,MAAM,CAACE,MAAM,CAAG,CAAC,CACjB,MAAO,CAAAH,QAAQ,CACnB,KAAM,CAAAI,QAAQ,CAAGZ,OAAO,CAACa,iBAAiB,CAACT,MAAM,CAAC,CAClD,KAAM,CAAAU,MAAM,CAAG,MAAO,CAAAL,MAAM,CAAC,CAAC,CAAC,GAAK,QAAQ,CAAG,CAAC,CAAG,CAAC,CACpD;AACA,KAAM,CAAAM,MAAM,CAAGR,eAAe,CAACS,CAAC,CAACC,KAAK,CAAGX,SAAS,CAACU,CAAC,CACpD,KAAM,CAAAE,MAAM,CAAGX,eAAe,CAACY,CAAC,CAACF,KAAK,CAAGX,SAAS,CAACa,CAAC,CACpDV,MAAM,CAAC,CAAC,CAAGK,MAAM,CAAC,EAAIC,MAAM,CAC5BN,MAAM,CAAC,CAAC,CAAGK,MAAM,CAAC,EAAII,MAAM,CAC5B;AACR;AACA;AACA;AACA;AACA,WACQ,KAAM,CAAAE,YAAY,CAAGnB,SAAS,CAACc,MAAM,CAAEG,MAAM,CAAE,GAAG,CAAC,CACnD;AACA,GAAI,MAAO,CAAAT,MAAM,CAAC,CAAC,CAAGK,MAAM,CAAC,GAAK,QAAQ,CACtCL,MAAM,CAAC,CAAC,CAAGK,MAAM,CAAC,EAAIM,YAAY,CACtC;AACA,GAAI,MAAO,CAAAX,MAAM,CAAC,CAAC,CAAGK,MAAM,CAAC,GAAK,QAAQ,CACtCL,MAAM,CAAC,CAAC,CAAGK,MAAM,CAAC,EAAIM,YAAY,CACtC,MAAO,CAAAR,QAAQ,CAACH,MAAM,CAAC,CAC3B,CACJ,CAAC,CAED,OAASP,gBAAgB","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}