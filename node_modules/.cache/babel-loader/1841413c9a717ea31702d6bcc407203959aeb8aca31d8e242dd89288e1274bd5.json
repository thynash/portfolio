{"ast":null,"code":"import _objectWithoutProperties from\"/home/antisyn/portfolio/node_modules/@babel/runtime/helpers/esm/objectWithoutProperties.js\";import _objectSpread from\"/home/antisyn/portfolio/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";const _excluded=[\"willChange\"];import{KeyframeResolver,time,frame,isMotionValue,cancelFrame,transformProps,motionValue,findValueType,complex,getAnimatableNone}from'motion-dom';import{warnOnce,isNumericalString,isZeroValueString,SubscriptionManager}from'motion-utils';import{featureDefinitions}from'../motion/features/definitions.mjs';import{createBox}from'../projection/geometry/models.mjs';import{initPrefersReducedMotion}from'../utils/reduced-motion/index.mjs';import{hasReducedMotionListener,prefersReducedMotion}from'../utils/reduced-motion/state.mjs';import{visualElementStore}from'./store.mjs';import{isControllingVariants,isVariantNode}from'./utils/is-controlling-variants.mjs';import{updateMotionValuesFromProps}from'./utils/motion-values.mjs';import{resolveVariantFromProps}from'./utils/resolve-variants.mjs';const propEventHandlers=[\"AnimationStart\",\"AnimationComplete\",\"Update\",\"BeforeLayoutMeasure\",\"LayoutMeasure\",\"LayoutAnimationStart\",\"LayoutAnimationComplete\"];/**\n * A VisualElement is an imperative abstraction around UI elements such as\n * HTMLElement, SVGElement, Three.Object3D etc.\n */class VisualElement{/**\n     * This method takes React props and returns found MotionValues. For example, HTML\n     * MotionValues will be found within the style prop, whereas for Three.js within attribute arrays.\n     *\n     * This isn't an abstract method as it needs calling in the constructor, but it is\n     * intended to be one.\n     */scrapeMotionValuesFromProps(_props,_prevProps,_visualElement){return{};}constructor(_ref){let{parent,props,presenceContext,reducedMotionConfig,blockInitialAnimation,visualState}=_ref;let options=arguments.length>1&&arguments[1]!==undefined?arguments[1]:{};/**\n         * A reference to the current underlying Instance, e.g. a HTMLElement\n         * or Three.Mesh etc.\n         */this.current=null;/**\n         * A set containing references to this VisualElement's children.\n         */this.children=new Set();/**\n         * Determine what role this visual element should take in the variant tree.\n         */this.isVariantNode=false;this.isControllingVariants=false;/**\n         * Decides whether this VisualElement should animate in reduced motion\n         * mode.\n         *\n         * TODO: This is currently set on every individual VisualElement but feels\n         * like it could be set globally.\n         */this.shouldReduceMotion=null;/**\n         * A map of all motion values attached to this visual element. Motion\n         * values are source of truth for any given animated value. A motion\n         * value might be provided externally by the component via props.\n         */this.values=new Map();this.KeyframeResolver=KeyframeResolver;/**\n         * Cleanup functions for active features (hover/tap/exit etc)\n         */this.features={};/**\n         * A map of every subscription that binds the provided or generated\n         * motion values onChange listeners to this visual element.\n         */this.valueSubscriptions=new Map();/**\n         * A reference to the previously-provided motion values as returned\n         * from scrapeMotionValuesFromProps. We use the keys in here to determine\n         * if any motion values need to be removed after props are updated.\n         */this.prevMotionValues={};/**\n         * An object containing a SubscriptionManager for each active event.\n         */this.events={};/**\n         * An object containing an unsubscribe function for each prop event subscription.\n         * For example, every \"Update\" event can have multiple subscribers via\n         * VisualElement.on(), but only one of those can be defined via the onUpdate prop.\n         */this.propEventSubscriptions={};this.notifyUpdate=()=>this.notify(\"Update\",this.latestValues);this.render=()=>{if(!this.current)return;this.triggerBuild();this.renderInstance(this.current,this.renderState,this.props.style,this.projection);};this.renderScheduledAt=0.0;this.scheduleRender=()=>{const now=time.now();if(this.renderScheduledAt<now){this.renderScheduledAt=now;frame.render(this.render,false,true);}};const{latestValues,renderState}=visualState;this.latestValues=latestValues;this.baseTarget=_objectSpread({},latestValues);this.initialValues=props.initial?_objectSpread({},latestValues):{};this.renderState=renderState;this.parent=parent;this.props=props;this.presenceContext=presenceContext;this.depth=parent?parent.depth+1:0;this.reducedMotionConfig=reducedMotionConfig;this.options=options;this.blockInitialAnimation=Boolean(blockInitialAnimation);this.isControllingVariants=isControllingVariants(props);this.isVariantNode=isVariantNode(props);if(this.isVariantNode){this.variantChildren=new Set();}this.manuallyAnimateOnMount=Boolean(parent&&parent.current);/**\n         * Any motion values that are provided to the element when created\n         * aren't yet bound to the element, as this would technically be impure.\n         * However, we iterate through the motion values and set them to the\n         * initial values for this component.\n         *\n         * TODO: This is impure and we should look at changing this to run on mount.\n         * Doing so will break some tests but this isn't necessarily a breaking change,\n         * more a reflection of the test.\n         */const _this$scrapeMotionVal=this.scrapeMotionValuesFromProps(props,{},this),{willChange}=_this$scrapeMotionVal,initialMotionValues=_objectWithoutProperties(_this$scrapeMotionVal,_excluded);for(const key in initialMotionValues){const value=initialMotionValues[key];if(latestValues[key]!==undefined&&isMotionValue(value)){value.set(latestValues[key],false);}}}mount(instance){this.current=instance;visualElementStore.set(instance,this);if(this.projection&&!this.projection.instance){this.projection.mount(instance);}if(this.parent&&this.isVariantNode&&!this.isControllingVariants){this.removeFromVariantTree=this.parent.addVariantChild(this);}this.values.forEach((value,key)=>this.bindToMotionValue(key,value));if(!hasReducedMotionListener.current){initPrefersReducedMotion();}this.shouldReduceMotion=this.reducedMotionConfig===\"never\"?false:this.reducedMotionConfig===\"always\"?true:prefersReducedMotion.current;if(process.env.NODE_ENV!==\"production\"){warnOnce(this.shouldReduceMotion!==true,\"You have Reduced Motion enabled on your device. Animations may not appear as expected.\");}if(this.parent)this.parent.children.add(this);this.update(this.props,this.presenceContext);}unmount(){this.projection&&this.projection.unmount();cancelFrame(this.notifyUpdate);cancelFrame(this.render);this.valueSubscriptions.forEach(remove=>remove());this.valueSubscriptions.clear();this.removeFromVariantTree&&this.removeFromVariantTree();this.parent&&this.parent.children.delete(this);for(const key in this.events){this.events[key].clear();}for(const key in this.features){const feature=this.features[key];if(feature){feature.unmount();feature.isMounted=false;}}this.current=null;}bindToMotionValue(key,value){if(this.valueSubscriptions.has(key)){this.valueSubscriptions.get(key)();}const valueIsTransform=transformProps.has(key);if(valueIsTransform&&this.onBindTransform){this.onBindTransform();}const removeOnChange=value.on(\"change\",latestValue=>{this.latestValues[key]=latestValue;this.props.onUpdate&&frame.preRender(this.notifyUpdate);if(valueIsTransform&&this.projection){this.projection.isTransformDirty=true;}});const removeOnRenderRequest=value.on(\"renderRequest\",this.scheduleRender);let removeSyncCheck;if(window.MotionCheckAppearSync){removeSyncCheck=window.MotionCheckAppearSync(this,key,value);}this.valueSubscriptions.set(key,()=>{removeOnChange();removeOnRenderRequest();if(removeSyncCheck)removeSyncCheck();if(value.owner)value.stop();});}sortNodePosition(other){/**\n         * If these nodes aren't even of the same type we can't compare their depth.\n         */if(!this.current||!this.sortInstanceNodePosition||this.type!==other.type){return 0;}return this.sortInstanceNodePosition(this.current,other.current);}updateFeatures(){let key=\"animation\";for(key in featureDefinitions){const featureDefinition=featureDefinitions[key];if(!featureDefinition)continue;const{isEnabled,Feature:FeatureConstructor}=featureDefinition;/**\n             * If this feature is enabled but not active, make a new instance.\n             */if(!this.features[key]&&FeatureConstructor&&isEnabled(this.props)){this.features[key]=new FeatureConstructor(this);}/**\n             * If we have a feature, mount or update it.\n             */if(this.features[key]){const feature=this.features[key];if(feature.isMounted){feature.update();}else{feature.mount();feature.isMounted=true;}}}}triggerBuild(){this.build(this.renderState,this.latestValues,this.props);}/**\n     * Measure the current viewport box with or without transforms.\n     * Only measures axis-aligned boxes, rotate and skew must be manually\n     * removed with a re-render to work.\n     */measureViewportBox(){return this.current?this.measureInstanceViewportBox(this.current,this.props):createBox();}getStaticValue(key){return this.latestValues[key];}setStaticValue(key,value){this.latestValues[key]=value;}/**\n     * Update the provided props. Ensure any newly-added motion values are\n     * added to our map, old ones removed, and listeners updated.\n     */update(props,presenceContext){if(props.transformTemplate||this.props.transformTemplate){this.scheduleRender();}this.prevProps=this.props;this.props=props;this.prevPresenceContext=this.presenceContext;this.presenceContext=presenceContext;/**\n         * Update prop event handlers ie onAnimationStart, onAnimationComplete\n         */for(let i=0;i<propEventHandlers.length;i++){const key=propEventHandlers[i];if(this.propEventSubscriptions[key]){this.propEventSubscriptions[key]();delete this.propEventSubscriptions[key];}const listenerName=\"on\"+key;const listener=props[listenerName];if(listener){this.propEventSubscriptions[key]=this.on(key,listener);}}this.prevMotionValues=updateMotionValuesFromProps(this,this.scrapeMotionValuesFromProps(props,this.prevProps,this),this.prevMotionValues);if(this.handleChildMotionValue){this.handleChildMotionValue();}}getProps(){return this.props;}/**\n     * Returns the variant definition with a given name.\n     */getVariant(name){return this.props.variants?this.props.variants[name]:undefined;}/**\n     * Returns the defined default transition on this component.\n     */getDefaultTransition(){return this.props.transition;}getTransformPagePoint(){return this.props.transformPagePoint;}getClosestVariantNode(){return this.isVariantNode?this:this.parent?this.parent.getClosestVariantNode():undefined;}/**\n     * Add a child visual element to our set of children.\n     */addVariantChild(child){const closestVariantNode=this.getClosestVariantNode();if(closestVariantNode){closestVariantNode.variantChildren&&closestVariantNode.variantChildren.add(child);return()=>closestVariantNode.variantChildren.delete(child);}}/**\n     * Add a motion value and bind it to this visual element.\n     */addValue(key,value){// Remove existing value if it exists\nconst existingValue=this.values.get(key);if(value!==existingValue){if(existingValue)this.removeValue(key);this.bindToMotionValue(key,value);this.values.set(key,value);this.latestValues[key]=value.get();}}/**\n     * Remove a motion value and unbind any active subscriptions.\n     */removeValue(key){this.values.delete(key);const unsubscribe=this.valueSubscriptions.get(key);if(unsubscribe){unsubscribe();this.valueSubscriptions.delete(key);}delete this.latestValues[key];this.removeValueFromRenderState(key,this.renderState);}/**\n     * Check whether we have a motion value for this key\n     */hasValue(key){return this.values.has(key);}getValue(key,defaultValue){if(this.props.values&&this.props.values[key]){return this.props.values[key];}let value=this.values.get(key);if(value===undefined&&defaultValue!==undefined){value=motionValue(defaultValue===null?undefined:defaultValue,{owner:this});this.addValue(key,value);}return value;}/**\n     * If we're trying to animate to a previously unencountered value,\n     * we need to check for it in our state and as a last resort read it\n     * directly from the instance (which might have performance implications).\n     */readValue(key,target){var _this$getBaseTargetFr;let value=this.latestValues[key]!==undefined||!this.current?this.latestValues[key]:(_this$getBaseTargetFr=this.getBaseTargetFromProps(this.props,key))!==null&&_this$getBaseTargetFr!==void 0?_this$getBaseTargetFr:this.readValueFromInstance(this.current,key,this.options);if(value!==undefined&&value!==null){if(typeof value===\"string\"&&(isNumericalString(value)||isZeroValueString(value))){// If this is a number read as a string, ie \"0\" or \"200\", convert it to a number\nvalue=parseFloat(value);}else if(!findValueType(value)&&complex.test(target)){value=getAnimatableNone(key,target);}this.setBaseTarget(key,isMotionValue(value)?value.get():value);}return isMotionValue(value)?value.get():value;}/**\n     * Set the base target to later animate back to. This is currently\n     * only hydrated on creation and when we first read a value.\n     */setBaseTarget(key,value){this.baseTarget[key]=value;}/**\n     * Find the base target for a value thats been removed from all animation\n     * props.\n     */getBaseTarget(key){const{initial}=this.props;let valueFromInitial;if(typeof initial===\"string\"||typeof initial===\"object\"){var _this$presenceContext;const variant=resolveVariantFromProps(this.props,initial,(_this$presenceContext=this.presenceContext)===null||_this$presenceContext===void 0?void 0:_this$presenceContext.custom);if(variant){valueFromInitial=variant[key];}}/**\n         * If this value still exists in the current initial variant, read that.\n         */if(initial&&valueFromInitial!==undefined){return valueFromInitial;}/**\n         * Alternatively, if this VisualElement config has defined a getBaseTarget\n         * so we can read the value from an alternative source, try that.\n         */const target=this.getBaseTargetFromProps(this.props,key);if(target!==undefined&&!isMotionValue(target))return target;/**\n         * If the value was initially defined on initial, but it doesn't any more,\n         * return undefined. Otherwise return the value as initially read from the DOM.\n         */return this.initialValues[key]!==undefined&&valueFromInitial===undefined?undefined:this.baseTarget[key];}on(eventName,callback){if(!this.events[eventName]){this.events[eventName]=new SubscriptionManager();}return this.events[eventName].add(callback);}notify(eventName){if(this.events[eventName]){for(var _len=arguments.length,args=new Array(_len>1?_len-1:0),_key=1;_key<_len;_key++){args[_key-1]=arguments[_key];}this.events[eventName].notify(...args);}}}export{VisualElement};","map":{"version":3,"names":["KeyframeResolver","time","frame","isMotionValue","cancelFrame","transformProps","motionValue","findValueType","complex","getAnimatableNone","warnOnce","isNumericalString","isZeroValueString","SubscriptionManager","featureDefinitions","createBox","initPrefersReducedMotion","hasReducedMotionListener","prefersReducedMotion","visualElementStore","isControllingVariants","isVariantNode","updateMotionValuesFromProps","resolveVariantFromProps","propEventHandlers","VisualElement","scrapeMotionValuesFromProps","_props","_prevProps","_visualElement","constructor","_ref","parent","props","presenceContext","reducedMotionConfig","blockInitialAnimation","visualState","options","arguments","length","undefined","current","children","Set","shouldReduceMotion","values","Map","features","valueSubscriptions","prevMotionValues","events","propEventSubscriptions","notifyUpdate","notify","latestValues","render","triggerBuild","renderInstance","renderState","style","projection","renderScheduledAt","scheduleRender","now","baseTarget","_objectSpread","initialValues","initial","depth","Boolean","variantChildren","manuallyAnimateOnMount","_this$scrapeMotionVal","willChange","initialMotionValues","_objectWithoutProperties","_excluded","key","value","set","mount","instance","removeFromVariantTree","addVariantChild","forEach","bindToMotionValue","process","env","NODE_ENV","add","update","unmount","remove","clear","delete","feature","isMounted","has","get","valueIsTransform","onBindTransform","removeOnChange","on","latestValue","onUpdate","preRender","isTransformDirty","removeOnRenderRequest","removeSyncCheck","window","MotionCheckAppearSync","owner","stop","sortNodePosition","other","sortInstanceNodePosition","type","updateFeatures","featureDefinition","isEnabled","Feature","FeatureConstructor","build","measureViewportBox","measureInstanceViewportBox","getStaticValue","setStaticValue","transformTemplate","prevProps","prevPresenceContext","i","listenerName","listener","handleChildMotionValue","getProps","getVariant","name","variants","getDefaultTransition","transition","getTransformPagePoint","transformPagePoint","getClosestVariantNode","child","closestVariantNode","addValue","existingValue","removeValue","unsubscribe","removeValueFromRenderState","hasValue","getValue","defaultValue","readValue","target","_this$getBaseTargetFr","getBaseTargetFromProps","readValueFromInstance","parseFloat","test","setBaseTarget","getBaseTarget","valueFromInitial","_this$presenceContext","variant","custom","eventName","callback","_len","args","Array","_key"],"sources":["/home/antisyn/portfolio/src/components/node_modules/framer-motion/dist/es/render/VisualElement.mjs"],"sourcesContent":["import { KeyframeResolver, time, frame, isMotionValue, cancelFrame, transformProps, motionValue, findValueType, complex, getAnimatableNone } from 'motion-dom';\nimport { warnOnce, isNumericalString, isZeroValueString, SubscriptionManager } from 'motion-utils';\nimport { featureDefinitions } from '../motion/features/definitions.mjs';\nimport { createBox } from '../projection/geometry/models.mjs';\nimport { initPrefersReducedMotion } from '../utils/reduced-motion/index.mjs';\nimport { hasReducedMotionListener, prefersReducedMotion } from '../utils/reduced-motion/state.mjs';\nimport { visualElementStore } from './store.mjs';\nimport { isControllingVariants, isVariantNode } from './utils/is-controlling-variants.mjs';\nimport { updateMotionValuesFromProps } from './utils/motion-values.mjs';\nimport { resolveVariantFromProps } from './utils/resolve-variants.mjs';\n\nconst propEventHandlers = [\n    \"AnimationStart\",\n    \"AnimationComplete\",\n    \"Update\",\n    \"BeforeLayoutMeasure\",\n    \"LayoutMeasure\",\n    \"LayoutAnimationStart\",\n    \"LayoutAnimationComplete\",\n];\n/**\n * A VisualElement is an imperative abstraction around UI elements such as\n * HTMLElement, SVGElement, Three.Object3D etc.\n */\nclass VisualElement {\n    /**\n     * This method takes React props and returns found MotionValues. For example, HTML\n     * MotionValues will be found within the style prop, whereas for Three.js within attribute arrays.\n     *\n     * This isn't an abstract method as it needs calling in the constructor, but it is\n     * intended to be one.\n     */\n    scrapeMotionValuesFromProps(_props, _prevProps, _visualElement) {\n        return {};\n    }\n    constructor({ parent, props, presenceContext, reducedMotionConfig, blockInitialAnimation, visualState, }, options = {}) {\n        /**\n         * A reference to the current underlying Instance, e.g. a HTMLElement\n         * or Three.Mesh etc.\n         */\n        this.current = null;\n        /**\n         * A set containing references to this VisualElement's children.\n         */\n        this.children = new Set();\n        /**\n         * Determine what role this visual element should take in the variant tree.\n         */\n        this.isVariantNode = false;\n        this.isControllingVariants = false;\n        /**\n         * Decides whether this VisualElement should animate in reduced motion\n         * mode.\n         *\n         * TODO: This is currently set on every individual VisualElement but feels\n         * like it could be set globally.\n         */\n        this.shouldReduceMotion = null;\n        /**\n         * A map of all motion values attached to this visual element. Motion\n         * values are source of truth for any given animated value. A motion\n         * value might be provided externally by the component via props.\n         */\n        this.values = new Map();\n        this.KeyframeResolver = KeyframeResolver;\n        /**\n         * Cleanup functions for active features (hover/tap/exit etc)\n         */\n        this.features = {};\n        /**\n         * A map of every subscription that binds the provided or generated\n         * motion values onChange listeners to this visual element.\n         */\n        this.valueSubscriptions = new Map();\n        /**\n         * A reference to the previously-provided motion values as returned\n         * from scrapeMotionValuesFromProps. We use the keys in here to determine\n         * if any motion values need to be removed after props are updated.\n         */\n        this.prevMotionValues = {};\n        /**\n         * An object containing a SubscriptionManager for each active event.\n         */\n        this.events = {};\n        /**\n         * An object containing an unsubscribe function for each prop event subscription.\n         * For example, every \"Update\" event can have multiple subscribers via\n         * VisualElement.on(), but only one of those can be defined via the onUpdate prop.\n         */\n        this.propEventSubscriptions = {};\n        this.notifyUpdate = () => this.notify(\"Update\", this.latestValues);\n        this.render = () => {\n            if (!this.current)\n                return;\n            this.triggerBuild();\n            this.renderInstance(this.current, this.renderState, this.props.style, this.projection);\n        };\n        this.renderScheduledAt = 0.0;\n        this.scheduleRender = () => {\n            const now = time.now();\n            if (this.renderScheduledAt < now) {\n                this.renderScheduledAt = now;\n                frame.render(this.render, false, true);\n            }\n        };\n        const { latestValues, renderState } = visualState;\n        this.latestValues = latestValues;\n        this.baseTarget = { ...latestValues };\n        this.initialValues = props.initial ? { ...latestValues } : {};\n        this.renderState = renderState;\n        this.parent = parent;\n        this.props = props;\n        this.presenceContext = presenceContext;\n        this.depth = parent ? parent.depth + 1 : 0;\n        this.reducedMotionConfig = reducedMotionConfig;\n        this.options = options;\n        this.blockInitialAnimation = Boolean(blockInitialAnimation);\n        this.isControllingVariants = isControllingVariants(props);\n        this.isVariantNode = isVariantNode(props);\n        if (this.isVariantNode) {\n            this.variantChildren = new Set();\n        }\n        this.manuallyAnimateOnMount = Boolean(parent && parent.current);\n        /**\n         * Any motion values that are provided to the element when created\n         * aren't yet bound to the element, as this would technically be impure.\n         * However, we iterate through the motion values and set them to the\n         * initial values for this component.\n         *\n         * TODO: This is impure and we should look at changing this to run on mount.\n         * Doing so will break some tests but this isn't necessarily a breaking change,\n         * more a reflection of the test.\n         */\n        const { willChange, ...initialMotionValues } = this.scrapeMotionValuesFromProps(props, {}, this);\n        for (const key in initialMotionValues) {\n            const value = initialMotionValues[key];\n            if (latestValues[key] !== undefined && isMotionValue(value)) {\n                value.set(latestValues[key], false);\n            }\n        }\n    }\n    mount(instance) {\n        this.current = instance;\n        visualElementStore.set(instance, this);\n        if (this.projection && !this.projection.instance) {\n            this.projection.mount(instance);\n        }\n        if (this.parent && this.isVariantNode && !this.isControllingVariants) {\n            this.removeFromVariantTree = this.parent.addVariantChild(this);\n        }\n        this.values.forEach((value, key) => this.bindToMotionValue(key, value));\n        if (!hasReducedMotionListener.current) {\n            initPrefersReducedMotion();\n        }\n        this.shouldReduceMotion =\n            this.reducedMotionConfig === \"never\"\n                ? false\n                : this.reducedMotionConfig === \"always\"\n                    ? true\n                    : prefersReducedMotion.current;\n        if (process.env.NODE_ENV !== \"production\") {\n            warnOnce(this.shouldReduceMotion !== true, \"You have Reduced Motion enabled on your device. Animations may not appear as expected.\");\n        }\n        if (this.parent)\n            this.parent.children.add(this);\n        this.update(this.props, this.presenceContext);\n    }\n    unmount() {\n        this.projection && this.projection.unmount();\n        cancelFrame(this.notifyUpdate);\n        cancelFrame(this.render);\n        this.valueSubscriptions.forEach((remove) => remove());\n        this.valueSubscriptions.clear();\n        this.removeFromVariantTree && this.removeFromVariantTree();\n        this.parent && this.parent.children.delete(this);\n        for (const key in this.events) {\n            this.events[key].clear();\n        }\n        for (const key in this.features) {\n            const feature = this.features[key];\n            if (feature) {\n                feature.unmount();\n                feature.isMounted = false;\n            }\n        }\n        this.current = null;\n    }\n    bindToMotionValue(key, value) {\n        if (this.valueSubscriptions.has(key)) {\n            this.valueSubscriptions.get(key)();\n        }\n        const valueIsTransform = transformProps.has(key);\n        if (valueIsTransform && this.onBindTransform) {\n            this.onBindTransform();\n        }\n        const removeOnChange = value.on(\"change\", (latestValue) => {\n            this.latestValues[key] = latestValue;\n            this.props.onUpdate && frame.preRender(this.notifyUpdate);\n            if (valueIsTransform && this.projection) {\n                this.projection.isTransformDirty = true;\n            }\n        });\n        const removeOnRenderRequest = value.on(\"renderRequest\", this.scheduleRender);\n        let removeSyncCheck;\n        if (window.MotionCheckAppearSync) {\n            removeSyncCheck = window.MotionCheckAppearSync(this, key, value);\n        }\n        this.valueSubscriptions.set(key, () => {\n            removeOnChange();\n            removeOnRenderRequest();\n            if (removeSyncCheck)\n                removeSyncCheck();\n            if (value.owner)\n                value.stop();\n        });\n    }\n    sortNodePosition(other) {\n        /**\n         * If these nodes aren't even of the same type we can't compare their depth.\n         */\n        if (!this.current ||\n            !this.sortInstanceNodePosition ||\n            this.type !== other.type) {\n            return 0;\n        }\n        return this.sortInstanceNodePosition(this.current, other.current);\n    }\n    updateFeatures() {\n        let key = \"animation\";\n        for (key in featureDefinitions) {\n            const featureDefinition = featureDefinitions[key];\n            if (!featureDefinition)\n                continue;\n            const { isEnabled, Feature: FeatureConstructor } = featureDefinition;\n            /**\n             * If this feature is enabled but not active, make a new instance.\n             */\n            if (!this.features[key] &&\n                FeatureConstructor &&\n                isEnabled(this.props)) {\n                this.features[key] = new FeatureConstructor(this);\n            }\n            /**\n             * If we have a feature, mount or update it.\n             */\n            if (this.features[key]) {\n                const feature = this.features[key];\n                if (feature.isMounted) {\n                    feature.update();\n                }\n                else {\n                    feature.mount();\n                    feature.isMounted = true;\n                }\n            }\n        }\n    }\n    triggerBuild() {\n        this.build(this.renderState, this.latestValues, this.props);\n    }\n    /**\n     * Measure the current viewport box with or without transforms.\n     * Only measures axis-aligned boxes, rotate and skew must be manually\n     * removed with a re-render to work.\n     */\n    measureViewportBox() {\n        return this.current\n            ? this.measureInstanceViewportBox(this.current, this.props)\n            : createBox();\n    }\n    getStaticValue(key) {\n        return this.latestValues[key];\n    }\n    setStaticValue(key, value) {\n        this.latestValues[key] = value;\n    }\n    /**\n     * Update the provided props. Ensure any newly-added motion values are\n     * added to our map, old ones removed, and listeners updated.\n     */\n    update(props, presenceContext) {\n        if (props.transformTemplate || this.props.transformTemplate) {\n            this.scheduleRender();\n        }\n        this.prevProps = this.props;\n        this.props = props;\n        this.prevPresenceContext = this.presenceContext;\n        this.presenceContext = presenceContext;\n        /**\n         * Update prop event handlers ie onAnimationStart, onAnimationComplete\n         */\n        for (let i = 0; i < propEventHandlers.length; i++) {\n            const key = propEventHandlers[i];\n            if (this.propEventSubscriptions[key]) {\n                this.propEventSubscriptions[key]();\n                delete this.propEventSubscriptions[key];\n            }\n            const listenerName = (\"on\" + key);\n            const listener = props[listenerName];\n            if (listener) {\n                this.propEventSubscriptions[key] = this.on(key, listener);\n            }\n        }\n        this.prevMotionValues = updateMotionValuesFromProps(this, this.scrapeMotionValuesFromProps(props, this.prevProps, this), this.prevMotionValues);\n        if (this.handleChildMotionValue) {\n            this.handleChildMotionValue();\n        }\n    }\n    getProps() {\n        return this.props;\n    }\n    /**\n     * Returns the variant definition with a given name.\n     */\n    getVariant(name) {\n        return this.props.variants ? this.props.variants[name] : undefined;\n    }\n    /**\n     * Returns the defined default transition on this component.\n     */\n    getDefaultTransition() {\n        return this.props.transition;\n    }\n    getTransformPagePoint() {\n        return this.props.transformPagePoint;\n    }\n    getClosestVariantNode() {\n        return this.isVariantNode\n            ? this\n            : this.parent\n                ? this.parent.getClosestVariantNode()\n                : undefined;\n    }\n    /**\n     * Add a child visual element to our set of children.\n     */\n    addVariantChild(child) {\n        const closestVariantNode = this.getClosestVariantNode();\n        if (closestVariantNode) {\n            closestVariantNode.variantChildren &&\n                closestVariantNode.variantChildren.add(child);\n            return () => closestVariantNode.variantChildren.delete(child);\n        }\n    }\n    /**\n     * Add a motion value and bind it to this visual element.\n     */\n    addValue(key, value) {\n        // Remove existing value if it exists\n        const existingValue = this.values.get(key);\n        if (value !== existingValue) {\n            if (existingValue)\n                this.removeValue(key);\n            this.bindToMotionValue(key, value);\n            this.values.set(key, value);\n            this.latestValues[key] = value.get();\n        }\n    }\n    /**\n     * Remove a motion value and unbind any active subscriptions.\n     */\n    removeValue(key) {\n        this.values.delete(key);\n        const unsubscribe = this.valueSubscriptions.get(key);\n        if (unsubscribe) {\n            unsubscribe();\n            this.valueSubscriptions.delete(key);\n        }\n        delete this.latestValues[key];\n        this.removeValueFromRenderState(key, this.renderState);\n    }\n    /**\n     * Check whether we have a motion value for this key\n     */\n    hasValue(key) {\n        return this.values.has(key);\n    }\n    getValue(key, defaultValue) {\n        if (this.props.values && this.props.values[key]) {\n            return this.props.values[key];\n        }\n        let value = this.values.get(key);\n        if (value === undefined && defaultValue !== undefined) {\n            value = motionValue(defaultValue === null ? undefined : defaultValue, { owner: this });\n            this.addValue(key, value);\n        }\n        return value;\n    }\n    /**\n     * If we're trying to animate to a previously unencountered value,\n     * we need to check for it in our state and as a last resort read it\n     * directly from the instance (which might have performance implications).\n     */\n    readValue(key, target) {\n        let value = this.latestValues[key] !== undefined || !this.current\n            ? this.latestValues[key]\n            : this.getBaseTargetFromProps(this.props, key) ??\n                this.readValueFromInstance(this.current, key, this.options);\n        if (value !== undefined && value !== null) {\n            if (typeof value === \"string\" &&\n                (isNumericalString(value) || isZeroValueString(value))) {\n                // If this is a number read as a string, ie \"0\" or \"200\", convert it to a number\n                value = parseFloat(value);\n            }\n            else if (!findValueType(value) && complex.test(target)) {\n                value = getAnimatableNone(key, target);\n            }\n            this.setBaseTarget(key, isMotionValue(value) ? value.get() : value);\n        }\n        return isMotionValue(value) ? value.get() : value;\n    }\n    /**\n     * Set the base target to later animate back to. This is currently\n     * only hydrated on creation and when we first read a value.\n     */\n    setBaseTarget(key, value) {\n        this.baseTarget[key] = value;\n    }\n    /**\n     * Find the base target for a value thats been removed from all animation\n     * props.\n     */\n    getBaseTarget(key) {\n        const { initial } = this.props;\n        let valueFromInitial;\n        if (typeof initial === \"string\" || typeof initial === \"object\") {\n            const variant = resolveVariantFromProps(this.props, initial, this.presenceContext?.custom);\n            if (variant) {\n                valueFromInitial = variant[key];\n            }\n        }\n        /**\n         * If this value still exists in the current initial variant, read that.\n         */\n        if (initial && valueFromInitial !== undefined) {\n            return valueFromInitial;\n        }\n        /**\n         * Alternatively, if this VisualElement config has defined a getBaseTarget\n         * so we can read the value from an alternative source, try that.\n         */\n        const target = this.getBaseTargetFromProps(this.props, key);\n        if (target !== undefined && !isMotionValue(target))\n            return target;\n        /**\n         * If the value was initially defined on initial, but it doesn't any more,\n         * return undefined. Otherwise return the value as initially read from the DOM.\n         */\n        return this.initialValues[key] !== undefined &&\n            valueFromInitial === undefined\n            ? undefined\n            : this.baseTarget[key];\n    }\n    on(eventName, callback) {\n        if (!this.events[eventName]) {\n            this.events[eventName] = new SubscriptionManager();\n        }\n        return this.events[eventName].add(callback);\n    }\n    notify(eventName, ...args) {\n        if (this.events[eventName]) {\n            this.events[eventName].notify(...args);\n        }\n    }\n}\n\nexport { VisualElement };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}