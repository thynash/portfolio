{"ast":null,"code":"import _objectSpread from\"/home/antisyn/portfolio/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";import{getValueTransition,frame,JSAnimation,AsyncMotionValueAnimation}from'motion-dom';import{secondsToMilliseconds,MotionGlobalConfig}from'motion-utils';import{getFinalKeyframe}from'../animators/waapi/utils/get-final-keyframe.mjs';import{getDefaultTransition}from'../utils/default-transitions.mjs';import{isTransitionDefined}from'../utils/is-transition-defined.mjs';const animateMotionValue=function(name,value,target){let transition=arguments.length>3&&arguments[3]!==undefined?arguments[3]:{};let element=arguments.length>4?arguments[4]:undefined;let isHandoff=arguments.length>5?arguments[5]:undefined;return onComplete=>{const valueTransition=getValueTransition(transition,name)||{};/**\n     * Most transition values are currently completely overwritten by value-specific\n     * transitions. In the future it'd be nicer to blend these transitions. But for now\n     * delay actually does inherit from the root transition if not value-specific.\n     */const delay=valueTransition.delay||transition.delay||0;/**\n     * Elapsed isn't a public transition option but can be passed through from\n     * optimized appear effects in milliseconds.\n     */let{elapsed=0}=transition;elapsed=elapsed-secondsToMilliseconds(delay);const options=_objectSpread(_objectSpread({keyframes:Array.isArray(target)?target:[null,target],ease:\"easeOut\",velocity:value.getVelocity()},valueTransition),{},{delay:-elapsed,onUpdate:v=>{value.set(v);valueTransition.onUpdate&&valueTransition.onUpdate(v);},onComplete:()=>{onComplete();valueTransition.onComplete&&valueTransition.onComplete();},name,motionValue:value,element:isHandoff?undefined:element});/**\n     * If there's no transition defined for this value, we can generate\n     * unique transition settings for this value.\n     */if(!isTransitionDefined(valueTransition)){Object.assign(options,getDefaultTransition(name,options));}/**\n     * Both WAAPI and our internal animation functions use durations\n     * as defined by milliseconds, while our external API defines them\n     * as seconds.\n     */options.duration&&(options.duration=secondsToMilliseconds(options.duration));options.repeatDelay&&(options.repeatDelay=secondsToMilliseconds(options.repeatDelay));/**\n     * Support deprecated way to set initial value. Prefer keyframe syntax.\n     */if(options.from!==undefined){options.keyframes[0]=options.from;}let shouldSkip=false;if(options.type===false||options.duration===0&&!options.repeatDelay){options.duration=0;if(options.delay===0){shouldSkip=true;}}if(MotionGlobalConfig.instantAnimations||MotionGlobalConfig.skipAnimations){shouldSkip=true;options.duration=0;options.delay=0;}/**\n     * If the transition type or easing has been explicitly set by the user\n     * then we don't want to allow flattening the animation.\n     */options.allowFlatten=!valueTransition.type&&!valueTransition.ease;/**\n     * If we can or must skip creating the animation, and apply only\n     * the final keyframe, do so. We also check once keyframes are resolved but\n     * this early check prevents the need to create an animation at all.\n     */if(shouldSkip&&!isHandoff&&value.get()!==undefined){const finalKeyframe=getFinalKeyframe(options.keyframes,valueTransition);if(finalKeyframe!==undefined){frame.update(()=>{options.onUpdate(finalKeyframe);options.onComplete();});return;}}return valueTransition.isSync?new JSAnimation(options):new AsyncMotionValueAnimation(options);};};export{animateMotionValue};","map":{"version":3,"names":["getValueTransition","frame","JSAnimation","AsyncMotionValueAnimation","secondsToMilliseconds","MotionGlobalConfig","getFinalKeyframe","getDefaultTransition","isTransitionDefined","animateMotionValue","name","value","target","transition","arguments","length","undefined","element","isHandoff","onComplete","valueTransition","delay","elapsed","options","_objectSpread","keyframes","Array","isArray","ease","velocity","getVelocity","onUpdate","v","set","motionValue","Object","assign","duration","repeatDelay","from","shouldSkip","type","instantAnimations","skipAnimations","allowFlatten","get","finalKeyframe","update","isSync"],"sources":["/home/antisyn/portfolio/src/components/node_modules/framer-motion/dist/es/animation/interfaces/motion-value.mjs"],"sourcesContent":["import { getValueTransition, frame, JSAnimation, AsyncMotionValueAnimation } from 'motion-dom';\nimport { secondsToMilliseconds, MotionGlobalConfig } from 'motion-utils';\nimport { getFinalKeyframe } from '../animators/waapi/utils/get-final-keyframe.mjs';\nimport { getDefaultTransition } from '../utils/default-transitions.mjs';\nimport { isTransitionDefined } from '../utils/is-transition-defined.mjs';\n\nconst animateMotionValue = (name, value, target, transition = {}, element, isHandoff) => (onComplete) => {\n    const valueTransition = getValueTransition(transition, name) || {};\n    /**\n     * Most transition values are currently completely overwritten by value-specific\n     * transitions. In the future it'd be nicer to blend these transitions. But for now\n     * delay actually does inherit from the root transition if not value-specific.\n     */\n    const delay = valueTransition.delay || transition.delay || 0;\n    /**\n     * Elapsed isn't a public transition option but can be passed through from\n     * optimized appear effects in milliseconds.\n     */\n    let { elapsed = 0 } = transition;\n    elapsed = elapsed - secondsToMilliseconds(delay);\n    const options = {\n        keyframes: Array.isArray(target) ? target : [null, target],\n        ease: \"easeOut\",\n        velocity: value.getVelocity(),\n        ...valueTransition,\n        delay: -elapsed,\n        onUpdate: (v) => {\n            value.set(v);\n            valueTransition.onUpdate && valueTransition.onUpdate(v);\n        },\n        onComplete: () => {\n            onComplete();\n            valueTransition.onComplete && valueTransition.onComplete();\n        },\n        name,\n        motionValue: value,\n        element: isHandoff ? undefined : element,\n    };\n    /**\n     * If there's no transition defined for this value, we can generate\n     * unique transition settings for this value.\n     */\n    if (!isTransitionDefined(valueTransition)) {\n        Object.assign(options, getDefaultTransition(name, options));\n    }\n    /**\n     * Both WAAPI and our internal animation functions use durations\n     * as defined by milliseconds, while our external API defines them\n     * as seconds.\n     */\n    options.duration && (options.duration = secondsToMilliseconds(options.duration));\n    options.repeatDelay && (options.repeatDelay = secondsToMilliseconds(options.repeatDelay));\n    /**\n     * Support deprecated way to set initial value. Prefer keyframe syntax.\n     */\n    if (options.from !== undefined) {\n        options.keyframes[0] = options.from;\n    }\n    let shouldSkip = false;\n    if (options.type === false ||\n        (options.duration === 0 && !options.repeatDelay)) {\n        options.duration = 0;\n        if (options.delay === 0) {\n            shouldSkip = true;\n        }\n    }\n    if (MotionGlobalConfig.instantAnimations ||\n        MotionGlobalConfig.skipAnimations) {\n        shouldSkip = true;\n        options.duration = 0;\n        options.delay = 0;\n    }\n    /**\n     * If the transition type or easing has been explicitly set by the user\n     * then we don't want to allow flattening the animation.\n     */\n    options.allowFlatten = !valueTransition.type && !valueTransition.ease;\n    /**\n     * If we can or must skip creating the animation, and apply only\n     * the final keyframe, do so. We also check once keyframes are resolved but\n     * this early check prevents the need to create an animation at all.\n     */\n    if (shouldSkip && !isHandoff && value.get() !== undefined) {\n        const finalKeyframe = getFinalKeyframe(options.keyframes, valueTransition);\n        if (finalKeyframe !== undefined) {\n            frame.update(() => {\n                options.onUpdate(finalKeyframe);\n                options.onComplete();\n            });\n            return;\n        }\n    }\n    return valueTransition.isSync\n        ? new JSAnimation(options)\n        : new AsyncMotionValueAnimation(options);\n};\n\nexport { animateMotionValue };\n"],"mappings":"4GAAA,OAASA,kBAAkB,CAAEC,KAAK,CAAEC,WAAW,CAAEC,yBAAyB,KAAQ,YAAY,CAC9F,OAASC,qBAAqB,CAAEC,kBAAkB,KAAQ,cAAc,CACxE,OAASC,gBAAgB,KAAQ,iDAAiD,CAClF,OAASC,oBAAoB,KAAQ,kCAAkC,CACvE,OAASC,mBAAmB,KAAQ,oCAAoC,CAExE,KAAM,CAAAC,kBAAkB,CAAG,QAAAA,CAACC,IAAI,CAAEC,KAAK,CAAEC,MAAM,KAAE,CAAAC,UAAU,CAAAC,SAAA,CAAAC,MAAA,IAAAD,SAAA,MAAAE,SAAA,CAAAF,SAAA,IAAG,CAAC,CAAC,IAAE,CAAAG,OAAO,CAAAH,SAAA,CAAAC,MAAA,GAAAD,SAAA,IAAAE,SAAA,IAAE,CAAAE,SAAS,CAAAJ,SAAA,CAAAC,MAAA,GAAAD,SAAA,IAAAE,SAAA,OAAM,CAAAG,UAAU,EAAK,CACrG,KAAM,CAAAC,eAAe,CAAGpB,kBAAkB,CAACa,UAAU,CAAEH,IAAI,CAAC,EAAI,CAAC,CAAC,CAClE;AACJ;AACA;AACA;AACA,OACI,KAAM,CAAAW,KAAK,CAAGD,eAAe,CAACC,KAAK,EAAIR,UAAU,CAACQ,KAAK,EAAI,CAAC,CAC5D;AACJ;AACA;AACA,OACI,GAAI,CAAEC,OAAO,CAAG,CAAE,CAAC,CAAGT,UAAU,CAChCS,OAAO,CAAGA,OAAO,CAAGlB,qBAAqB,CAACiB,KAAK,CAAC,CAChD,KAAM,CAAAE,OAAO,CAAAC,aAAA,CAAAA,aAAA,EACTC,SAAS,CAAEC,KAAK,CAACC,OAAO,CAACf,MAAM,CAAC,CAAGA,MAAM,CAAG,CAAC,IAAI,CAAEA,MAAM,CAAC,CAC1DgB,IAAI,CAAE,SAAS,CACfC,QAAQ,CAAElB,KAAK,CAACmB,WAAW,CAAC,CAAC,EAC1BV,eAAe,MAClBC,KAAK,CAAE,CAACC,OAAO,CACfS,QAAQ,CAAGC,CAAC,EAAK,CACbrB,KAAK,CAACsB,GAAG,CAACD,CAAC,CAAC,CACZZ,eAAe,CAACW,QAAQ,EAAIX,eAAe,CAACW,QAAQ,CAACC,CAAC,CAAC,CAC3D,CAAC,CACDb,UAAU,CAAEA,CAAA,GAAM,CACdA,UAAU,CAAC,CAAC,CACZC,eAAe,CAACD,UAAU,EAAIC,eAAe,CAACD,UAAU,CAAC,CAAC,CAC9D,CAAC,CACDT,IAAI,CACJwB,WAAW,CAAEvB,KAAK,CAClBM,OAAO,CAAEC,SAAS,CAAGF,SAAS,CAAGC,OAAO,EAC3C,CACD;AACJ;AACA;AACA,OACI,GAAI,CAACT,mBAAmB,CAACY,eAAe,CAAC,CAAE,CACvCe,MAAM,CAACC,MAAM,CAACb,OAAO,CAAEhB,oBAAoB,CAACG,IAAI,CAAEa,OAAO,CAAC,CAAC,CAC/D,CACA;AACJ;AACA;AACA;AACA,OACIA,OAAO,CAACc,QAAQ,GAAKd,OAAO,CAACc,QAAQ,CAAGjC,qBAAqB,CAACmB,OAAO,CAACc,QAAQ,CAAC,CAAC,CAChFd,OAAO,CAACe,WAAW,GAAKf,OAAO,CAACe,WAAW,CAAGlC,qBAAqB,CAACmB,OAAO,CAACe,WAAW,CAAC,CAAC,CACzF;AACJ;AACA,OACI,GAAIf,OAAO,CAACgB,IAAI,GAAKvB,SAAS,CAAE,CAC5BO,OAAO,CAACE,SAAS,CAAC,CAAC,CAAC,CAAGF,OAAO,CAACgB,IAAI,CACvC,CACA,GAAI,CAAAC,UAAU,CAAG,KAAK,CACtB,GAAIjB,OAAO,CAACkB,IAAI,GAAK,KAAK,EACrBlB,OAAO,CAACc,QAAQ,GAAK,CAAC,EAAI,CAACd,OAAO,CAACe,WAAY,CAAE,CAClDf,OAAO,CAACc,QAAQ,CAAG,CAAC,CACpB,GAAId,OAAO,CAACF,KAAK,GAAK,CAAC,CAAE,CACrBmB,UAAU,CAAG,IAAI,CACrB,CACJ,CACA,GAAInC,kBAAkB,CAACqC,iBAAiB,EACpCrC,kBAAkB,CAACsC,cAAc,CAAE,CACnCH,UAAU,CAAG,IAAI,CACjBjB,OAAO,CAACc,QAAQ,CAAG,CAAC,CACpBd,OAAO,CAACF,KAAK,CAAG,CAAC,CACrB,CACA;AACJ;AACA;AACA,OACIE,OAAO,CAACqB,YAAY,CAAG,CAACxB,eAAe,CAACqB,IAAI,EAAI,CAACrB,eAAe,CAACQ,IAAI,CACrE;AACJ;AACA;AACA;AACA,OACI,GAAIY,UAAU,EAAI,CAACtB,SAAS,EAAIP,KAAK,CAACkC,GAAG,CAAC,CAAC,GAAK7B,SAAS,CAAE,CACvD,KAAM,CAAA8B,aAAa,CAAGxC,gBAAgB,CAACiB,OAAO,CAACE,SAAS,CAAEL,eAAe,CAAC,CAC1E,GAAI0B,aAAa,GAAK9B,SAAS,CAAE,CAC7Bf,KAAK,CAAC8C,MAAM,CAAC,IAAM,CACfxB,OAAO,CAACQ,QAAQ,CAACe,aAAa,CAAC,CAC/BvB,OAAO,CAACJ,UAAU,CAAC,CAAC,CACxB,CAAC,CAAC,CACF,OACJ,CACJ,CACA,MAAO,CAAAC,eAAe,CAAC4B,MAAM,CACvB,GAAI,CAAA9C,WAAW,CAACqB,OAAO,CAAC,CACxB,GAAI,CAAApB,yBAAyB,CAACoB,OAAO,CAAC,CAChD,CAAC,GAED,OAASd,kBAAkB","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}