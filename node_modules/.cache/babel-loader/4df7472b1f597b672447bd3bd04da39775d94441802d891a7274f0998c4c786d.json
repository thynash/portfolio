{"ast":null,"code":"import{invariant,millisecondsToSeconds,secondsToMilliseconds,noop}from'motion-utils';import{setStyle}from'../render/dom/style-set.mjs';import{supportsScrollTimeline}from'../utils/supports/scroll-timeline.mjs';import{getFinalKeyframe}from'./keyframes/get-final.mjs';import{WithPromise}from'./utils/WithPromise.mjs';import{startWaapiAnimation}from'./waapi/start-waapi-animation.mjs';import{applyGeneratorOptions}from'./waapi/utils/apply-generator.mjs';/**\n * NativeAnimation implements AnimationPlaybackControls for the browser's Web Animations API.\n */class NativeAnimation extends WithPromise{constructor(options){super();this.finishedTime=null;this.isStopped=false;if(!options)return;const{element,name,keyframes,pseudoElement,allowFlatten=false,finalKeyframe,onComplete}=options;this.isPseudoElement=Boolean(pseudoElement);this.allowFlatten=allowFlatten;this.options=options;invariant(typeof options.type!==\"string\",\"animateMini doesn't support \\\"type\\\" as a string. Did you mean to import { spring } from \\\"motion\\\"?\");const transition=applyGeneratorOptions(options);this.animation=startWaapiAnimation(element,name,keyframes,transition,pseudoElement);if(transition.autoplay===false){this.animation.pause();}this.animation.onfinish=()=>{this.finishedTime=this.time;if(!pseudoElement){const keyframe=getFinalKeyframe(keyframes,this.options,finalKeyframe,this.speed);if(this.updateMotionValue){this.updateMotionValue(keyframe);}else{/**\n                     * If we can, we want to commit the final style as set by the user,\n                     * rather than the computed keyframe value supplied by the animation.\n                     */setStyle(element,name,keyframe);}this.animation.cancel();}onComplete===null||onComplete===void 0?void 0:onComplete();this.notifyFinished();};}play(){if(this.isStopped)return;this.animation.play();if(this.state===\"finished\"){this.updateFinished();}}pause(){this.animation.pause();}complete(){var _this$animation$finis,_this$animation;(_this$animation$finis=(_this$animation=this.animation).finish)===null||_this$animation$finis===void 0?void 0:_this$animation$finis.call(_this$animation);}cancel(){try{this.animation.cancel();}catch(e){}}stop(){if(this.isStopped)return;this.isStopped=true;const{state}=this;if(state===\"idle\"||state===\"finished\"){return;}if(this.updateMotionValue){this.updateMotionValue();}else{this.commitStyles();}if(!this.isPseudoElement)this.cancel();}/**\n     * WAAPI doesn't natively have any interruption capabilities.\n     *\n     * In this method, we commit styles back to the DOM before cancelling\n     * the animation.\n     *\n     * This is designed to be overridden by NativeAnimationExtended, which\n     * will create a renderless JS animation and sample it twice to calculate\n     * its current value, \"previous\" value, and therefore allow\n     * Motion to also correctly calculate velocity for any subsequent animation\n     * while deferring the commit until the next animation frame.\n     */commitStyles(){if(!this.isPseudoElement){var _this$animation$commi,_this$animation2;(_this$animation$commi=(_this$animation2=this.animation).commitStyles)===null||_this$animation$commi===void 0?void 0:_this$animation$commi.call(_this$animation2);}}get duration(){var _this$animation$effec,_this$animation$effec2;const duration=((_this$animation$effec=this.animation.effect)===null||_this$animation$effec===void 0?void 0:(_this$animation$effec2=_this$animation$effec.getComputedTiming)===null||_this$animation$effec2===void 0?void 0:_this$animation$effec2.call(_this$animation$effec).duration)||0;return millisecondsToSeconds(Number(duration));}get time(){return millisecondsToSeconds(Number(this.animation.currentTime)||0);}set time(newTime){this.finishedTime=null;this.animation.currentTime=secondsToMilliseconds(newTime);}/**\n     * The playback speed of the animation.\n     * 1 = normal speed, 2 = double speed, 0.5 = half speed.\n     */get speed(){return this.animation.playbackRate;}set speed(newSpeed){// Allow backwards playback after finishing\nif(newSpeed<0)this.finishedTime=null;this.animation.playbackRate=newSpeed;}get state(){return this.finishedTime!==null?\"finished\":this.animation.playState;}get startTime(){return Number(this.animation.startTime);}set startTime(newStartTime){this.animation.startTime=newStartTime;}/**\n     * Attaches a timeline to the animation, for instance the `ScrollTimeline`.\n     */attachTimeline(_ref){let{timeline,observe}=_ref;if(this.allowFlatten){var _this$animation$effec3;(_this$animation$effec3=this.animation.effect)===null||_this$animation$effec3===void 0?void 0:_this$animation$effec3.updateTiming({easing:\"linear\"});}this.animation.onfinish=null;if(timeline&&supportsScrollTimeline()){this.animation.timeline=timeline;return noop;}else{return observe(this);}}}export{NativeAnimation};","map":{"version":3,"names":["invariant","millisecondsToSeconds","secondsToMilliseconds","noop","setStyle","supportsScrollTimeline","getFinalKeyframe","WithPromise","startWaapiAnimation","applyGeneratorOptions","NativeAnimation","constructor","options","finishedTime","isStopped","element","name","keyframes","pseudoElement","allowFlatten","finalKeyframe","onComplete","isPseudoElement","Boolean","type","transition","animation","autoplay","pause","onfinish","time","keyframe","speed","updateMotionValue","cancel","notifyFinished","play","state","updateFinished","complete","_this$animation$finis","_this$animation","finish","call","e","stop","commitStyles","_this$animation$commi","_this$animation2","duration","_this$animation$effec","_this$animation$effec2","effect","getComputedTiming","Number","currentTime","newTime","playbackRate","newSpeed","playState","startTime","newStartTime","attachTimeline","_ref","timeline","observe","_this$animation$effec3","updateTiming","easing"],"sources":["/home/antisyn/portfolio/src/components/node_modules/motion-dom/dist/es/animation/NativeAnimation.mjs"],"sourcesContent":["import { invariant, millisecondsToSeconds, secondsToMilliseconds, noop } from 'motion-utils';\nimport { setStyle } from '../render/dom/style-set.mjs';\nimport { supportsScrollTimeline } from '../utils/supports/scroll-timeline.mjs';\nimport { getFinalKeyframe } from './keyframes/get-final.mjs';\nimport { WithPromise } from './utils/WithPromise.mjs';\nimport { startWaapiAnimation } from './waapi/start-waapi-animation.mjs';\nimport { applyGeneratorOptions } from './waapi/utils/apply-generator.mjs';\n\n/**\n * NativeAnimation implements AnimationPlaybackControls for the browser's Web Animations API.\n */\nclass NativeAnimation extends WithPromise {\n    constructor(options) {\n        super();\n        this.finishedTime = null;\n        this.isStopped = false;\n        if (!options)\n            return;\n        const { element, name, keyframes, pseudoElement, allowFlatten = false, finalKeyframe, onComplete, } = options;\n        this.isPseudoElement = Boolean(pseudoElement);\n        this.allowFlatten = allowFlatten;\n        this.options = options;\n        invariant(typeof options.type !== \"string\", `animateMini doesn't support \"type\" as a string. Did you mean to import { spring } from \"motion\"?`);\n        const transition = applyGeneratorOptions(options);\n        this.animation = startWaapiAnimation(element, name, keyframes, transition, pseudoElement);\n        if (transition.autoplay === false) {\n            this.animation.pause();\n        }\n        this.animation.onfinish = () => {\n            this.finishedTime = this.time;\n            if (!pseudoElement) {\n                const keyframe = getFinalKeyframe(keyframes, this.options, finalKeyframe, this.speed);\n                if (this.updateMotionValue) {\n                    this.updateMotionValue(keyframe);\n                }\n                else {\n                    /**\n                     * If we can, we want to commit the final style as set by the user,\n                     * rather than the computed keyframe value supplied by the animation.\n                     */\n                    setStyle(element, name, keyframe);\n                }\n                this.animation.cancel();\n            }\n            onComplete?.();\n            this.notifyFinished();\n        };\n    }\n    play() {\n        if (this.isStopped)\n            return;\n        this.animation.play();\n        if (this.state === \"finished\") {\n            this.updateFinished();\n        }\n    }\n    pause() {\n        this.animation.pause();\n    }\n    complete() {\n        this.animation.finish?.();\n    }\n    cancel() {\n        try {\n            this.animation.cancel();\n        }\n        catch (e) { }\n    }\n    stop() {\n        if (this.isStopped)\n            return;\n        this.isStopped = true;\n        const { state } = this;\n        if (state === \"idle\" || state === \"finished\") {\n            return;\n        }\n        if (this.updateMotionValue) {\n            this.updateMotionValue();\n        }\n        else {\n            this.commitStyles();\n        }\n        if (!this.isPseudoElement)\n            this.cancel();\n    }\n    /**\n     * WAAPI doesn't natively have any interruption capabilities.\n     *\n     * In this method, we commit styles back to the DOM before cancelling\n     * the animation.\n     *\n     * This is designed to be overridden by NativeAnimationExtended, which\n     * will create a renderless JS animation and sample it twice to calculate\n     * its current value, \"previous\" value, and therefore allow\n     * Motion to also correctly calculate velocity for any subsequent animation\n     * while deferring the commit until the next animation frame.\n     */\n    commitStyles() {\n        if (!this.isPseudoElement) {\n            this.animation.commitStyles?.();\n        }\n    }\n    get duration() {\n        const duration = this.animation.effect?.getComputedTiming?.().duration || 0;\n        return millisecondsToSeconds(Number(duration));\n    }\n    get time() {\n        return millisecondsToSeconds(Number(this.animation.currentTime) || 0);\n    }\n    set time(newTime) {\n        this.finishedTime = null;\n        this.animation.currentTime = secondsToMilliseconds(newTime);\n    }\n    /**\n     * The playback speed of the animation.\n     * 1 = normal speed, 2 = double speed, 0.5 = half speed.\n     */\n    get speed() {\n        return this.animation.playbackRate;\n    }\n    set speed(newSpeed) {\n        // Allow backwards playback after finishing\n        if (newSpeed < 0)\n            this.finishedTime = null;\n        this.animation.playbackRate = newSpeed;\n    }\n    get state() {\n        return this.finishedTime !== null\n            ? \"finished\"\n            : this.animation.playState;\n    }\n    get startTime() {\n        return Number(this.animation.startTime);\n    }\n    set startTime(newStartTime) {\n        this.animation.startTime = newStartTime;\n    }\n    /**\n     * Attaches a timeline to the animation, for instance the `ScrollTimeline`.\n     */\n    attachTimeline({ timeline, observe }) {\n        if (this.allowFlatten) {\n            this.animation.effect?.updateTiming({ easing: \"linear\" });\n        }\n        this.animation.onfinish = null;\n        if (timeline && supportsScrollTimeline()) {\n            this.animation.timeline = timeline;\n            return noop;\n        }\n        else {\n            return observe(this);\n        }\n    }\n}\n\nexport { NativeAnimation };\n"],"mappings":"AAAA,OAASA,SAAS,CAAEC,qBAAqB,CAAEC,qBAAqB,CAAEC,IAAI,KAAQ,cAAc,CAC5F,OAASC,QAAQ,KAAQ,6BAA6B,CACtD,OAASC,sBAAsB,KAAQ,uCAAuC,CAC9E,OAASC,gBAAgB,KAAQ,2BAA2B,CAC5D,OAASC,WAAW,KAAQ,yBAAyB,CACrD,OAASC,mBAAmB,KAAQ,mCAAmC,CACvE,OAASC,qBAAqB,KAAQ,mCAAmC,CAEzE;AACA;AACA,GACA,KAAM,CAAAC,eAAe,QAAS,CAAAH,WAAY,CACtCI,WAAWA,CAACC,OAAO,CAAE,CACjB,KAAK,CAAC,CAAC,CACP,IAAI,CAACC,YAAY,CAAG,IAAI,CACxB,IAAI,CAACC,SAAS,CAAG,KAAK,CACtB,GAAI,CAACF,OAAO,CACR,OACJ,KAAM,CAAEG,OAAO,CAAEC,IAAI,CAAEC,SAAS,CAAEC,aAAa,CAAEC,YAAY,CAAG,KAAK,CAAEC,aAAa,CAAEC,UAAY,CAAC,CAAGT,OAAO,CAC7G,IAAI,CAACU,eAAe,CAAGC,OAAO,CAACL,aAAa,CAAC,CAC7C,IAAI,CAACC,YAAY,CAAGA,YAAY,CAChC,IAAI,CAACP,OAAO,CAAGA,OAAO,CACtBZ,SAAS,CAAC,MAAO,CAAAY,OAAO,CAACY,IAAI,GAAK,QAAQ,uGAAoG,CAAC,CAC/I,KAAM,CAAAC,UAAU,CAAGhB,qBAAqB,CAACG,OAAO,CAAC,CACjD,IAAI,CAACc,SAAS,CAAGlB,mBAAmB,CAACO,OAAO,CAAEC,IAAI,CAAEC,SAAS,CAAEQ,UAAU,CAAEP,aAAa,CAAC,CACzF,GAAIO,UAAU,CAACE,QAAQ,GAAK,KAAK,CAAE,CAC/B,IAAI,CAACD,SAAS,CAACE,KAAK,CAAC,CAAC,CAC1B,CACA,IAAI,CAACF,SAAS,CAACG,QAAQ,CAAG,IAAM,CAC5B,IAAI,CAAChB,YAAY,CAAG,IAAI,CAACiB,IAAI,CAC7B,GAAI,CAACZ,aAAa,CAAE,CAChB,KAAM,CAAAa,QAAQ,CAAGzB,gBAAgB,CAACW,SAAS,CAAE,IAAI,CAACL,OAAO,CAAEQ,aAAa,CAAE,IAAI,CAACY,KAAK,CAAC,CACrF,GAAI,IAAI,CAACC,iBAAiB,CAAE,CACxB,IAAI,CAACA,iBAAiB,CAACF,QAAQ,CAAC,CACpC,CAAC,IACI,CACD;AACpB;AACA;AACA,uBACoB3B,QAAQ,CAACW,OAAO,CAAEC,IAAI,CAAEe,QAAQ,CAAC,CACrC,CACA,IAAI,CAACL,SAAS,CAACQ,MAAM,CAAC,CAAC,CAC3B,CACAb,UAAU,SAAVA,UAAU,iBAAVA,UAAU,CAAG,CAAC,CACd,IAAI,CAACc,cAAc,CAAC,CAAC,CACzB,CAAC,CACL,CACAC,IAAIA,CAAA,CAAG,CACH,GAAI,IAAI,CAACtB,SAAS,CACd,OACJ,IAAI,CAACY,SAAS,CAACU,IAAI,CAAC,CAAC,CACrB,GAAI,IAAI,CAACC,KAAK,GAAK,UAAU,CAAE,CAC3B,IAAI,CAACC,cAAc,CAAC,CAAC,CACzB,CACJ,CACAV,KAAKA,CAAA,CAAG,CACJ,IAAI,CAACF,SAAS,CAACE,KAAK,CAAC,CAAC,CAC1B,CACAW,QAAQA,CAAA,CAAG,KAAAC,qBAAA,CAAAC,eAAA,CACP,CAAAD,qBAAA,EAAAC,eAAA,KAAI,CAACf,SAAS,EAACgB,MAAM,UAAAF,qBAAA,iBAArBA,qBAAA,CAAAG,IAAA,CAAAF,eAAwB,CAAC,CAC7B,CACAP,MAAMA,CAAA,CAAG,CACL,GAAI,CACA,IAAI,CAACR,SAAS,CAACQ,MAAM,CAAC,CAAC,CAC3B,CACA,MAAOU,CAAC,CAAE,CAAE,CAChB,CACAC,IAAIA,CAAA,CAAG,CACH,GAAI,IAAI,CAAC/B,SAAS,CACd,OACJ,IAAI,CAACA,SAAS,CAAG,IAAI,CACrB,KAAM,CAAEuB,KAAM,CAAC,CAAG,IAAI,CACtB,GAAIA,KAAK,GAAK,MAAM,EAAIA,KAAK,GAAK,UAAU,CAAE,CAC1C,OACJ,CACA,GAAI,IAAI,CAACJ,iBAAiB,CAAE,CACxB,IAAI,CAACA,iBAAiB,CAAC,CAAC,CAC5B,CAAC,IACI,CACD,IAAI,CAACa,YAAY,CAAC,CAAC,CACvB,CACA,GAAI,CAAC,IAAI,CAACxB,eAAe,CACrB,IAAI,CAACY,MAAM,CAAC,CAAC,CACrB,CACA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OACIY,YAAYA,CAAA,CAAG,CACX,GAAI,CAAC,IAAI,CAACxB,eAAe,CAAE,KAAAyB,qBAAA,CAAAC,gBAAA,CACvB,CAAAD,qBAAA,EAAAC,gBAAA,KAAI,CAACtB,SAAS,EAACoB,YAAY,UAAAC,qBAAA,iBAA3BA,qBAAA,CAAAJ,IAAA,CAAAK,gBAA8B,CAAC,CACnC,CACJ,CACA,GAAI,CAAAC,QAAQA,CAAA,CAAG,KAAAC,qBAAA,CAAAC,sBAAA,CACX,KAAM,CAAAF,QAAQ,CAAG,EAAAC,qBAAA,KAAI,CAACxB,SAAS,CAAC0B,MAAM,UAAAF,qBAAA,kBAAAC,sBAAA,CAArBD,qBAAA,CAAuBG,iBAAiB,UAAAF,sBAAA,iBAAxCA,sBAAA,CAAAR,IAAA,CAAAO,qBAA2C,CAAC,CAACD,QAAQ,GAAI,CAAC,CAC3E,MAAO,CAAAhD,qBAAqB,CAACqD,MAAM,CAACL,QAAQ,CAAC,CAAC,CAClD,CACA,GAAI,CAAAnB,IAAIA,CAAA,CAAG,CACP,MAAO,CAAA7B,qBAAqB,CAACqD,MAAM,CAAC,IAAI,CAAC5B,SAAS,CAAC6B,WAAW,CAAC,EAAI,CAAC,CAAC,CACzE,CACA,GAAI,CAAAzB,IAAIA,CAAC0B,OAAO,CAAE,CACd,IAAI,CAAC3C,YAAY,CAAG,IAAI,CACxB,IAAI,CAACa,SAAS,CAAC6B,WAAW,CAAGrD,qBAAqB,CAACsD,OAAO,CAAC,CAC/D,CACA;AACJ;AACA;AACA,OACI,GAAI,CAAAxB,KAAKA,CAAA,CAAG,CACR,MAAO,KAAI,CAACN,SAAS,CAAC+B,YAAY,CACtC,CACA,GAAI,CAAAzB,KAAKA,CAAC0B,QAAQ,CAAE,CAChB;AACA,GAAIA,QAAQ,CAAG,CAAC,CACZ,IAAI,CAAC7C,YAAY,CAAG,IAAI,CAC5B,IAAI,CAACa,SAAS,CAAC+B,YAAY,CAAGC,QAAQ,CAC1C,CACA,GAAI,CAAArB,KAAKA,CAAA,CAAG,CACR,MAAO,KAAI,CAACxB,YAAY,GAAK,IAAI,CAC3B,UAAU,CACV,IAAI,CAACa,SAAS,CAACiC,SAAS,CAClC,CACA,GAAI,CAAAC,SAASA,CAAA,CAAG,CACZ,MAAO,CAAAN,MAAM,CAAC,IAAI,CAAC5B,SAAS,CAACkC,SAAS,CAAC,CAC3C,CACA,GAAI,CAAAA,SAASA,CAACC,YAAY,CAAE,CACxB,IAAI,CAACnC,SAAS,CAACkC,SAAS,CAAGC,YAAY,CAC3C,CACA;AACJ;AACA,OACIC,cAAcA,CAAAC,IAAA,CAAwB,IAAvB,CAAEC,QAAQ,CAAEC,OAAQ,CAAC,CAAAF,IAAA,CAChC,GAAI,IAAI,CAAC5C,YAAY,CAAE,KAAA+C,sBAAA,CACnB,CAAAA,sBAAA,KAAI,CAACxC,SAAS,CAAC0B,MAAM,UAAAc,sBAAA,iBAArBA,sBAAA,CAAuBC,YAAY,CAAC,CAAEC,MAAM,CAAE,QAAS,CAAC,CAAC,CAC7D,CACA,IAAI,CAAC1C,SAAS,CAACG,QAAQ,CAAG,IAAI,CAC9B,GAAImC,QAAQ,EAAI3D,sBAAsB,CAAC,CAAC,CAAE,CACtC,IAAI,CAACqB,SAAS,CAACsC,QAAQ,CAAGA,QAAQ,CAClC,MAAO,CAAA7D,IAAI,CACf,CAAC,IACI,CACD,MAAO,CAAA8D,OAAO,CAAC,IAAI,CAAC,CACxB,CACJ,CACJ,CAEA,OAASvD,eAAe","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}