{"ast":null,"code":"import _objectSpread from\"/home/antisyn/portfolio/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";import _objectWithoutProperties from\"/home/antisyn/portfolio/node_modules/@babel/runtime/helpers/esm/objectWithoutProperties.js\";const _excluded=[\"autoplay\",\"delay\",\"type\",\"repeat\",\"repeatDelay\",\"repeatType\",\"keyframes\",\"name\",\"motionValue\",\"element\"];import{MotionGlobalConfig,noop}from'motion-utils';import{time}from'../frameloop/sync-time.mjs';import{JSAnimation}from'./JSAnimation.mjs';import{getFinalKeyframe}from'./keyframes/get-final.mjs';import{KeyframeResolver,flushKeyframeResolvers}from'./keyframes/KeyframesResolver.mjs';import{NativeAnimationExtended}from'./NativeAnimationExtended.mjs';import{canAnimate}from'./utils/can-animate.mjs';import{WithPromise}from'./utils/WithPromise.mjs';import{supportsBrowserAnimation}from'./waapi/supports/waapi.mjs';/**\n * Maximum time allowed between an animation being created and it being\n * resolved for us to use the latter as the start time.\n *\n * This is to ensure that while we prefer to \"start\" an animation as soon\n * as it's triggered, we also want to avoid a visual jump if there's a big delay\n * between these two moments.\n */const MAX_RESOLVE_DELAY=40;class AsyncMotionValueAnimation extends WithPromise{constructor(_ref){var _this$keyframeResolve2;let{autoplay=true,delay=0,type=\"keyframes\",repeat=0,repeatDelay=0,repeatType=\"loop\",keyframes,name,motionValue,element}=_ref,options=_objectWithoutProperties(_ref,_excluded);super();/**\n         * Bound to support return animation.stop pattern\n         */this.stop=()=>{var _this$keyframeResolve;if(this._animation){var _this$stopTimeline;this._animation.stop();(_this$stopTimeline=this.stopTimeline)===null||_this$stopTimeline===void 0?void 0:_this$stopTimeline.call(this);}(_this$keyframeResolve=this.keyframeResolver)===null||_this$keyframeResolve===void 0?void 0:_this$keyframeResolve.cancel();};this.createdAt=time.now();const optionsWithDefaults=_objectSpread({autoplay,delay,type,repeat,repeatDelay,repeatType,name,motionValue,element},options);const KeyframeResolver$1=(element===null||element===void 0?void 0:element.KeyframeResolver)||KeyframeResolver;this.keyframeResolver=new KeyframeResolver$1(keyframes,(resolvedKeyframes,finalKeyframe,forced)=>this.onKeyframesResolved(resolvedKeyframes,finalKeyframe,optionsWithDefaults,!forced),name,motionValue,element);(_this$keyframeResolve2=this.keyframeResolver)===null||_this$keyframeResolve2===void 0?void 0:_this$keyframeResolve2.scheduleResolve();}onKeyframesResolved(keyframes,finalKeyframe,options,sync){this.keyframeResolver=undefined;const{name,type,velocity,delay,isHandoff,onUpdate}=options;this.resolvedAt=time.now();/**\n         * If we can't animate this value with the resolved keyframes\n         * then we should complete it immediately.\n         */if(!canAnimate(keyframes,name,type,velocity)){if(MotionGlobalConfig.instantAnimations||!delay){onUpdate===null||onUpdate===void 0?void 0:onUpdate(getFinalKeyframe(keyframes,options,finalKeyframe));}keyframes[0]=keyframes[keyframes.length-1];options.duration=0;options.repeat=0;}/**\n         * Resolve startTime for the animation.\n         *\n         * This method uses the createdAt and resolvedAt to calculate the\n         * animation startTime. *Ideally*, we would use the createdAt time as t=0\n         * as the following frame would then be the first frame of the animation in\n         * progress, which would feel snappier.\n         *\n         * However, if there's a delay (main thread work) between the creation of\n         * the animation and the first commited frame, we prefer to use resolvedAt\n         * to avoid a sudden jump into the animation.\n         */const startTime=sync?!this.resolvedAt?this.createdAt:this.resolvedAt-this.createdAt>MAX_RESOLVE_DELAY?this.resolvedAt:this.createdAt:undefined;const resolvedOptions=_objectSpread(_objectSpread({startTime,finalKeyframe},options),{},{keyframes});/**\n         * Animate via WAAPI if possible. If this is a handoff animation, the optimised animation will be running via\n         * WAAPI. Therefore, this animation must be JS to ensure it runs \"under\" the\n         * optimised animation.\n         */const animation=!isHandoff&&supportsBrowserAnimation(resolvedOptions)?new NativeAnimationExtended(_objectSpread(_objectSpread({},resolvedOptions),{},{element:resolvedOptions.motionValue.owner.current})):new JSAnimation(resolvedOptions);animation.finished.then(()=>this.notifyFinished()).catch(noop);if(this.pendingTimeline){this.stopTimeline=animation.attachTimeline(this.pendingTimeline);this.pendingTimeline=undefined;}this._animation=animation;}get finished(){if(!this._animation){return this._finished;}else{return this.animation.finished;}}then(onResolve,_onReject){return this.finished.finally(onResolve).then(()=>{});}get animation(){if(!this._animation){var _this$keyframeResolve3;(_this$keyframeResolve3=this.keyframeResolver)===null||_this$keyframeResolve3===void 0?void 0:_this$keyframeResolve3.resume();flushKeyframeResolvers();}return this._animation;}get duration(){return this.animation.duration;}get time(){return this.animation.time;}set time(newTime){this.animation.time=newTime;}get speed(){return this.animation.speed;}get state(){return this.animation.state;}set speed(newSpeed){this.animation.speed=newSpeed;}get startTime(){return this.animation.startTime;}attachTimeline(timeline){if(this._animation){this.stopTimeline=this.animation.attachTimeline(timeline);}else{this.pendingTimeline=timeline;}return()=>this.stop();}play(){this.animation.play();}pause(){this.animation.pause();}complete(){this.animation.complete();}cancel(){var _this$keyframeResolve4;if(this._animation){this.animation.cancel();}(_this$keyframeResolve4=this.keyframeResolver)===null||_this$keyframeResolve4===void 0?void 0:_this$keyframeResolve4.cancel();}}export{AsyncMotionValueAnimation};","map":{"version":3,"names":["MotionGlobalConfig","noop","time","JSAnimation","getFinalKeyframe","KeyframeResolver","flushKeyframeResolvers","NativeAnimationExtended","canAnimate","WithPromise","supportsBrowserAnimation","MAX_RESOLVE_DELAY","AsyncMotionValueAnimation","constructor","_ref","_this$keyframeResolve2","autoplay","delay","type","repeat","repeatDelay","repeatType","keyframes","name","motionValue","element","options","_objectWithoutProperties","_excluded","stop","_this$keyframeResolve","_animation","_this$stopTimeline","stopTimeline","call","keyframeResolver","cancel","createdAt","now","optionsWithDefaults","_objectSpread","KeyframeResolver$1","resolvedKeyframes","finalKeyframe","forced","onKeyframesResolved","scheduleResolve","sync","undefined","velocity","isHandoff","onUpdate","resolvedAt","instantAnimations","length","duration","startTime","resolvedOptions","animation","owner","current","finished","then","notifyFinished","catch","pendingTimeline","attachTimeline","_finished","onResolve","_onReject","finally","_this$keyframeResolve3","resume","newTime","speed","state","newSpeed","timeline","play","pause","complete","_this$keyframeResolve4"],"sources":["/home/antisyn/portfolio/src/components/node_modules/motion-dom/dist/es/animation/AsyncMotionValueAnimation.mjs"],"sourcesContent":["import { MotionGlobalConfig, noop } from 'motion-utils';\nimport { time } from '../frameloop/sync-time.mjs';\nimport { JSAnimation } from './JSAnimation.mjs';\nimport { getFinalKeyframe } from './keyframes/get-final.mjs';\nimport { KeyframeResolver, flushKeyframeResolvers } from './keyframes/KeyframesResolver.mjs';\nimport { NativeAnimationExtended } from './NativeAnimationExtended.mjs';\nimport { canAnimate } from './utils/can-animate.mjs';\nimport { WithPromise } from './utils/WithPromise.mjs';\nimport { supportsBrowserAnimation } from './waapi/supports/waapi.mjs';\n\n/**\n * Maximum time allowed between an animation being created and it being\n * resolved for us to use the latter as the start time.\n *\n * This is to ensure that while we prefer to \"start\" an animation as soon\n * as it's triggered, we also want to avoid a visual jump if there's a big delay\n * between these two moments.\n */\nconst MAX_RESOLVE_DELAY = 40;\nclass AsyncMotionValueAnimation extends WithPromise {\n    constructor({ autoplay = true, delay = 0, type = \"keyframes\", repeat = 0, repeatDelay = 0, repeatType = \"loop\", keyframes, name, motionValue, element, ...options }) {\n        super();\n        /**\n         * Bound to support return animation.stop pattern\n         */\n        this.stop = () => {\n            if (this._animation) {\n                this._animation.stop();\n                this.stopTimeline?.();\n            }\n            this.keyframeResolver?.cancel();\n        };\n        this.createdAt = time.now();\n        const optionsWithDefaults = {\n            autoplay,\n            delay,\n            type,\n            repeat,\n            repeatDelay,\n            repeatType,\n            name,\n            motionValue,\n            element,\n            ...options,\n        };\n        const KeyframeResolver$1 = element?.KeyframeResolver || KeyframeResolver;\n        this.keyframeResolver = new KeyframeResolver$1(keyframes, (resolvedKeyframes, finalKeyframe, forced) => this.onKeyframesResolved(resolvedKeyframes, finalKeyframe, optionsWithDefaults, !forced), name, motionValue, element);\n        this.keyframeResolver?.scheduleResolve();\n    }\n    onKeyframesResolved(keyframes, finalKeyframe, options, sync) {\n        this.keyframeResolver = undefined;\n        const { name, type, velocity, delay, isHandoff, onUpdate } = options;\n        this.resolvedAt = time.now();\n        /**\n         * If we can't animate this value with the resolved keyframes\n         * then we should complete it immediately.\n         */\n        if (!canAnimate(keyframes, name, type, velocity)) {\n            if (MotionGlobalConfig.instantAnimations || !delay) {\n                onUpdate?.(getFinalKeyframe(keyframes, options, finalKeyframe));\n            }\n            keyframes[0] = keyframes[keyframes.length - 1];\n            options.duration = 0;\n            options.repeat = 0;\n        }\n        /**\n         * Resolve startTime for the animation.\n         *\n         * This method uses the createdAt and resolvedAt to calculate the\n         * animation startTime. *Ideally*, we would use the createdAt time as t=0\n         * as the following frame would then be the first frame of the animation in\n         * progress, which would feel snappier.\n         *\n         * However, if there's a delay (main thread work) between the creation of\n         * the animation and the first commited frame, we prefer to use resolvedAt\n         * to avoid a sudden jump into the animation.\n         */\n        const startTime = sync\n            ? !this.resolvedAt\n                ? this.createdAt\n                : this.resolvedAt - this.createdAt > MAX_RESOLVE_DELAY\n                    ? this.resolvedAt\n                    : this.createdAt\n            : undefined;\n        const resolvedOptions = {\n            startTime,\n            finalKeyframe,\n            ...options,\n            keyframes,\n        };\n        /**\n         * Animate via WAAPI if possible. If this is a handoff animation, the optimised animation will be running via\n         * WAAPI. Therefore, this animation must be JS to ensure it runs \"under\" the\n         * optimised animation.\n         */\n        const animation = !isHandoff && supportsBrowserAnimation(resolvedOptions)\n            ? new NativeAnimationExtended({\n                ...resolvedOptions,\n                element: resolvedOptions.motionValue.owner.current,\n            })\n            : new JSAnimation(resolvedOptions);\n        animation.finished.then(() => this.notifyFinished()).catch(noop);\n        if (this.pendingTimeline) {\n            this.stopTimeline = animation.attachTimeline(this.pendingTimeline);\n            this.pendingTimeline = undefined;\n        }\n        this._animation = animation;\n    }\n    get finished() {\n        if (!this._animation) {\n            return this._finished;\n        }\n        else {\n            return this.animation.finished;\n        }\n    }\n    then(onResolve, _onReject) {\n        return this.finished.finally(onResolve).then(() => { });\n    }\n    get animation() {\n        if (!this._animation) {\n            this.keyframeResolver?.resume();\n            flushKeyframeResolvers();\n        }\n        return this._animation;\n    }\n    get duration() {\n        return this.animation.duration;\n    }\n    get time() {\n        return this.animation.time;\n    }\n    set time(newTime) {\n        this.animation.time = newTime;\n    }\n    get speed() {\n        return this.animation.speed;\n    }\n    get state() {\n        return this.animation.state;\n    }\n    set speed(newSpeed) {\n        this.animation.speed = newSpeed;\n    }\n    get startTime() {\n        return this.animation.startTime;\n    }\n    attachTimeline(timeline) {\n        if (this._animation) {\n            this.stopTimeline = this.animation.attachTimeline(timeline);\n        }\n        else {\n            this.pendingTimeline = timeline;\n        }\n        return () => this.stop();\n    }\n    play() {\n        this.animation.play();\n    }\n    pause() {\n        this.animation.pause();\n    }\n    complete() {\n        this.animation.complete();\n    }\n    cancel() {\n        if (this._animation) {\n            this.animation.cancel();\n        }\n        this.keyframeResolver?.cancel();\n    }\n}\n\nexport { AsyncMotionValueAnimation };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}