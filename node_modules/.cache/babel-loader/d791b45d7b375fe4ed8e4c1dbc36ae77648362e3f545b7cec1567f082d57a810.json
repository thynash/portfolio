{"ast":null,"code":"import _objectSpread from\"/home/antisyn/portfolio/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";import _objectWithoutProperties from\"/home/antisyn/portfolio/node_modules/@babel/runtime/helpers/esm/objectWithoutProperties.js\";const _excluded=[\"defaultTransition\"],_excluded2=[\"delay\",\"times\",\"type\",\"repeat\",\"repeatType\",\"repeatDelay\"];import{isMotionValue,defaultOffset,isGenerator,createGeneratorEasing,fillOffset}from'motion-dom';import{progress,secondsToMilliseconds,invariant,getEasingForSegment}from'motion-utils';import{resolveSubjects}from'../animate/resolve-subjects.mjs';import{calculateRepeatDuration}from'./utils/calc-repeat-duration.mjs';import{calcNextTime}from'./utils/calc-time.mjs';import{addKeyframes}from'./utils/edit.mjs';import{normalizeTimes}from'./utils/normalize-times.mjs';import{compareByTime}from'./utils/sort.mjs';const defaultSegmentEasing=\"easeInOut\";const MAX_REPEAT=20;function createAnimationsFromSequence(sequence){let _ref=arguments.length>1&&arguments[1]!==undefined?arguments[1]:{},{defaultTransition={}}=_ref,sequenceTransition=_objectWithoutProperties(_ref,_excluded);let scope=arguments.length>2?arguments[2]:undefined;let generators=arguments.length>3?arguments[3]:undefined;const defaultDuration=defaultTransition.duration||0.3;const animationDefinitions=new Map();const sequences=new Map();const elementCache={};const timeLabels=new Map();let prevTime=0;let currentTime=0;let totalDuration=0;/**\n     * Build the timeline by mapping over the sequence array and converting\n     * the definitions into keyframes and offsets with absolute time values.\n     * These will later get converted into relative offsets in a second pass.\n     */for(let i=0;i<sequence.length;i++){const segment=sequence[i];/**\n         * If this is a timeline label, mark it and skip the rest of this iteration.\n         */if(typeof segment===\"string\"){timeLabels.set(segment,currentTime);continue;}else if(!Array.isArray(segment)){timeLabels.set(segment.name,calcNextTime(currentTime,segment.at,prevTime,timeLabels));continue;}let[subject,keyframes,transition={}]=segment;/**\n         * If a relative or absolute time value has been specified we need to resolve\n         * it in relation to the currentTime.\n         */if(transition.at!==undefined){currentTime=calcNextTime(currentTime,transition.at,prevTime,timeLabels);}/**\n         * Keep track of the maximum duration in this definition. This will be\n         * applied to currentTime once the definition has been parsed.\n         */let maxDuration=0;const resolveValueSequence=function(valueKeyframes,valueTransition,valueSequence){var _duration;let elementIndex=arguments.length>3&&arguments[3]!==undefined?arguments[3]:0;let numSubjects=arguments.length>4&&arguments[4]!==undefined?arguments[4]:0;const valueKeyframesAsList=keyframesAsList(valueKeyframes);const{delay=0,times=defaultOffset(valueKeyframesAsList),type=\"keyframes\",repeat,repeatType,repeatDelay=0}=valueTransition,remainingTransition=_objectWithoutProperties(valueTransition,_excluded2);let{ease=defaultTransition.ease||\"easeOut\",duration}=valueTransition;/**\n             * Resolve stagger() if defined.\n             */const calculatedDelay=typeof delay===\"function\"?delay(elementIndex,numSubjects):delay;/**\n             * If this animation should and can use a spring, generate a spring easing function.\n             */const numKeyframes=valueKeyframesAsList.length;const createGenerator=isGenerator(type)?type:generators===null||generators===void 0?void 0:generators[type||\"keyframes\"];if(numKeyframes<=2&&createGenerator){/**\n                 * As we're creating an easing function from a spring,\n                 * ideally we want to generate it using the real distance\n                 * between the two keyframes. However this isn't always\n                 * possible - in these situations we use 0-100.\n                 */let absoluteDelta=100;if(numKeyframes===2&&isNumberKeyframesArray(valueKeyframesAsList)){const delta=valueKeyframesAsList[1]-valueKeyframesAsList[0];absoluteDelta=Math.abs(delta);}const springTransition=_objectSpread({},remainingTransition);if(duration!==undefined){springTransition.duration=secondsToMilliseconds(duration);}const springEasing=createGeneratorEasing(springTransition,absoluteDelta,createGenerator);ease=springEasing.ease;duration=springEasing.duration;}(_duration=duration)!==null&&_duration!==void 0?_duration:duration=defaultDuration;const startTime=currentTime+calculatedDelay;/**\n             * If there's only one time offset of 0, fill in a second with length 1\n             */if(times.length===1&&times[0]===0){times[1]=1;}/**\n             * Fill out if offset if fewer offsets than keyframes\n             */const remainder=times.length-valueKeyframesAsList.length;remainder>0&&fillOffset(times,remainder);/**\n             * If only one value has been set, ie [1], push a null to the start of\n             * the keyframe array. This will let us mark a keyframe at this point\n             * that will later be hydrated with the previous value.\n             */valueKeyframesAsList.length===1&&valueKeyframesAsList.unshift(null);/**\n             * Handle repeat options\n             */if(repeat){invariant(repeat<MAX_REPEAT,\"Repeat count too high, must be less than 20\");duration=calculateRepeatDuration(duration,repeat);const originalKeyframes=[...valueKeyframesAsList];const originalTimes=[...times];ease=Array.isArray(ease)?[...ease]:[ease];const originalEase=[...ease];for(let repeatIndex=0;repeatIndex<repeat;repeatIndex++){valueKeyframesAsList.push(...originalKeyframes);for(let keyframeIndex=0;keyframeIndex<originalKeyframes.length;keyframeIndex++){times.push(originalTimes[keyframeIndex]+(repeatIndex+1));ease.push(keyframeIndex===0?\"linear\":getEasingForSegment(originalEase,keyframeIndex-1));}}normalizeTimes(times,repeat);}const targetTime=startTime+duration;/**\n             * Add keyframes, mapping offsets to absolute time.\n             */addKeyframes(valueSequence,valueKeyframesAsList,ease,times,startTime,targetTime);maxDuration=Math.max(calculatedDelay+duration,maxDuration);totalDuration=Math.max(targetTime,totalDuration);};if(isMotionValue(subject)){const subjectSequence=getSubjectSequence(subject,sequences);resolveValueSequence(keyframes,transition,getValueSequence(\"default\",subjectSequence));}else{const subjects=resolveSubjects(subject,keyframes,scope,elementCache);const numSubjects=subjects.length;/**\n             * For every element in this segment, process the defined values.\n             */for(let subjectIndex=0;subjectIndex<numSubjects;subjectIndex++){/**\n                 * Cast necessary, but we know these are of this type\n                 */keyframes=keyframes;transition=transition;const thisSubject=subjects[subjectIndex];const subjectSequence=getSubjectSequence(thisSubject,sequences);for(const key in keyframes){resolveValueSequence(keyframes[key],getValueTransition(transition,key),getValueSequence(key,subjectSequence),subjectIndex,numSubjects);}}}prevTime=currentTime;currentTime+=maxDuration;}/**\n     * For every element and value combination create a new animation.\n     */sequences.forEach((valueSequences,element)=>{for(const key in valueSequences){const valueSequence=valueSequences[key];/**\n             * Arrange all the keyframes in ascending time order.\n             */valueSequence.sort(compareByTime);const keyframes=[];const valueOffset=[];const valueEasing=[];/**\n             * For each keyframe, translate absolute times into\n             * relative offsets based on the total duration of the timeline.\n             */for(let i=0;i<valueSequence.length;i++){const{at,value,easing}=valueSequence[i];keyframes.push(value);valueOffset.push(progress(0,totalDuration,at));valueEasing.push(easing||\"easeOut\");}/**\n             * If the first keyframe doesn't land on offset: 0\n             * provide one by duplicating the initial keyframe. This ensures\n             * it snaps to the first keyframe when the animation starts.\n             */if(valueOffset[0]!==0){valueOffset.unshift(0);keyframes.unshift(keyframes[0]);valueEasing.unshift(defaultSegmentEasing);}/**\n             * If the last keyframe doesn't land on offset: 1\n             * provide one with a null wildcard value. This will ensure it\n             * stays static until the end of the animation.\n             */if(valueOffset[valueOffset.length-1]!==1){valueOffset.push(1);keyframes.push(null);}if(!animationDefinitions.has(element)){animationDefinitions.set(element,{keyframes:{},transition:{}});}const definition=animationDefinitions.get(element);definition.keyframes[key]=keyframes;definition.transition[key]=_objectSpread(_objectSpread({},defaultTransition),{},{duration:totalDuration,ease:valueEasing,times:valueOffset},sequenceTransition);}});return animationDefinitions;}function getSubjectSequence(subject,sequences){!sequences.has(subject)&&sequences.set(subject,{});return sequences.get(subject);}function getValueSequence(name,sequences){if(!sequences[name])sequences[name]=[];return sequences[name];}function keyframesAsList(keyframes){return Array.isArray(keyframes)?keyframes:[keyframes];}function getValueTransition(transition,key){return transition&&transition[key]?_objectSpread(_objectSpread({},transition),transition[key]):_objectSpread({},transition);}const isNumber=keyframe=>typeof keyframe===\"number\";const isNumberKeyframesArray=keyframes=>keyframes.every(isNumber);export{createAnimationsFromSequence,getValueTransition};","map":{"version":3,"names":["isMotionValue","defaultOffset","isGenerator","createGeneratorEasing","fillOffset","progress","secondsToMilliseconds","invariant","getEasingForSegment","resolveSubjects","calculateRepeatDuration","calcNextTime","addKeyframes","normalizeTimes","compareByTime","defaultSegmentEasing","MAX_REPEAT","createAnimationsFromSequence","sequence","_ref","arguments","length","undefined","defaultTransition","sequenceTransition","_objectWithoutProperties","_excluded","scope","generators","defaultDuration","duration","animationDefinitions","Map","sequences","elementCache","timeLabels","prevTime","currentTime","totalDuration","i","segment","set","Array","isArray","name","at","subject","keyframes","transition","maxDuration","resolveValueSequence","valueKeyframes","valueTransition","valueSequence","_duration","elementIndex","numSubjects","valueKeyframesAsList","keyframesAsList","delay","times","type","repeat","repeatType","repeatDelay","remainingTransition","_excluded2","ease","calculatedDelay","numKeyframes","createGenerator","absoluteDelta","isNumberKeyframesArray","delta","Math","abs","springTransition","_objectSpread","springEasing","startTime","remainder","unshift","originalKeyframes","originalTimes","originalEase","repeatIndex","push","keyframeIndex","targetTime","max","subjectSequence","getSubjectSequence","getValueSequence","subjects","subjectIndex","thisSubject","key","getValueTransition","forEach","valueSequences","element","sort","valueOffset","valueEasing","value","easing","has","definition","get","isNumber","keyframe","every"],"sources":["/home/antisyn/portfolio/src/components/node_modules/framer-motion/dist/es/animation/sequence/create.mjs"],"sourcesContent":["import { isMotionValue, defaultOffset, isGenerator, createGeneratorEasing, fillOffset } from 'motion-dom';\nimport { progress, secondsToMilliseconds, invariant, getEasingForSegment } from 'motion-utils';\nimport { resolveSubjects } from '../animate/resolve-subjects.mjs';\nimport { calculateRepeatDuration } from './utils/calc-repeat-duration.mjs';\nimport { calcNextTime } from './utils/calc-time.mjs';\nimport { addKeyframes } from './utils/edit.mjs';\nimport { normalizeTimes } from './utils/normalize-times.mjs';\nimport { compareByTime } from './utils/sort.mjs';\n\nconst defaultSegmentEasing = \"easeInOut\";\nconst MAX_REPEAT = 20;\nfunction createAnimationsFromSequence(sequence, { defaultTransition = {}, ...sequenceTransition } = {}, scope, generators) {\n    const defaultDuration = defaultTransition.duration || 0.3;\n    const animationDefinitions = new Map();\n    const sequences = new Map();\n    const elementCache = {};\n    const timeLabels = new Map();\n    let prevTime = 0;\n    let currentTime = 0;\n    let totalDuration = 0;\n    /**\n     * Build the timeline by mapping over the sequence array and converting\n     * the definitions into keyframes and offsets with absolute time values.\n     * These will later get converted into relative offsets in a second pass.\n     */\n    for (let i = 0; i < sequence.length; i++) {\n        const segment = sequence[i];\n        /**\n         * If this is a timeline label, mark it and skip the rest of this iteration.\n         */\n        if (typeof segment === \"string\") {\n            timeLabels.set(segment, currentTime);\n            continue;\n        }\n        else if (!Array.isArray(segment)) {\n            timeLabels.set(segment.name, calcNextTime(currentTime, segment.at, prevTime, timeLabels));\n            continue;\n        }\n        let [subject, keyframes, transition = {}] = segment;\n        /**\n         * If a relative or absolute time value has been specified we need to resolve\n         * it in relation to the currentTime.\n         */\n        if (transition.at !== undefined) {\n            currentTime = calcNextTime(currentTime, transition.at, prevTime, timeLabels);\n        }\n        /**\n         * Keep track of the maximum duration in this definition. This will be\n         * applied to currentTime once the definition has been parsed.\n         */\n        let maxDuration = 0;\n        const resolveValueSequence = (valueKeyframes, valueTransition, valueSequence, elementIndex = 0, numSubjects = 0) => {\n            const valueKeyframesAsList = keyframesAsList(valueKeyframes);\n            const { delay = 0, times = defaultOffset(valueKeyframesAsList), type = \"keyframes\", repeat, repeatType, repeatDelay = 0, ...remainingTransition } = valueTransition;\n            let { ease = defaultTransition.ease || \"easeOut\", duration } = valueTransition;\n            /**\n             * Resolve stagger() if defined.\n             */\n            const calculatedDelay = typeof delay === \"function\"\n                ? delay(elementIndex, numSubjects)\n                : delay;\n            /**\n             * If this animation should and can use a spring, generate a spring easing function.\n             */\n            const numKeyframes = valueKeyframesAsList.length;\n            const createGenerator = isGenerator(type)\n                ? type\n                : generators?.[type || \"keyframes\"];\n            if (numKeyframes <= 2 && createGenerator) {\n                /**\n                 * As we're creating an easing function from a spring,\n                 * ideally we want to generate it using the real distance\n                 * between the two keyframes. However this isn't always\n                 * possible - in these situations we use 0-100.\n                 */\n                let absoluteDelta = 100;\n                if (numKeyframes === 2 &&\n                    isNumberKeyframesArray(valueKeyframesAsList)) {\n                    const delta = valueKeyframesAsList[1] - valueKeyframesAsList[0];\n                    absoluteDelta = Math.abs(delta);\n                }\n                const springTransition = { ...remainingTransition };\n                if (duration !== undefined) {\n                    springTransition.duration = secondsToMilliseconds(duration);\n                }\n                const springEasing = createGeneratorEasing(springTransition, absoluteDelta, createGenerator);\n                ease = springEasing.ease;\n                duration = springEasing.duration;\n            }\n            duration ?? (duration = defaultDuration);\n            const startTime = currentTime + calculatedDelay;\n            /**\n             * If there's only one time offset of 0, fill in a second with length 1\n             */\n            if (times.length === 1 && times[0] === 0) {\n                times[1] = 1;\n            }\n            /**\n             * Fill out if offset if fewer offsets than keyframes\n             */\n            const remainder = times.length - valueKeyframesAsList.length;\n            remainder > 0 && fillOffset(times, remainder);\n            /**\n             * If only one value has been set, ie [1], push a null to the start of\n             * the keyframe array. This will let us mark a keyframe at this point\n             * that will later be hydrated with the previous value.\n             */\n            valueKeyframesAsList.length === 1 &&\n                valueKeyframesAsList.unshift(null);\n            /**\n             * Handle repeat options\n             */\n            if (repeat) {\n                invariant(repeat < MAX_REPEAT, \"Repeat count too high, must be less than 20\");\n                duration = calculateRepeatDuration(duration, repeat);\n                const originalKeyframes = [...valueKeyframesAsList];\n                const originalTimes = [...times];\n                ease = Array.isArray(ease) ? [...ease] : [ease];\n                const originalEase = [...ease];\n                for (let repeatIndex = 0; repeatIndex < repeat; repeatIndex++) {\n                    valueKeyframesAsList.push(...originalKeyframes);\n                    for (let keyframeIndex = 0; keyframeIndex < originalKeyframes.length; keyframeIndex++) {\n                        times.push(originalTimes[keyframeIndex] + (repeatIndex + 1));\n                        ease.push(keyframeIndex === 0\n                            ? \"linear\"\n                            : getEasingForSegment(originalEase, keyframeIndex - 1));\n                    }\n                }\n                normalizeTimes(times, repeat);\n            }\n            const targetTime = startTime + duration;\n            /**\n             * Add keyframes, mapping offsets to absolute time.\n             */\n            addKeyframes(valueSequence, valueKeyframesAsList, ease, times, startTime, targetTime);\n            maxDuration = Math.max(calculatedDelay + duration, maxDuration);\n            totalDuration = Math.max(targetTime, totalDuration);\n        };\n        if (isMotionValue(subject)) {\n            const subjectSequence = getSubjectSequence(subject, sequences);\n            resolveValueSequence(keyframes, transition, getValueSequence(\"default\", subjectSequence));\n        }\n        else {\n            const subjects = resolveSubjects(subject, keyframes, scope, elementCache);\n            const numSubjects = subjects.length;\n            /**\n             * For every element in this segment, process the defined values.\n             */\n            for (let subjectIndex = 0; subjectIndex < numSubjects; subjectIndex++) {\n                /**\n                 * Cast necessary, but we know these are of this type\n                 */\n                keyframes = keyframes;\n                transition = transition;\n                const thisSubject = subjects[subjectIndex];\n                const subjectSequence = getSubjectSequence(thisSubject, sequences);\n                for (const key in keyframes) {\n                    resolveValueSequence(keyframes[key], getValueTransition(transition, key), getValueSequence(key, subjectSequence), subjectIndex, numSubjects);\n                }\n            }\n        }\n        prevTime = currentTime;\n        currentTime += maxDuration;\n    }\n    /**\n     * For every element and value combination create a new animation.\n     */\n    sequences.forEach((valueSequences, element) => {\n        for (const key in valueSequences) {\n            const valueSequence = valueSequences[key];\n            /**\n             * Arrange all the keyframes in ascending time order.\n             */\n            valueSequence.sort(compareByTime);\n            const keyframes = [];\n            const valueOffset = [];\n            const valueEasing = [];\n            /**\n             * For each keyframe, translate absolute times into\n             * relative offsets based on the total duration of the timeline.\n             */\n            for (let i = 0; i < valueSequence.length; i++) {\n                const { at, value, easing } = valueSequence[i];\n                keyframes.push(value);\n                valueOffset.push(progress(0, totalDuration, at));\n                valueEasing.push(easing || \"easeOut\");\n            }\n            /**\n             * If the first keyframe doesn't land on offset: 0\n             * provide one by duplicating the initial keyframe. This ensures\n             * it snaps to the first keyframe when the animation starts.\n             */\n            if (valueOffset[0] !== 0) {\n                valueOffset.unshift(0);\n                keyframes.unshift(keyframes[0]);\n                valueEasing.unshift(defaultSegmentEasing);\n            }\n            /**\n             * If the last keyframe doesn't land on offset: 1\n             * provide one with a null wildcard value. This will ensure it\n             * stays static until the end of the animation.\n             */\n            if (valueOffset[valueOffset.length - 1] !== 1) {\n                valueOffset.push(1);\n                keyframes.push(null);\n            }\n            if (!animationDefinitions.has(element)) {\n                animationDefinitions.set(element, {\n                    keyframes: {},\n                    transition: {},\n                });\n            }\n            const definition = animationDefinitions.get(element);\n            definition.keyframes[key] = keyframes;\n            definition.transition[key] = {\n                ...defaultTransition,\n                duration: totalDuration,\n                ease: valueEasing,\n                times: valueOffset,\n                ...sequenceTransition,\n            };\n        }\n    });\n    return animationDefinitions;\n}\nfunction getSubjectSequence(subject, sequences) {\n    !sequences.has(subject) && sequences.set(subject, {});\n    return sequences.get(subject);\n}\nfunction getValueSequence(name, sequences) {\n    if (!sequences[name])\n        sequences[name] = [];\n    return sequences[name];\n}\nfunction keyframesAsList(keyframes) {\n    return Array.isArray(keyframes) ? keyframes : [keyframes];\n}\nfunction getValueTransition(transition, key) {\n    return transition && transition[key]\n        ? {\n            ...transition,\n            ...transition[key],\n        }\n        : { ...transition };\n}\nconst isNumber = (keyframe) => typeof keyframe === \"number\";\nconst isNumberKeyframesArray = (keyframes) => keyframes.every(isNumber);\n\nexport { createAnimationsFromSequence, getValueTransition };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}