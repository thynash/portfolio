{"ast":null,"code":"import _objectSpread from\"/home/antisyn/portfolio/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";import _objectWithoutProperties from\"/home/antisyn/portfolio/node_modules/@babel/runtime/helpers/esm/objectWithoutProperties.js\";const _excluded=[\"transition\",\"transitionEnd\"];import{getValueTransition,frame,positionalKeys}from'motion-dom';import{setTarget}from'../../render/utils/setters.mjs';import{addValueToWillChange}from'../../value/use-will-change/add-will-change.mjs';import{getOptimisedAppearId}from'../optimized-appear/get-appear-id.mjs';import{animateMotionValue}from'./motion-value.mjs';/**\n * Decide whether we should block this animation. Previously, we achieved this\n * just by checking whether the key was listed in protectedKeys, but this\n * posed problems if an animation was triggered by afterChildren and protectedKeys\n * had been set to true in the meantime.\n */function shouldBlockAnimation(_ref,key){let{protectedKeys,needsAnimating}=_ref;const shouldBlock=protectedKeys.hasOwnProperty(key)&&needsAnimating[key]!==true;needsAnimating[key]=false;return shouldBlock;}function animateTarget(visualElement,targetAndTransition){let{delay=0,transitionOverride,type}=arguments.length>2&&arguments[2]!==undefined?arguments[2]:{};let{transition=visualElement.getDefaultTransition(),transitionEnd}=targetAndTransition,target=_objectWithoutProperties(targetAndTransition,_excluded);if(transitionOverride)transition=transitionOverride;const animations=[];const animationTypeState=type&&visualElement.animationState&&visualElement.animationState.getState()[type];for(const key in target){var _visualElement$latest;const value=visualElement.getValue(key,(_visualElement$latest=visualElement.latestValues[key])!==null&&_visualElement$latest!==void 0?_visualElement$latest:null);const valueTarget=target[key];if(valueTarget===undefined||animationTypeState&&shouldBlockAnimation(animationTypeState,key)){continue;}const valueTransition=_objectSpread({delay},getValueTransition(transition||{},key));/**\n         * If the value is already at the defined target, skip the animation.\n         */const currentValue=value.get();if(currentValue!==undefined&&!value.isAnimating&&!Array.isArray(valueTarget)&&valueTarget===currentValue&&!valueTransition.velocity){continue;}/**\n         * If this is the first time a value is being animated, check\n         * to see if we're handling off from an existing animation.\n         */let isHandoff=false;if(window.MotionHandoffAnimation){const appearId=getOptimisedAppearId(visualElement);if(appearId){const startTime=window.MotionHandoffAnimation(appearId,key,frame);if(startTime!==null){valueTransition.startTime=startTime;isHandoff=true;}}}addValueToWillChange(visualElement,key);value.start(animateMotionValue(key,value,valueTarget,visualElement.shouldReduceMotion&&positionalKeys.has(key)?{type:false}:valueTransition,visualElement,isHandoff));const animation=value.animation;if(animation){animations.push(animation);}}if(transitionEnd){Promise.all(animations).then(()=>{frame.update(()=>{transitionEnd&&setTarget(visualElement,transitionEnd);});});}return animations;}export{animateTarget};","map":{"version":3,"names":["getValueTransition","frame","positionalKeys","setTarget","addValueToWillChange","getOptimisedAppearId","animateMotionValue","shouldBlockAnimation","_ref","key","protectedKeys","needsAnimating","shouldBlock","hasOwnProperty","animateTarget","visualElement","targetAndTransition","delay","transitionOverride","type","arguments","length","undefined","transition","getDefaultTransition","transitionEnd","target","_objectWithoutProperties","_excluded","animations","animationTypeState","animationState","getState","_visualElement$latest","value","getValue","latestValues","valueTarget","valueTransition","_objectSpread","currentValue","get","isAnimating","Array","isArray","velocity","isHandoff","window","MotionHandoffAnimation","appearId","startTime","start","shouldReduceMotion","has","animation","push","Promise","all","then","update"],"sources":["/home/antisyn/portfolio/src/components/node_modules/framer-motion/dist/es/animation/interfaces/visual-element-target.mjs"],"sourcesContent":["import { getValueTransition, frame, positionalKeys } from 'motion-dom';\nimport { setTarget } from '../../render/utils/setters.mjs';\nimport { addValueToWillChange } from '../../value/use-will-change/add-will-change.mjs';\nimport { getOptimisedAppearId } from '../optimized-appear/get-appear-id.mjs';\nimport { animateMotionValue } from './motion-value.mjs';\n\n/**\n * Decide whether we should block this animation. Previously, we achieved this\n * just by checking whether the key was listed in protectedKeys, but this\n * posed problems if an animation was triggered by afterChildren and protectedKeys\n * had been set to true in the meantime.\n */\nfunction shouldBlockAnimation({ protectedKeys, needsAnimating }, key) {\n    const shouldBlock = protectedKeys.hasOwnProperty(key) && needsAnimating[key] !== true;\n    needsAnimating[key] = false;\n    return shouldBlock;\n}\nfunction animateTarget(visualElement, targetAndTransition, { delay = 0, transitionOverride, type } = {}) {\n    let { transition = visualElement.getDefaultTransition(), transitionEnd, ...target } = targetAndTransition;\n    if (transitionOverride)\n        transition = transitionOverride;\n    const animations = [];\n    const animationTypeState = type &&\n        visualElement.animationState &&\n        visualElement.animationState.getState()[type];\n    for (const key in target) {\n        const value = visualElement.getValue(key, visualElement.latestValues[key] ?? null);\n        const valueTarget = target[key];\n        if (valueTarget === undefined ||\n            (animationTypeState &&\n                shouldBlockAnimation(animationTypeState, key))) {\n            continue;\n        }\n        const valueTransition = {\n            delay,\n            ...getValueTransition(transition || {}, key),\n        };\n        /**\n         * If the value is already at the defined target, skip the animation.\n         */\n        const currentValue = value.get();\n        if (currentValue !== undefined &&\n            !value.isAnimating &&\n            !Array.isArray(valueTarget) &&\n            valueTarget === currentValue &&\n            !valueTransition.velocity) {\n            continue;\n        }\n        /**\n         * If this is the first time a value is being animated, check\n         * to see if we're handling off from an existing animation.\n         */\n        let isHandoff = false;\n        if (window.MotionHandoffAnimation) {\n            const appearId = getOptimisedAppearId(visualElement);\n            if (appearId) {\n                const startTime = window.MotionHandoffAnimation(appearId, key, frame);\n                if (startTime !== null) {\n                    valueTransition.startTime = startTime;\n                    isHandoff = true;\n                }\n            }\n        }\n        addValueToWillChange(visualElement, key);\n        value.start(animateMotionValue(key, value, valueTarget, visualElement.shouldReduceMotion && positionalKeys.has(key)\n            ? { type: false }\n            : valueTransition, visualElement, isHandoff));\n        const animation = value.animation;\n        if (animation) {\n            animations.push(animation);\n        }\n    }\n    if (transitionEnd) {\n        Promise.all(animations).then(() => {\n            frame.update(() => {\n                transitionEnd && setTarget(visualElement, transitionEnd);\n            });\n        });\n    }\n    return animations;\n}\n\nexport { animateTarget };\n"],"mappings":"4RAAA,OAASA,kBAAkB,CAAEC,KAAK,CAAEC,cAAc,KAAQ,YAAY,CACtE,OAASC,SAAS,KAAQ,gCAAgC,CAC1D,OAASC,oBAAoB,KAAQ,iDAAiD,CACtF,OAASC,oBAAoB,KAAQ,uCAAuC,CAC5E,OAASC,kBAAkB,KAAQ,oBAAoB,CAEvD;AACA;AACA;AACA;AACA;AACA,GACA,QAAS,CAAAC,oBAAoBA,CAAAC,IAAA,CAAoCC,GAAG,CAAE,IAAxC,CAAEC,aAAa,CAAEC,cAAe,CAAC,CAAAH,IAAA,CAC3D,KAAM,CAAAI,WAAW,CAAGF,aAAa,CAACG,cAAc,CAACJ,GAAG,CAAC,EAAIE,cAAc,CAACF,GAAG,CAAC,GAAK,IAAI,CACrFE,cAAc,CAACF,GAAG,CAAC,CAAG,KAAK,CAC3B,MAAO,CAAAG,WAAW,CACtB,CACA,QAAS,CAAAE,aAAaA,CAACC,aAAa,CAAEC,mBAAmB,CAAgD,IAA9C,CAAEC,KAAK,CAAG,CAAC,CAAEC,kBAAkB,CAAEC,IAAK,CAAC,CAAAC,SAAA,CAAAC,MAAA,IAAAD,SAAA,MAAAE,SAAA,CAAAF,SAAA,IAAG,CAAC,CAAC,CACnG,GAAI,CAAEG,UAAU,CAAGR,aAAa,CAACS,oBAAoB,CAAC,CAAC,CAAEC,aAAyB,CAAC,CAAGT,mBAAmB,CAA9BU,MAAM,CAAAC,wBAAA,CAAKX,mBAAmB,CAAAY,SAAA,EACzG,GAAIV,kBAAkB,CAClBK,UAAU,CAAGL,kBAAkB,CACnC,KAAM,CAAAW,UAAU,CAAG,EAAE,CACrB,KAAM,CAAAC,kBAAkB,CAAGX,IAAI,EAC3BJ,aAAa,CAACgB,cAAc,EAC5BhB,aAAa,CAACgB,cAAc,CAACC,QAAQ,CAAC,CAAC,CAACb,IAAI,CAAC,CACjD,IAAK,KAAM,CAAAV,GAAG,GAAI,CAAAiB,MAAM,CAAE,KAAAO,qBAAA,CACtB,KAAM,CAAAC,KAAK,CAAGnB,aAAa,CAACoB,QAAQ,CAAC1B,GAAG,EAAAwB,qBAAA,CAAElB,aAAa,CAACqB,YAAY,CAAC3B,GAAG,CAAC,UAAAwB,qBAAA,UAAAA,qBAAA,CAAI,IAAI,CAAC,CAClF,KAAM,CAAAI,WAAW,CAAGX,MAAM,CAACjB,GAAG,CAAC,CAC/B,GAAI4B,WAAW,GAAKf,SAAS,EACxBQ,kBAAkB,EACfvB,oBAAoB,CAACuB,kBAAkB,CAAErB,GAAG,CAAE,CAAE,CACpD,SACJ,CACA,KAAM,CAAA6B,eAAe,CAAAC,aAAA,EACjBtB,KAAK,EACFjB,kBAAkB,CAACuB,UAAU,EAAI,CAAC,CAAC,CAAEd,GAAG,CAAC,CAC/C,CACD;AACR;AACA,WACQ,KAAM,CAAA+B,YAAY,CAAGN,KAAK,CAACO,GAAG,CAAC,CAAC,CAChC,GAAID,YAAY,GAAKlB,SAAS,EAC1B,CAACY,KAAK,CAACQ,WAAW,EAClB,CAACC,KAAK,CAACC,OAAO,CAACP,WAAW,CAAC,EAC3BA,WAAW,GAAKG,YAAY,EAC5B,CAACF,eAAe,CAACO,QAAQ,CAAE,CAC3B,SACJ,CACA;AACR;AACA;AACA,WACQ,GAAI,CAAAC,SAAS,CAAG,KAAK,CACrB,GAAIC,MAAM,CAACC,sBAAsB,CAAE,CAC/B,KAAM,CAAAC,QAAQ,CAAG5C,oBAAoB,CAACU,aAAa,CAAC,CACpD,GAAIkC,QAAQ,CAAE,CACV,KAAM,CAAAC,SAAS,CAAGH,MAAM,CAACC,sBAAsB,CAACC,QAAQ,CAAExC,GAAG,CAAER,KAAK,CAAC,CACrE,GAAIiD,SAAS,GAAK,IAAI,CAAE,CACpBZ,eAAe,CAACY,SAAS,CAAGA,SAAS,CACrCJ,SAAS,CAAG,IAAI,CACpB,CACJ,CACJ,CACA1C,oBAAoB,CAACW,aAAa,CAAEN,GAAG,CAAC,CACxCyB,KAAK,CAACiB,KAAK,CAAC7C,kBAAkB,CAACG,GAAG,CAAEyB,KAAK,CAAEG,WAAW,CAAEtB,aAAa,CAACqC,kBAAkB,EAAIlD,cAAc,CAACmD,GAAG,CAAC5C,GAAG,CAAC,CAC7G,CAAEU,IAAI,CAAE,KAAM,CAAC,CACfmB,eAAe,CAAEvB,aAAa,CAAE+B,SAAS,CAAC,CAAC,CACjD,KAAM,CAAAQ,SAAS,CAAGpB,KAAK,CAACoB,SAAS,CACjC,GAAIA,SAAS,CAAE,CACXzB,UAAU,CAAC0B,IAAI,CAACD,SAAS,CAAC,CAC9B,CACJ,CACA,GAAI7B,aAAa,CAAE,CACf+B,OAAO,CAACC,GAAG,CAAC5B,UAAU,CAAC,CAAC6B,IAAI,CAAC,IAAM,CAC/BzD,KAAK,CAAC0D,MAAM,CAAC,IAAM,CACflC,aAAa,EAAItB,SAAS,CAACY,aAAa,CAAEU,aAAa,CAAC,CAC5D,CAAC,CAAC,CACN,CAAC,CAAC,CACN,CACA,MAAO,CAAAI,UAAU,CACrB,CAEA,OAASf,aAAa","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}