{"ast":null,"code":"import{memo}from'motion-utils';import{isHTMLElement}from'../../../utils/is-html-element.mjs';/**\n * A list of values that can be hardware-accelerated.\n */const acceleratedValues=new Set([\"opacity\",\"clipPath\",\"filter\",\"transform\"// TODO: Could be re-enabled now we have support for linear() easing\n// \"background-color\"\n]);const supportsWaapi=/*@__PURE__*/memo(()=>Object.hasOwnProperty.call(Element.prototype,\"animate\"));function supportsBrowserAnimation(options){var _motionValue$owner;const{motionValue,name,repeatDelay,repeatType,damping,type}=options;if(!isHTMLElement(motionValue===null||motionValue===void 0?void 0:(_motionValue$owner=motionValue.owner)===null||_motionValue$owner===void 0?void 0:_motionValue$owner.current)){return false;}const{onUpdate,transformTemplate}=motionValue.owner.getProps();return supportsWaapi()&&name&&acceleratedValues.has(name)&&(name!==\"transform\"||!transformTemplate)&&/**\n         * If we're outputting values to onUpdate then we can't use WAAPI as there's\n         * no way to read the value from WAAPI every frame.\n         */!onUpdate&&!repeatDelay&&repeatType!==\"mirror\"&&damping!==0&&type!==\"inertia\";}export{supportsBrowserAnimation};","map":{"version":3,"names":["memo","isHTMLElement","acceleratedValues","Set","supportsWaapi","Object","hasOwnProperty","call","Element","prototype","supportsBrowserAnimation","options","_motionValue$owner","motionValue","name","repeatDelay","repeatType","damping","type","owner","current","onUpdate","transformTemplate","getProps","has"],"sources":["/home/antisyn/portfolio/src/components/node_modules/motion-dom/dist/es/animation/waapi/supports/waapi.mjs"],"sourcesContent":["import { memo } from 'motion-utils';\nimport { isHTMLElement } from '../../../utils/is-html-element.mjs';\n\n/**\n * A list of values that can be hardware-accelerated.\n */\nconst acceleratedValues = new Set([\n    \"opacity\",\n    \"clipPath\",\n    \"filter\",\n    \"transform\",\n    // TODO: Could be re-enabled now we have support for linear() easing\n    // \"background-color\"\n]);\nconst supportsWaapi = /*@__PURE__*/ memo(() => Object.hasOwnProperty.call(Element.prototype, \"animate\"));\nfunction supportsBrowserAnimation(options) {\n    const { motionValue, name, repeatDelay, repeatType, damping, type } = options;\n    if (!isHTMLElement(motionValue?.owner?.current)) {\n        return false;\n    }\n    const { onUpdate, transformTemplate } = motionValue.owner.getProps();\n    return (supportsWaapi() &&\n        name &&\n        acceleratedValues.has(name) &&\n        (name !== \"transform\" || !transformTemplate) &&\n        /**\n         * If we're outputting values to onUpdate then we can't use WAAPI as there's\n         * no way to read the value from WAAPI every frame.\n         */\n        !onUpdate &&\n        !repeatDelay &&\n        repeatType !== \"mirror\" &&\n        damping !== 0 &&\n        type !== \"inertia\");\n}\n\nexport { supportsBrowserAnimation };\n"],"mappings":"AAAA,OAASA,IAAI,KAAQ,cAAc,CACnC,OAASC,aAAa,KAAQ,oCAAoC,CAElE;AACA;AACA,GACA,KAAM,CAAAC,iBAAiB,CAAG,GAAI,CAAAC,GAAG,CAAC,CAC9B,SAAS,CACT,UAAU,CACV,QAAQ,CACR,WACA;AACA;AAAA,CACH,CAAC,CACF,KAAM,CAAAC,aAAa,CAAG,aAAcJ,IAAI,CAAC,IAAMK,MAAM,CAACC,cAAc,CAACC,IAAI,CAACC,OAAO,CAACC,SAAS,CAAE,SAAS,CAAC,CAAC,CACxG,QAAS,CAAAC,wBAAwBA,CAACC,OAAO,CAAE,KAAAC,kBAAA,CACvC,KAAM,CAAEC,WAAW,CAAEC,IAAI,CAAEC,WAAW,CAAEC,UAAU,CAAEC,OAAO,CAAEC,IAAK,CAAC,CAAGP,OAAO,CAC7E,GAAI,CAACV,aAAa,CAACY,WAAW,SAAXA,WAAW,kBAAAD,kBAAA,CAAXC,WAAW,CAAEM,KAAK,UAAAP,kBAAA,iBAAlBA,kBAAA,CAAoBQ,OAAO,CAAC,CAAE,CAC7C,MAAO,MAAK,CAChB,CACA,KAAM,CAAEC,QAAQ,CAAEC,iBAAkB,CAAC,CAAGT,WAAW,CAACM,KAAK,CAACI,QAAQ,CAAC,CAAC,CACpE,MAAQ,CAAAnB,aAAa,CAAC,CAAC,EACnBU,IAAI,EACJZ,iBAAiB,CAACsB,GAAG,CAACV,IAAI,CAAC,GAC1BA,IAAI,GAAK,WAAW,EAAI,CAACQ,iBAAiB,CAAC,EAC5C;AACR;AACA;AACA,WACQ,CAACD,QAAQ,EACT,CAACN,WAAW,EACZC,UAAU,GAAK,QAAQ,EACvBC,OAAO,GAAK,CAAC,EACbC,IAAI,GAAK,SAAS,CAC1B,CAEA,OAASR,wBAAwB","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}