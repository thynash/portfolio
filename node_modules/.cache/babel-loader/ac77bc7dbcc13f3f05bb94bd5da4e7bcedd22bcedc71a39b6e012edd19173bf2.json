{"ast":null,"code":"import{mixNumber}from'motion-dom';import{progress,clamp}from'motion-utils';import{calcLength}from'../../../projection/geometry/delta-calc.mjs';/**\n * Apply constraints to a point. These constraints are both physical along an\n * axis, and an elastic factor that determines how much to constrain the point\n * by if it does lie outside the defined parameters.\n */function applyConstraints(point,_ref,elastic){let{min,max}=_ref;if(min!==undefined&&point<min){// If we have a min point defined, and this is outside of that, constrain\npoint=elastic?mixNumber(min,point,elastic.min):Math.max(point,min);}else if(max!==undefined&&point>max){// If we have a max point defined, and this is outside of that, constrain\npoint=elastic?mixNumber(max,point,elastic.max):Math.min(point,max);}return point;}/**\n * Calculate constraints in terms of the viewport when defined relatively to the\n * measured axis. This is measured from the nearest edge, so a max constraint of 200\n * on an axis with a max value of 300 would return a constraint of 500 - axis length\n */function calcRelativeAxisConstraints(axis,min,max){return{min:min!==undefined?axis.min+min:undefined,max:max!==undefined?axis.max+max-(axis.max-axis.min):undefined};}/**\n * Calculate constraints in terms of the viewport when\n * defined relatively to the measured bounding box.\n */function calcRelativeConstraints(layoutBox,_ref2){let{top,left,bottom,right}=_ref2;return{x:calcRelativeAxisConstraints(layoutBox.x,left,right),y:calcRelativeAxisConstraints(layoutBox.y,top,bottom)};}/**\n * Calculate viewport constraints when defined as another viewport-relative axis\n */function calcViewportAxisConstraints(layoutAxis,constraintsAxis){let min=constraintsAxis.min-layoutAxis.min;let max=constraintsAxis.max-layoutAxis.max;// If the constraints axis is actually smaller than the layout axis then we can\n// flip the constraints\nif(constraintsAxis.max-constraintsAxis.min<layoutAxis.max-layoutAxis.min){[min,max]=[max,min];}return{min,max};}/**\n * Calculate viewport constraints when defined as another viewport-relative box\n */function calcViewportConstraints(layoutBox,constraintsBox){return{x:calcViewportAxisConstraints(layoutBox.x,constraintsBox.x),y:calcViewportAxisConstraints(layoutBox.y,constraintsBox.y)};}/**\n * Calculate a transform origin relative to the source axis, between 0-1, that results\n * in an asthetically pleasing scale/transform needed to project from source to target.\n */function calcOrigin(source,target){let origin=0.5;const sourceLength=calcLength(source);const targetLength=calcLength(target);if(targetLength>sourceLength){origin=progress(target.min,target.max-sourceLength,source.min);}else if(sourceLength>targetLength){origin=progress(source.min,source.max-targetLength,target.min);}return clamp(0,1,origin);}/**\n * Rebase the calculated viewport constraints relative to the layout.min point.\n */function rebaseAxisConstraints(layout,constraints){const relativeConstraints={};if(constraints.min!==undefined){relativeConstraints.min=constraints.min-layout.min;}if(constraints.max!==undefined){relativeConstraints.max=constraints.max-layout.min;}return relativeConstraints;}const defaultElastic=0.35;/**\n * Accepts a dragElastic prop and returns resolved elastic values for each axis.\n */function resolveDragElastic(){let dragElastic=arguments.length>0&&arguments[0]!==undefined?arguments[0]:defaultElastic;if(dragElastic===false){dragElastic=0;}else if(dragElastic===true){dragElastic=defaultElastic;}return{x:resolveAxisElastic(dragElastic,\"left\",\"right\"),y:resolveAxisElastic(dragElastic,\"top\",\"bottom\")};}function resolveAxisElastic(dragElastic,minLabel,maxLabel){return{min:resolvePointElastic(dragElastic,minLabel),max:resolvePointElastic(dragElastic,maxLabel)};}function resolvePointElastic(dragElastic,label){return typeof dragElastic===\"number\"?dragElastic:dragElastic[label]||0;}export{applyConstraints,calcOrigin,calcRelativeAxisConstraints,calcRelativeConstraints,calcViewportAxisConstraints,calcViewportConstraints,defaultElastic,rebaseAxisConstraints,resolveAxisElastic,resolveDragElastic,resolvePointElastic};","map":{"version":3,"names":["mixNumber","progress","clamp","calcLength","applyConstraints","point","_ref","elastic","min","max","undefined","Math","calcRelativeAxisConstraints","axis","calcRelativeConstraints","layoutBox","_ref2","top","left","bottom","right","x","y","calcViewportAxisConstraints","layoutAxis","constraintsAxis","calcViewportConstraints","constraintsBox","calcOrigin","source","target","origin","sourceLength","targetLength","rebaseAxisConstraints","layout","constraints","relativeConstraints","defaultElastic","resolveDragElastic","dragElastic","arguments","length","resolveAxisElastic","minLabel","maxLabel","resolvePointElastic","label"],"sources":["/home/antisyn/portfolio/src/components/node_modules/framer-motion/dist/es/gestures/drag/utils/constraints.mjs"],"sourcesContent":["import { mixNumber } from 'motion-dom';\nimport { progress, clamp } from 'motion-utils';\nimport { calcLength } from '../../../projection/geometry/delta-calc.mjs';\n\n/**\n * Apply constraints to a point. These constraints are both physical along an\n * axis, and an elastic factor that determines how much to constrain the point\n * by if it does lie outside the defined parameters.\n */\nfunction applyConstraints(point, { min, max }, elastic) {\n    if (min !== undefined && point < min) {\n        // If we have a min point defined, and this is outside of that, constrain\n        point = elastic\n            ? mixNumber(min, point, elastic.min)\n            : Math.max(point, min);\n    }\n    else if (max !== undefined && point > max) {\n        // If we have a max point defined, and this is outside of that, constrain\n        point = elastic\n            ? mixNumber(max, point, elastic.max)\n            : Math.min(point, max);\n    }\n    return point;\n}\n/**\n * Calculate constraints in terms of the viewport when defined relatively to the\n * measured axis. This is measured from the nearest edge, so a max constraint of 200\n * on an axis with a max value of 300 would return a constraint of 500 - axis length\n */\nfunction calcRelativeAxisConstraints(axis, min, max) {\n    return {\n        min: min !== undefined ? axis.min + min : undefined,\n        max: max !== undefined\n            ? axis.max + max - (axis.max - axis.min)\n            : undefined,\n    };\n}\n/**\n * Calculate constraints in terms of the viewport when\n * defined relatively to the measured bounding box.\n */\nfunction calcRelativeConstraints(layoutBox, { top, left, bottom, right }) {\n    return {\n        x: calcRelativeAxisConstraints(layoutBox.x, left, right),\n        y: calcRelativeAxisConstraints(layoutBox.y, top, bottom),\n    };\n}\n/**\n * Calculate viewport constraints when defined as another viewport-relative axis\n */\nfunction calcViewportAxisConstraints(layoutAxis, constraintsAxis) {\n    let min = constraintsAxis.min - layoutAxis.min;\n    let max = constraintsAxis.max - layoutAxis.max;\n    // If the constraints axis is actually smaller than the layout axis then we can\n    // flip the constraints\n    if (constraintsAxis.max - constraintsAxis.min <\n        layoutAxis.max - layoutAxis.min) {\n        [min, max] = [max, min];\n    }\n    return { min, max };\n}\n/**\n * Calculate viewport constraints when defined as another viewport-relative box\n */\nfunction calcViewportConstraints(layoutBox, constraintsBox) {\n    return {\n        x: calcViewportAxisConstraints(layoutBox.x, constraintsBox.x),\n        y: calcViewportAxisConstraints(layoutBox.y, constraintsBox.y),\n    };\n}\n/**\n * Calculate a transform origin relative to the source axis, between 0-1, that results\n * in an asthetically pleasing scale/transform needed to project from source to target.\n */\nfunction calcOrigin(source, target) {\n    let origin = 0.5;\n    const sourceLength = calcLength(source);\n    const targetLength = calcLength(target);\n    if (targetLength > sourceLength) {\n        origin = progress(target.min, target.max - sourceLength, source.min);\n    }\n    else if (sourceLength > targetLength) {\n        origin = progress(source.min, source.max - targetLength, target.min);\n    }\n    return clamp(0, 1, origin);\n}\n/**\n * Rebase the calculated viewport constraints relative to the layout.min point.\n */\nfunction rebaseAxisConstraints(layout, constraints) {\n    const relativeConstraints = {};\n    if (constraints.min !== undefined) {\n        relativeConstraints.min = constraints.min - layout.min;\n    }\n    if (constraints.max !== undefined) {\n        relativeConstraints.max = constraints.max - layout.min;\n    }\n    return relativeConstraints;\n}\nconst defaultElastic = 0.35;\n/**\n * Accepts a dragElastic prop and returns resolved elastic values for each axis.\n */\nfunction resolveDragElastic(dragElastic = defaultElastic) {\n    if (dragElastic === false) {\n        dragElastic = 0;\n    }\n    else if (dragElastic === true) {\n        dragElastic = defaultElastic;\n    }\n    return {\n        x: resolveAxisElastic(dragElastic, \"left\", \"right\"),\n        y: resolveAxisElastic(dragElastic, \"top\", \"bottom\"),\n    };\n}\nfunction resolveAxisElastic(dragElastic, minLabel, maxLabel) {\n    return {\n        min: resolvePointElastic(dragElastic, minLabel),\n        max: resolvePointElastic(dragElastic, maxLabel),\n    };\n}\nfunction resolvePointElastic(dragElastic, label) {\n    return typeof dragElastic === \"number\"\n        ? dragElastic\n        : dragElastic[label] || 0;\n}\n\nexport { applyConstraints, calcOrigin, calcRelativeAxisConstraints, calcRelativeConstraints, calcViewportAxisConstraints, calcViewportConstraints, defaultElastic, rebaseAxisConstraints, resolveAxisElastic, resolveDragElastic, resolvePointElastic };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}