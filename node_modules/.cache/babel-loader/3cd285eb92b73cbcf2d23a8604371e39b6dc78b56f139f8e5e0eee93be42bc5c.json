{"ast":null,"code":"import{px}from'motion-dom';function pixelsToPercent(pixels,axis){if(axis.max===axis.min)return 0;return pixels/(axis.max-axis.min)*100;}/**\n * We always correct borderRadius as a percentage rather than pixels to reduce paints.\n * For example, if you are projecting a box that is 100px wide with a 10px borderRadius\n * into a box that is 200px wide with a 20px borderRadius, that is actually a 10%\n * borderRadius in both states. If we animate between the two in pixels that will trigger\n * a paint each time. If we animate between the two in percentage we'll avoid a paint.\n */const correctBorderRadius={correct:(latest,node)=>{if(!node.target)return latest;/**\n         * If latest is a string, if it's a percentage we can return immediately as it's\n         * going to be stretched appropriately. Otherwise, if it's a pixel, convert it to a number.\n         */if(typeof latest===\"string\"){if(px.test(latest)){latest=parseFloat(latest);}else{return latest;}}/**\n         * If latest is a number, it's a pixel value. We use the current viewportBox to calculate that\n         * pixel value as a percentage of each axis\n         */const x=pixelsToPercent(latest,node.target.x);const y=pixelsToPercent(latest,node.target.y);return\"\".concat(x,\"% \").concat(y,\"%\");}};export{correctBorderRadius,pixelsToPercent};","map":{"version":3,"names":["px","pixelsToPercent","pixels","axis","max","min","correctBorderRadius","correct","latest","node","target","test","parseFloat","x","y","concat"],"sources":["/home/antisyn/portfolio/src/components/node_modules/framer-motion/dist/es/projection/styles/scale-border-radius.mjs"],"sourcesContent":["import { px } from 'motion-dom';\n\nfunction pixelsToPercent(pixels, axis) {\n    if (axis.max === axis.min)\n        return 0;\n    return (pixels / (axis.max - axis.min)) * 100;\n}\n/**\n * We always correct borderRadius as a percentage rather than pixels to reduce paints.\n * For example, if you are projecting a box that is 100px wide with a 10px borderRadius\n * into a box that is 200px wide with a 20px borderRadius, that is actually a 10%\n * borderRadius in both states. If we animate between the two in pixels that will trigger\n * a paint each time. If we animate between the two in percentage we'll avoid a paint.\n */\nconst correctBorderRadius = {\n    correct: (latest, node) => {\n        if (!node.target)\n            return latest;\n        /**\n         * If latest is a string, if it's a percentage we can return immediately as it's\n         * going to be stretched appropriately. Otherwise, if it's a pixel, convert it to a number.\n         */\n        if (typeof latest === \"string\") {\n            if (px.test(latest)) {\n                latest = parseFloat(latest);\n            }\n            else {\n                return latest;\n            }\n        }\n        /**\n         * If latest is a number, it's a pixel value. We use the current viewportBox to calculate that\n         * pixel value as a percentage of each axis\n         */\n        const x = pixelsToPercent(latest, node.target.x);\n        const y = pixelsToPercent(latest, node.target.y);\n        return `${x}% ${y}%`;\n    },\n};\n\nexport { correctBorderRadius, pixelsToPercent };\n"],"mappings":"AAAA,OAASA,EAAE,KAAQ,YAAY,CAE/B,QAAS,CAAAC,eAAeA,CAACC,MAAM,CAAEC,IAAI,CAAE,CACnC,GAAIA,IAAI,CAACC,GAAG,GAAKD,IAAI,CAACE,GAAG,CACrB,MAAO,EAAC,CACZ,MAAQ,CAAAH,MAAM,EAAIC,IAAI,CAACC,GAAG,CAAGD,IAAI,CAACE,GAAG,CAAC,CAAI,GAAG,CACjD,CACA;AACA;AACA;AACA;AACA;AACA;AACA,GACA,KAAM,CAAAC,mBAAmB,CAAG,CACxBC,OAAO,CAAEA,CAACC,MAAM,CAAEC,IAAI,GAAK,CACvB,GAAI,CAACA,IAAI,CAACC,MAAM,CACZ,MAAO,CAAAF,MAAM,CACjB;AACR;AACA;AACA,WACQ,GAAI,MAAO,CAAAA,MAAM,GAAK,QAAQ,CAAE,CAC5B,GAAIR,EAAE,CAACW,IAAI,CAACH,MAAM,CAAC,CAAE,CACjBA,MAAM,CAAGI,UAAU,CAACJ,MAAM,CAAC,CAC/B,CAAC,IACI,CACD,MAAO,CAAAA,MAAM,CACjB,CACJ,CACA;AACR;AACA;AACA,WACQ,KAAM,CAAAK,CAAC,CAAGZ,eAAe,CAACO,MAAM,CAAEC,IAAI,CAACC,MAAM,CAACG,CAAC,CAAC,CAChD,KAAM,CAAAC,CAAC,CAAGb,eAAe,CAACO,MAAM,CAAEC,IAAI,CAACC,MAAM,CAACI,CAAC,CAAC,CAChD,SAAAC,MAAA,CAAUF,CAAC,OAAAE,MAAA,CAAKD,CAAC,MACrB,CACJ,CAAC,CAED,OAASR,mBAAmB,CAAEL,eAAe","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}