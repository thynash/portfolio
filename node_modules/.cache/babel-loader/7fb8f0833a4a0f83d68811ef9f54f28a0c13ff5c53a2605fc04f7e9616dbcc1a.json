{"ast":null,"code":"function buildProjectionTransform(delta,treeScale,latestTransform){let transform=\"\";/**\n     * The translations we use to calculate are always relative to the viewport coordinate space.\n     * But when we apply scales, we also scale the coordinate space of an element and its children.\n     * For instance if we have a treeScale (the culmination of all parent scales) of 0.5 and we need\n     * to move an element 100 pixels, we actually need to move it 200 in within that scaled space.\n     */const xTranslate=delta.x.translate/treeScale.x;const yTranslate=delta.y.translate/treeScale.y;const zTranslate=(latestTransform===null||latestTransform===void 0?void 0:latestTransform.z)||0;if(xTranslate||yTranslate||zTranslate){transform=\"translate3d(\".concat(xTranslate,\"px, \").concat(yTranslate,\"px, \").concat(zTranslate,\"px) \");}/**\n     * Apply scale correction for the tree transform.\n     * This will apply scale to the screen-orientated axes.\n     */if(treeScale.x!==1||treeScale.y!==1){transform+=\"scale(\".concat(1/treeScale.x,\", \").concat(1/treeScale.y,\") \");}if(latestTransform){const{transformPerspective,rotate,rotateX,rotateY,skewX,skewY}=latestTransform;if(transformPerspective)transform=\"perspective(\".concat(transformPerspective,\"px) \").concat(transform);if(rotate)transform+=\"rotate(\".concat(rotate,\"deg) \");if(rotateX)transform+=\"rotateX(\".concat(rotateX,\"deg) \");if(rotateY)transform+=\"rotateY(\".concat(rotateY,\"deg) \");if(skewX)transform+=\"skewX(\".concat(skewX,\"deg) \");if(skewY)transform+=\"skewY(\".concat(skewY,\"deg) \");}/**\n     * Apply scale to match the size of the element to the size we want it.\n     * This will apply scale to the element-orientated axes.\n     */const elementScaleX=delta.x.scale*treeScale.x;const elementScaleY=delta.y.scale*treeScale.y;if(elementScaleX!==1||elementScaleY!==1){transform+=\"scale(\".concat(elementScaleX,\", \").concat(elementScaleY,\")\");}return transform||\"none\";}export{buildProjectionTransform};","map":{"version":3,"names":["buildProjectionTransform","delta","treeScale","latestTransform","transform","xTranslate","x","translate","yTranslate","y","zTranslate","z","concat","transformPerspective","rotate","rotateX","rotateY","skewX","skewY","elementScaleX","scale","elementScaleY"],"sources":["/home/antisyn/portfolio/src/components/node_modules/framer-motion/dist/es/projection/styles/transform.mjs"],"sourcesContent":["function buildProjectionTransform(delta, treeScale, latestTransform) {\n    let transform = \"\";\n    /**\n     * The translations we use to calculate are always relative to the viewport coordinate space.\n     * But when we apply scales, we also scale the coordinate space of an element and its children.\n     * For instance if we have a treeScale (the culmination of all parent scales) of 0.5 and we need\n     * to move an element 100 pixels, we actually need to move it 200 in within that scaled space.\n     */\n    const xTranslate = delta.x.translate / treeScale.x;\n    const yTranslate = delta.y.translate / treeScale.y;\n    const zTranslate = latestTransform?.z || 0;\n    if (xTranslate || yTranslate || zTranslate) {\n        transform = `translate3d(${xTranslate}px, ${yTranslate}px, ${zTranslate}px) `;\n    }\n    /**\n     * Apply scale correction for the tree transform.\n     * This will apply scale to the screen-orientated axes.\n     */\n    if (treeScale.x !== 1 || treeScale.y !== 1) {\n        transform += `scale(${1 / treeScale.x}, ${1 / treeScale.y}) `;\n    }\n    if (latestTransform) {\n        const { transformPerspective, rotate, rotateX, rotateY, skewX, skewY } = latestTransform;\n        if (transformPerspective)\n            transform = `perspective(${transformPerspective}px) ${transform}`;\n        if (rotate)\n            transform += `rotate(${rotate}deg) `;\n        if (rotateX)\n            transform += `rotateX(${rotateX}deg) `;\n        if (rotateY)\n            transform += `rotateY(${rotateY}deg) `;\n        if (skewX)\n            transform += `skewX(${skewX}deg) `;\n        if (skewY)\n            transform += `skewY(${skewY}deg) `;\n    }\n    /**\n     * Apply scale to match the size of the element to the size we want it.\n     * This will apply scale to the element-orientated axes.\n     */\n    const elementScaleX = delta.x.scale * treeScale.x;\n    const elementScaleY = delta.y.scale * treeScale.y;\n    if (elementScaleX !== 1 || elementScaleY !== 1) {\n        transform += `scale(${elementScaleX}, ${elementScaleY})`;\n    }\n    return transform || \"none\";\n}\n\nexport { buildProjectionTransform };\n"],"mappings":"AAAA,QAAS,CAAAA,wBAAwBA,CAACC,KAAK,CAAEC,SAAS,CAAEC,eAAe,CAAE,CACjE,GAAI,CAAAC,SAAS,CAAG,EAAE,CAClB;AACJ;AACA;AACA;AACA;AACA,OACI,KAAM,CAAAC,UAAU,CAAGJ,KAAK,CAACK,CAAC,CAACC,SAAS,CAAGL,SAAS,CAACI,CAAC,CAClD,KAAM,CAAAE,UAAU,CAAGP,KAAK,CAACQ,CAAC,CAACF,SAAS,CAAGL,SAAS,CAACO,CAAC,CAClD,KAAM,CAAAC,UAAU,CAAG,CAAAP,eAAe,SAAfA,eAAe,iBAAfA,eAAe,CAAEQ,CAAC,GAAI,CAAC,CAC1C,GAAIN,UAAU,EAAIG,UAAU,EAAIE,UAAU,CAAE,CACxCN,SAAS,gBAAAQ,MAAA,CAAkBP,UAAU,SAAAO,MAAA,CAAOJ,UAAU,SAAAI,MAAA,CAAOF,UAAU,QAAM,CACjF,CACA;AACJ;AACA;AACA,OACI,GAAIR,SAAS,CAACI,CAAC,GAAK,CAAC,EAAIJ,SAAS,CAACO,CAAC,GAAK,CAAC,CAAE,CACxCL,SAAS,WAAAQ,MAAA,CAAa,CAAC,CAAGV,SAAS,CAACI,CAAC,OAAAM,MAAA,CAAK,CAAC,CAAGV,SAAS,CAACO,CAAC,MAAI,CACjE,CACA,GAAIN,eAAe,CAAE,CACjB,KAAM,CAAEU,oBAAoB,CAAEC,MAAM,CAAEC,OAAO,CAAEC,OAAO,CAAEC,KAAK,CAAEC,KAAM,CAAC,CAAGf,eAAe,CACxF,GAAIU,oBAAoB,CACpBT,SAAS,gBAAAQ,MAAA,CAAkBC,oBAAoB,SAAAD,MAAA,CAAOR,SAAS,CAAE,CACrE,GAAIU,MAAM,CACNV,SAAS,YAAAQ,MAAA,CAAcE,MAAM,SAAO,CACxC,GAAIC,OAAO,CACPX,SAAS,aAAAQ,MAAA,CAAeG,OAAO,SAAO,CAC1C,GAAIC,OAAO,CACPZ,SAAS,aAAAQ,MAAA,CAAeI,OAAO,SAAO,CAC1C,GAAIC,KAAK,CACLb,SAAS,WAAAQ,MAAA,CAAaK,KAAK,SAAO,CACtC,GAAIC,KAAK,CACLd,SAAS,WAAAQ,MAAA,CAAaM,KAAK,SAAO,CAC1C,CACA;AACJ;AACA;AACA,OACI,KAAM,CAAAC,aAAa,CAAGlB,KAAK,CAACK,CAAC,CAACc,KAAK,CAAGlB,SAAS,CAACI,CAAC,CACjD,KAAM,CAAAe,aAAa,CAAGpB,KAAK,CAACQ,CAAC,CAACW,KAAK,CAAGlB,SAAS,CAACO,CAAC,CACjD,GAAIU,aAAa,GAAK,CAAC,EAAIE,aAAa,GAAK,CAAC,CAAE,CAC5CjB,SAAS,WAAAQ,MAAA,CAAaO,aAAa,OAAAP,MAAA,CAAKS,aAAa,KAAG,CAC5D,CACA,MAAO,CAAAjB,SAAS,EAAI,MAAM,CAC9B,CAEA,OAASJ,wBAAwB","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}