{"ast":null,"code":"import{warnOnce}from'motion-utils';import{updateScrollInfo}from'./info.mjs';import{resolveOffsets}from'./offsets/index.mjs';function measure(container){let target=arguments.length>1&&arguments[1]!==undefined?arguments[1]:container;let info=arguments.length>2?arguments[2]:undefined;/**\n     * Find inset of target within scrollable container\n     */info.x.targetOffset=0;info.y.targetOffset=0;if(target!==container){let node=target;while(node&&node!==container){info.x.targetOffset+=node.offsetLeft;info.y.targetOffset+=node.offsetTop;node=node.offsetParent;}}info.x.targetLength=target===container?target.scrollWidth:target.clientWidth;info.y.targetLength=target===container?target.scrollHeight:target.clientHeight;info.x.containerLength=container.clientWidth;info.y.containerLength=container.clientHeight;/**\n     * In development mode ensure scroll containers aren't position: static as this makes\n     * it difficult to measure their relative positions.\n     */if(process.env.NODE_ENV!==\"production\"){if(container&&target&&target!==container){warnOnce(getComputedStyle(container).position!==\"static\",\"Please ensure that the container has a non-static position, like 'relative', 'fixed', or 'absolute' to ensure scroll offset is calculated correctly.\");}}}function createOnScrollHandler(element,onScroll,info){let options=arguments.length>3&&arguments[3]!==undefined?arguments[3]:{};return{measure:time=>{measure(element,options.target,info);updateScrollInfo(element,info,time);if(options.offset||options.target){resolveOffsets(element,info,options);}},notify:()=>onScroll(info)};}export{createOnScrollHandler};","map":{"version":3,"names":["warnOnce","updateScrollInfo","resolveOffsets","measure","container","target","arguments","length","undefined","info","x","targetOffset","y","node","offsetLeft","offsetTop","offsetParent","targetLength","scrollWidth","clientWidth","scrollHeight","clientHeight","containerLength","process","env","NODE_ENV","getComputedStyle","position","createOnScrollHandler","element","onScroll","options","time","offset","notify"],"sources":["/home/antisyn/portfolio/src/components/node_modules/framer-motion/dist/es/render/dom/scroll/on-scroll-handler.mjs"],"sourcesContent":["import { warnOnce } from 'motion-utils';\nimport { updateScrollInfo } from './info.mjs';\nimport { resolveOffsets } from './offsets/index.mjs';\n\nfunction measure(container, target = container, info) {\n    /**\n     * Find inset of target within scrollable container\n     */\n    info.x.targetOffset = 0;\n    info.y.targetOffset = 0;\n    if (target !== container) {\n        let node = target;\n        while (node && node !== container) {\n            info.x.targetOffset += node.offsetLeft;\n            info.y.targetOffset += node.offsetTop;\n            node = node.offsetParent;\n        }\n    }\n    info.x.targetLength =\n        target === container ? target.scrollWidth : target.clientWidth;\n    info.y.targetLength =\n        target === container ? target.scrollHeight : target.clientHeight;\n    info.x.containerLength = container.clientWidth;\n    info.y.containerLength = container.clientHeight;\n    /**\n     * In development mode ensure scroll containers aren't position: static as this makes\n     * it difficult to measure their relative positions.\n     */\n    if (process.env.NODE_ENV !== \"production\") {\n        if (container && target && target !== container) {\n            warnOnce(getComputedStyle(container).position !== \"static\", \"Please ensure that the container has a non-static position, like 'relative', 'fixed', or 'absolute' to ensure scroll offset is calculated correctly.\");\n        }\n    }\n}\nfunction createOnScrollHandler(element, onScroll, info, options = {}) {\n    return {\n        measure: (time) => {\n            measure(element, options.target, info);\n            updateScrollInfo(element, info, time);\n            if (options.offset || options.target) {\n                resolveOffsets(element, info, options);\n            }\n        },\n        notify: () => onScroll(info),\n    };\n}\n\nexport { createOnScrollHandler };\n"],"mappings":"AAAA,OAASA,QAAQ,KAAQ,cAAc,CACvC,OAASC,gBAAgB,KAAQ,YAAY,CAC7C,OAASC,cAAc,KAAQ,qBAAqB,CAEpD,QAAS,CAAAC,OAAOA,CAACC,SAAS,CAA4B,IAA1B,CAAAC,MAAM,CAAAC,SAAA,CAAAC,MAAA,IAAAD,SAAA,MAAAE,SAAA,CAAAF,SAAA,IAAGF,SAAS,IAAE,CAAAK,IAAI,CAAAH,SAAA,CAAAC,MAAA,GAAAD,SAAA,IAAAE,SAAA,CAChD;AACJ;AACA,OACIC,IAAI,CAACC,CAAC,CAACC,YAAY,CAAG,CAAC,CACvBF,IAAI,CAACG,CAAC,CAACD,YAAY,CAAG,CAAC,CACvB,GAAIN,MAAM,GAAKD,SAAS,CAAE,CACtB,GAAI,CAAAS,IAAI,CAAGR,MAAM,CACjB,MAAOQ,IAAI,EAAIA,IAAI,GAAKT,SAAS,CAAE,CAC/BK,IAAI,CAACC,CAAC,CAACC,YAAY,EAAIE,IAAI,CAACC,UAAU,CACtCL,IAAI,CAACG,CAAC,CAACD,YAAY,EAAIE,IAAI,CAACE,SAAS,CACrCF,IAAI,CAAGA,IAAI,CAACG,YAAY,CAC5B,CACJ,CACAP,IAAI,CAACC,CAAC,CAACO,YAAY,CACfZ,MAAM,GAAKD,SAAS,CAAGC,MAAM,CAACa,WAAW,CAAGb,MAAM,CAACc,WAAW,CAClEV,IAAI,CAACG,CAAC,CAACK,YAAY,CACfZ,MAAM,GAAKD,SAAS,CAAGC,MAAM,CAACe,YAAY,CAAGf,MAAM,CAACgB,YAAY,CACpEZ,IAAI,CAACC,CAAC,CAACY,eAAe,CAAGlB,SAAS,CAACe,WAAW,CAC9CV,IAAI,CAACG,CAAC,CAACU,eAAe,CAAGlB,SAAS,CAACiB,YAAY,CAC/C;AACJ;AACA;AACA,OACI,GAAIE,OAAO,CAACC,GAAG,CAACC,QAAQ,GAAK,YAAY,CAAE,CACvC,GAAIrB,SAAS,EAAIC,MAAM,EAAIA,MAAM,GAAKD,SAAS,CAAE,CAC7CJ,QAAQ,CAAC0B,gBAAgB,CAACtB,SAAS,CAAC,CAACuB,QAAQ,GAAK,QAAQ,CAAE,sJAAsJ,CAAC,CACvN,CACJ,CACJ,CACA,QAAS,CAAAC,qBAAqBA,CAACC,OAAO,CAAEC,QAAQ,CAAErB,IAAI,CAAgB,IAAd,CAAAsB,OAAO,CAAAzB,SAAA,CAAAC,MAAA,IAAAD,SAAA,MAAAE,SAAA,CAAAF,SAAA,IAAG,CAAC,CAAC,CAChE,MAAO,CACHH,OAAO,CAAG6B,IAAI,EAAK,CACf7B,OAAO,CAAC0B,OAAO,CAAEE,OAAO,CAAC1B,MAAM,CAAEI,IAAI,CAAC,CACtCR,gBAAgB,CAAC4B,OAAO,CAAEpB,IAAI,CAAEuB,IAAI,CAAC,CACrC,GAAID,OAAO,CAACE,MAAM,EAAIF,OAAO,CAAC1B,MAAM,CAAE,CAClCH,cAAc,CAAC2B,OAAO,CAAEpB,IAAI,CAAEsB,OAAO,CAAC,CAC1C,CACJ,CAAC,CACDG,MAAM,CAAEA,CAAA,GAAMJ,QAAQ,CAACrB,IAAI,CAC/B,CAAC,CACL,CAEA,OAASmB,qBAAqB","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}