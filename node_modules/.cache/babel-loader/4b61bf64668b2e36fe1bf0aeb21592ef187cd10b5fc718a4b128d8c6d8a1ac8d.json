{"ast":null,"code":"import _objectSpread from\"/home/antisyn/portfolio/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";import{resolveVariant}from'../../render/utils/resolve-dynamic-variants.mjs';import{animateTarget}from'./visual-element-target.mjs';function animateVariant(visualElement,variant){var _visualElement$presen;let options=arguments.length>2&&arguments[2]!==undefined?arguments[2]:{};const resolved=resolveVariant(visualElement,variant,options.type===\"exit\"?(_visualElement$presen=visualElement.presenceContext)===null||_visualElement$presen===void 0?void 0:_visualElement$presen.custom:undefined);let{transition=visualElement.getDefaultTransition()||{}}=resolved||{};if(options.transitionOverride){transition=options.transitionOverride;}/**\n     * If we have a variant, create a callback that runs it as an animation.\n     * Otherwise, we resolve a Promise immediately for a composable no-op.\n     */const getAnimation=resolved?()=>Promise.all(animateTarget(visualElement,resolved,options)):()=>Promise.resolve();/**\n     * If we have children, create a callback that runs all their animations.\n     * Otherwise, we resolve a Promise immediately for a composable no-op.\n     */const getChildAnimations=visualElement.variantChildren&&visualElement.variantChildren.size?(forwardDelay=0)=>{const{delayChildren=0,staggerChildren,staggerDirection}=transition;return animateChildren(visualElement,variant,delayChildren+forwardDelay,staggerChildren,staggerDirection,options);}:()=>Promise.resolve();/**\n     * If the transition explicitly defines a \"when\" option, we need to resolve either\n     * this animation or all children animations before playing the other.\n     */const{when}=transition;if(when){const[first,last]=when===\"beforeChildren\"?[getAnimation,getChildAnimations]:[getChildAnimations,getAnimation];return first().then(()=>last());}else{return Promise.all([getAnimation(),getChildAnimations(options.delay)]);}}function animateChildren(visualElement,variant){let delayChildren=arguments.length>2&&arguments[2]!==undefined?arguments[2]:0;let staggerChildren=arguments.length>3&&arguments[3]!==undefined?arguments[3]:0;let staggerDirection=arguments.length>4&&arguments[4]!==undefined?arguments[4]:1;let options=arguments.length>5?arguments[5]:undefined;const animations=[];const maxStaggerDuration=(visualElement.variantChildren.size-1)*staggerChildren;const generateStaggerDuration=staggerDirection===1?function(){let i=arguments.length>0&&arguments[0]!==undefined?arguments[0]:0;return i*staggerChildren;}:function(){let i=arguments.length>0&&arguments[0]!==undefined?arguments[0]:0;return maxStaggerDuration-i*staggerChildren;};Array.from(visualElement.variantChildren).sort(sortByTreeOrder).forEach((child,i)=>{child.notify(\"AnimationStart\",variant);animations.push(animateVariant(child,variant,_objectSpread(_objectSpread({},options),{},{delay:delayChildren+generateStaggerDuration(i)})).then(()=>child.notify(\"AnimationComplete\",variant)));});return Promise.all(animations);}function sortByTreeOrder(a,b){return a.sortNodePosition(b);}export{animateVariant,sortByTreeOrder};","map":{"version":3,"names":["resolveVariant","animateTarget","animateVariant","visualElement","variant","_visualElement$presen","options","arguments","length","undefined","resolved","type","presenceContext","custom","transition","getDefaultTransition","transitionOverride","getAnimation","Promise","all","resolve","getChildAnimations","variantChildren","size","forwardDelay","delayChildren","staggerChildren","staggerDirection","animateChildren","when","first","last","then","delay","animations","maxStaggerDuration","generateStaggerDuration","i","Array","from","sort","sortByTreeOrder","forEach","child","notify","push","_objectSpread","a","b","sortNodePosition"],"sources":["/home/antisyn/portfolio/src/components/node_modules/framer-motion/dist/es/animation/interfaces/visual-element-variant.mjs"],"sourcesContent":["import { resolveVariant } from '../../render/utils/resolve-dynamic-variants.mjs';\nimport { animateTarget } from './visual-element-target.mjs';\n\nfunction animateVariant(visualElement, variant, options = {}) {\n    const resolved = resolveVariant(visualElement, variant, options.type === \"exit\"\n        ? visualElement.presenceContext?.custom\n        : undefined);\n    let { transition = visualElement.getDefaultTransition() || {} } = resolved || {};\n    if (options.transitionOverride) {\n        transition = options.transitionOverride;\n    }\n    /**\n     * If we have a variant, create a callback that runs it as an animation.\n     * Otherwise, we resolve a Promise immediately for a composable no-op.\n     */\n    const getAnimation = resolved\n        ? () => Promise.all(animateTarget(visualElement, resolved, options))\n        : () => Promise.resolve();\n    /**\n     * If we have children, create a callback that runs all their animations.\n     * Otherwise, we resolve a Promise immediately for a composable no-op.\n     */\n    const getChildAnimations = visualElement.variantChildren && visualElement.variantChildren.size\n        ? (forwardDelay = 0) => {\n            const { delayChildren = 0, staggerChildren, staggerDirection, } = transition;\n            return animateChildren(visualElement, variant, delayChildren + forwardDelay, staggerChildren, staggerDirection, options);\n        }\n        : () => Promise.resolve();\n    /**\n     * If the transition explicitly defines a \"when\" option, we need to resolve either\n     * this animation or all children animations before playing the other.\n     */\n    const { when } = transition;\n    if (when) {\n        const [first, last] = when === \"beforeChildren\"\n            ? [getAnimation, getChildAnimations]\n            : [getChildAnimations, getAnimation];\n        return first().then(() => last());\n    }\n    else {\n        return Promise.all([getAnimation(), getChildAnimations(options.delay)]);\n    }\n}\nfunction animateChildren(visualElement, variant, delayChildren = 0, staggerChildren = 0, staggerDirection = 1, options) {\n    const animations = [];\n    const maxStaggerDuration = (visualElement.variantChildren.size - 1) * staggerChildren;\n    const generateStaggerDuration = staggerDirection === 1\n        ? (i = 0) => i * staggerChildren\n        : (i = 0) => maxStaggerDuration - i * staggerChildren;\n    Array.from(visualElement.variantChildren)\n        .sort(sortByTreeOrder)\n        .forEach((child, i) => {\n        child.notify(\"AnimationStart\", variant);\n        animations.push(animateVariant(child, variant, {\n            ...options,\n            delay: delayChildren + generateStaggerDuration(i),\n        }).then(() => child.notify(\"AnimationComplete\", variant)));\n    });\n    return Promise.all(animations);\n}\nfunction sortByTreeOrder(a, b) {\n    return a.sortNodePosition(b);\n}\n\nexport { animateVariant, sortByTreeOrder };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}