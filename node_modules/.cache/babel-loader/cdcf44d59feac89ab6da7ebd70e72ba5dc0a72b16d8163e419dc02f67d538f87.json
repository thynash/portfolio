{"ast":null,"code":"import _objectSpread from\"/home/antisyn/portfolio/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";import{frame,isPrimaryPointer,cancelFrame,frameData}from'motion-dom';import{pipe,secondsToMilliseconds,millisecondsToSeconds}from'motion-utils';import{addPointerEvent}from'../../events/add-pointer-event.mjs';import{extractEventInfo}from'../../events/event-info.mjs';import{distance2D}from'../../utils/distance.mjs';/**\n * @internal\n */class PanSession{constructor(event,handlers){let{transformPagePoint,contextWindow,dragSnapToOrigin=false}=arguments.length>2&&arguments[2]!==undefined?arguments[2]:{};/**\n         * @internal\n         */this.startEvent=null;/**\n         * @internal\n         */this.lastMoveEvent=null;/**\n         * @internal\n         */this.lastMoveEventInfo=null;/**\n         * @internal\n         */this.handlers={};/**\n         * @internal\n         */this.contextWindow=window;this.updatePoint=()=>{if(!(this.lastMoveEvent&&this.lastMoveEventInfo))return;const info=getPanInfo(this.lastMoveEventInfo,this.history);const isPanStarted=this.startEvent!==null;// Only start panning if the offset is larger than 3 pixels. If we make it\n// any larger than this we'll want to reset the pointer history\n// on the first update to avoid visual snapping to the cursoe.\nconst isDistancePastThreshold=distance2D(info.offset,{x:0,y:0})>=3;if(!isPanStarted&&!isDistancePastThreshold)return;const{point}=info;const{timestamp}=frameData;this.history.push(_objectSpread(_objectSpread({},point),{},{timestamp}));const{onStart,onMove}=this.handlers;if(!isPanStarted){onStart&&onStart(this.lastMoveEvent,info);this.startEvent=this.lastMoveEvent;}onMove&&onMove(this.lastMoveEvent,info);};this.handlePointerMove=(event,info)=>{this.lastMoveEvent=event;this.lastMoveEventInfo=transformPoint(info,this.transformPagePoint);// Throttle mouse move event to once per frame\nframe.update(this.updatePoint,true);};this.handlePointerUp=(event,info)=>{this.end();const{onEnd,onSessionEnd,resumeAnimation}=this.handlers;if(this.dragSnapToOrigin)resumeAnimation&&resumeAnimation();if(!(this.lastMoveEvent&&this.lastMoveEventInfo))return;const panInfo=getPanInfo(event.type===\"pointercancel\"?this.lastMoveEventInfo:transformPoint(info,this.transformPagePoint),this.history);if(this.startEvent&&onEnd){onEnd(event,panInfo);}onSessionEnd&&onSessionEnd(event,panInfo);};// If we have more than one touch, don't start detecting this gesture\nif(!isPrimaryPointer(event))return;this.dragSnapToOrigin=dragSnapToOrigin;this.handlers=handlers;this.transformPagePoint=transformPagePoint;this.contextWindow=contextWindow||window;const info=extractEventInfo(event);const initialInfo=transformPoint(info,this.transformPagePoint);const{point}=initialInfo;const{timestamp}=frameData;this.history=[_objectSpread(_objectSpread({},point),{},{timestamp})];const{onSessionStart}=handlers;onSessionStart&&onSessionStart(event,getPanInfo(initialInfo,this.history));this.removeListeners=pipe(addPointerEvent(this.contextWindow,\"pointermove\",this.handlePointerMove),addPointerEvent(this.contextWindow,\"pointerup\",this.handlePointerUp),addPointerEvent(this.contextWindow,\"pointercancel\",this.handlePointerUp));}updateHandlers(handlers){this.handlers=handlers;}end(){this.removeListeners&&this.removeListeners();cancelFrame(this.updatePoint);}}function transformPoint(info,transformPagePoint){return transformPagePoint?{point:transformPagePoint(info.point)}:info;}function subtractPoint(a,b){return{x:a.x-b.x,y:a.y-b.y};}function getPanInfo(_ref,history){let{point}=_ref;return{point,delta:subtractPoint(point,lastDevicePoint(history)),offset:subtractPoint(point,startDevicePoint(history)),velocity:getVelocity(history,0.1)};}function startDevicePoint(history){return history[0];}function lastDevicePoint(history){return history[history.length-1];}function getVelocity(history,timeDelta){if(history.length<2){return{x:0,y:0};}let i=history.length-1;let timestampedPoint=null;const lastPoint=lastDevicePoint(history);while(i>=0){timestampedPoint=history[i];if(lastPoint.timestamp-timestampedPoint.timestamp>secondsToMilliseconds(timeDelta)){break;}i--;}if(!timestampedPoint){return{x:0,y:0};}const time=millisecondsToSeconds(lastPoint.timestamp-timestampedPoint.timestamp);if(time===0){return{x:0,y:0};}const currentVelocity={x:(lastPoint.x-timestampedPoint.x)/time,y:(lastPoint.y-timestampedPoint.y)/time};if(currentVelocity.x===Infinity){currentVelocity.x=0;}if(currentVelocity.y===Infinity){currentVelocity.y=0;}return currentVelocity;}export{PanSession};","map":{"version":3,"names":["frame","isPrimaryPointer","cancelFrame","frameData","pipe","secondsToMilliseconds","millisecondsToSeconds","addPointerEvent","extractEventInfo","distance2D","PanSession","constructor","event","handlers","transformPagePoint","contextWindow","dragSnapToOrigin","arguments","length","undefined","startEvent","lastMoveEvent","lastMoveEventInfo","window","updatePoint","info","getPanInfo","history","isPanStarted","isDistancePastThreshold","offset","x","y","point","timestamp","push","_objectSpread","onStart","onMove","handlePointerMove","transformPoint","update","handlePointerUp","end","onEnd","onSessionEnd","resumeAnimation","panInfo","type","initialInfo","onSessionStart","removeListeners","updateHandlers","subtractPoint","a","b","_ref","delta","lastDevicePoint","startDevicePoint","velocity","getVelocity","timeDelta","i","timestampedPoint","lastPoint","time","currentVelocity","Infinity"],"sources":["/home/antisyn/portfolio/src/components/node_modules/framer-motion/dist/es/gestures/pan/PanSession.mjs"],"sourcesContent":["import { frame, isPrimaryPointer, cancelFrame, frameData } from 'motion-dom';\nimport { pipe, secondsToMilliseconds, millisecondsToSeconds } from 'motion-utils';\nimport { addPointerEvent } from '../../events/add-pointer-event.mjs';\nimport { extractEventInfo } from '../../events/event-info.mjs';\nimport { distance2D } from '../../utils/distance.mjs';\n\n/**\n * @internal\n */\nclass PanSession {\n    constructor(event, handlers, { transformPagePoint, contextWindow, dragSnapToOrigin = false, } = {}) {\n        /**\n         * @internal\n         */\n        this.startEvent = null;\n        /**\n         * @internal\n         */\n        this.lastMoveEvent = null;\n        /**\n         * @internal\n         */\n        this.lastMoveEventInfo = null;\n        /**\n         * @internal\n         */\n        this.handlers = {};\n        /**\n         * @internal\n         */\n        this.contextWindow = window;\n        this.updatePoint = () => {\n            if (!(this.lastMoveEvent && this.lastMoveEventInfo))\n                return;\n            const info = getPanInfo(this.lastMoveEventInfo, this.history);\n            const isPanStarted = this.startEvent !== null;\n            // Only start panning if the offset is larger than 3 pixels. If we make it\n            // any larger than this we'll want to reset the pointer history\n            // on the first update to avoid visual snapping to the cursoe.\n            const isDistancePastThreshold = distance2D(info.offset, { x: 0, y: 0 }) >= 3;\n            if (!isPanStarted && !isDistancePastThreshold)\n                return;\n            const { point } = info;\n            const { timestamp } = frameData;\n            this.history.push({ ...point, timestamp });\n            const { onStart, onMove } = this.handlers;\n            if (!isPanStarted) {\n                onStart && onStart(this.lastMoveEvent, info);\n                this.startEvent = this.lastMoveEvent;\n            }\n            onMove && onMove(this.lastMoveEvent, info);\n        };\n        this.handlePointerMove = (event, info) => {\n            this.lastMoveEvent = event;\n            this.lastMoveEventInfo = transformPoint(info, this.transformPagePoint);\n            // Throttle mouse move event to once per frame\n            frame.update(this.updatePoint, true);\n        };\n        this.handlePointerUp = (event, info) => {\n            this.end();\n            const { onEnd, onSessionEnd, resumeAnimation } = this.handlers;\n            if (this.dragSnapToOrigin)\n                resumeAnimation && resumeAnimation();\n            if (!(this.lastMoveEvent && this.lastMoveEventInfo))\n                return;\n            const panInfo = getPanInfo(event.type === \"pointercancel\"\n                ? this.lastMoveEventInfo\n                : transformPoint(info, this.transformPagePoint), this.history);\n            if (this.startEvent && onEnd) {\n                onEnd(event, panInfo);\n            }\n            onSessionEnd && onSessionEnd(event, panInfo);\n        };\n        // If we have more than one touch, don't start detecting this gesture\n        if (!isPrimaryPointer(event))\n            return;\n        this.dragSnapToOrigin = dragSnapToOrigin;\n        this.handlers = handlers;\n        this.transformPagePoint = transformPagePoint;\n        this.contextWindow = contextWindow || window;\n        const info = extractEventInfo(event);\n        const initialInfo = transformPoint(info, this.transformPagePoint);\n        const { point } = initialInfo;\n        const { timestamp } = frameData;\n        this.history = [{ ...point, timestamp }];\n        const { onSessionStart } = handlers;\n        onSessionStart &&\n            onSessionStart(event, getPanInfo(initialInfo, this.history));\n        this.removeListeners = pipe(addPointerEvent(this.contextWindow, \"pointermove\", this.handlePointerMove), addPointerEvent(this.contextWindow, \"pointerup\", this.handlePointerUp), addPointerEvent(this.contextWindow, \"pointercancel\", this.handlePointerUp));\n    }\n    updateHandlers(handlers) {\n        this.handlers = handlers;\n    }\n    end() {\n        this.removeListeners && this.removeListeners();\n        cancelFrame(this.updatePoint);\n    }\n}\nfunction transformPoint(info, transformPagePoint) {\n    return transformPagePoint ? { point: transformPagePoint(info.point) } : info;\n}\nfunction subtractPoint(a, b) {\n    return { x: a.x - b.x, y: a.y - b.y };\n}\nfunction getPanInfo({ point }, history) {\n    return {\n        point,\n        delta: subtractPoint(point, lastDevicePoint(history)),\n        offset: subtractPoint(point, startDevicePoint(history)),\n        velocity: getVelocity(history, 0.1),\n    };\n}\nfunction startDevicePoint(history) {\n    return history[0];\n}\nfunction lastDevicePoint(history) {\n    return history[history.length - 1];\n}\nfunction getVelocity(history, timeDelta) {\n    if (history.length < 2) {\n        return { x: 0, y: 0 };\n    }\n    let i = history.length - 1;\n    let timestampedPoint = null;\n    const lastPoint = lastDevicePoint(history);\n    while (i >= 0) {\n        timestampedPoint = history[i];\n        if (lastPoint.timestamp - timestampedPoint.timestamp >\n            secondsToMilliseconds(timeDelta)) {\n            break;\n        }\n        i--;\n    }\n    if (!timestampedPoint) {\n        return { x: 0, y: 0 };\n    }\n    const time = millisecondsToSeconds(lastPoint.timestamp - timestampedPoint.timestamp);\n    if (time === 0) {\n        return { x: 0, y: 0 };\n    }\n    const currentVelocity = {\n        x: (lastPoint.x - timestampedPoint.x) / time,\n        y: (lastPoint.y - timestampedPoint.y) / time,\n    };\n    if (currentVelocity.x === Infinity) {\n        currentVelocity.x = 0;\n    }\n    if (currentVelocity.y === Infinity) {\n        currentVelocity.y = 0;\n    }\n    return currentVelocity;\n}\n\nexport { PanSession };\n"],"mappings":"4GAAA,OAASA,KAAK,CAAEC,gBAAgB,CAAEC,WAAW,CAAEC,SAAS,KAAQ,YAAY,CAC5E,OAASC,IAAI,CAAEC,qBAAqB,CAAEC,qBAAqB,KAAQ,cAAc,CACjF,OAASC,eAAe,KAAQ,oCAAoC,CACpE,OAASC,gBAAgB,KAAQ,6BAA6B,CAC9D,OAASC,UAAU,KAAQ,0BAA0B,CAErD;AACA;AACA,GACA,KAAM,CAAAC,UAAW,CACbC,WAAWA,CAACC,KAAK,CAAEC,QAAQ,CAAyE,IAAvE,CAAEC,kBAAkB,CAAEC,aAAa,CAAEC,gBAAgB,CAAG,KAAO,CAAC,CAAAC,SAAA,CAAAC,MAAA,IAAAD,SAAA,MAAAE,SAAA,CAAAF,SAAA,IAAG,CAAC,CAAC,CAC9F;AACR;AACA,WACQ,IAAI,CAACG,UAAU,CAAG,IAAI,CACtB;AACR;AACA,WACQ,IAAI,CAACC,aAAa,CAAG,IAAI,CACzB;AACR;AACA,WACQ,IAAI,CAACC,iBAAiB,CAAG,IAAI,CAC7B;AACR;AACA,WACQ,IAAI,CAACT,QAAQ,CAAG,CAAC,CAAC,CAClB;AACR;AACA,WACQ,IAAI,CAACE,aAAa,CAAGQ,MAAM,CAC3B,IAAI,CAACC,WAAW,CAAG,IAAM,CACrB,GAAI,EAAE,IAAI,CAACH,aAAa,EAAI,IAAI,CAACC,iBAAiB,CAAC,CAC/C,OACJ,KAAM,CAAAG,IAAI,CAAGC,UAAU,CAAC,IAAI,CAACJ,iBAAiB,CAAE,IAAI,CAACK,OAAO,CAAC,CAC7D,KAAM,CAAAC,YAAY,CAAG,IAAI,CAACR,UAAU,GAAK,IAAI,CAC7C;AACA;AACA;AACA,KAAM,CAAAS,uBAAuB,CAAGpB,UAAU,CAACgB,IAAI,CAACK,MAAM,CAAE,CAAEC,CAAC,CAAE,CAAC,CAAEC,CAAC,CAAE,CAAE,CAAC,CAAC,EAAI,CAAC,CAC5E,GAAI,CAACJ,YAAY,EAAI,CAACC,uBAAuB,CACzC,OACJ,KAAM,CAAEI,KAAM,CAAC,CAAGR,IAAI,CACtB,KAAM,CAAES,SAAU,CAAC,CAAG/B,SAAS,CAC/B,IAAI,CAACwB,OAAO,CAACQ,IAAI,CAAAC,aAAA,CAAAA,aAAA,IAAMH,KAAK,MAAEC,SAAS,EAAE,CAAC,CAC1C,KAAM,CAAEG,OAAO,CAAEC,MAAO,CAAC,CAAG,IAAI,CAACzB,QAAQ,CACzC,GAAI,CAACe,YAAY,CAAE,CACfS,OAAO,EAAIA,OAAO,CAAC,IAAI,CAAChB,aAAa,CAAEI,IAAI,CAAC,CAC5C,IAAI,CAACL,UAAU,CAAG,IAAI,CAACC,aAAa,CACxC,CACAiB,MAAM,EAAIA,MAAM,CAAC,IAAI,CAACjB,aAAa,CAAEI,IAAI,CAAC,CAC9C,CAAC,CACD,IAAI,CAACc,iBAAiB,CAAG,CAAC3B,KAAK,CAAEa,IAAI,GAAK,CACtC,IAAI,CAACJ,aAAa,CAAGT,KAAK,CAC1B,IAAI,CAACU,iBAAiB,CAAGkB,cAAc,CAACf,IAAI,CAAE,IAAI,CAACX,kBAAkB,CAAC,CACtE;AACAd,KAAK,CAACyC,MAAM,CAAC,IAAI,CAACjB,WAAW,CAAE,IAAI,CAAC,CACxC,CAAC,CACD,IAAI,CAACkB,eAAe,CAAG,CAAC9B,KAAK,CAAEa,IAAI,GAAK,CACpC,IAAI,CAACkB,GAAG,CAAC,CAAC,CACV,KAAM,CAAEC,KAAK,CAAEC,YAAY,CAAEC,eAAgB,CAAC,CAAG,IAAI,CAACjC,QAAQ,CAC9D,GAAI,IAAI,CAACG,gBAAgB,CACrB8B,eAAe,EAAIA,eAAe,CAAC,CAAC,CACxC,GAAI,EAAE,IAAI,CAACzB,aAAa,EAAI,IAAI,CAACC,iBAAiB,CAAC,CAC/C,OACJ,KAAM,CAAAyB,OAAO,CAAGrB,UAAU,CAACd,KAAK,CAACoC,IAAI,GAAK,eAAe,CACnD,IAAI,CAAC1B,iBAAiB,CACtBkB,cAAc,CAACf,IAAI,CAAE,IAAI,CAACX,kBAAkB,CAAC,CAAE,IAAI,CAACa,OAAO,CAAC,CAClE,GAAI,IAAI,CAACP,UAAU,EAAIwB,KAAK,CAAE,CAC1BA,KAAK,CAAChC,KAAK,CAAEmC,OAAO,CAAC,CACzB,CACAF,YAAY,EAAIA,YAAY,CAACjC,KAAK,CAAEmC,OAAO,CAAC,CAChD,CAAC,CACD;AACA,GAAI,CAAC9C,gBAAgB,CAACW,KAAK,CAAC,CACxB,OACJ,IAAI,CAACI,gBAAgB,CAAGA,gBAAgB,CACxC,IAAI,CAACH,QAAQ,CAAGA,QAAQ,CACxB,IAAI,CAACC,kBAAkB,CAAGA,kBAAkB,CAC5C,IAAI,CAACC,aAAa,CAAGA,aAAa,EAAIQ,MAAM,CAC5C,KAAM,CAAAE,IAAI,CAAGjB,gBAAgB,CAACI,KAAK,CAAC,CACpC,KAAM,CAAAqC,WAAW,CAAGT,cAAc,CAACf,IAAI,CAAE,IAAI,CAACX,kBAAkB,CAAC,CACjE,KAAM,CAAEmB,KAAM,CAAC,CAAGgB,WAAW,CAC7B,KAAM,CAAEf,SAAU,CAAC,CAAG/B,SAAS,CAC/B,IAAI,CAACwB,OAAO,CAAG,CAAAS,aAAA,CAAAA,aAAA,IAAMH,KAAK,MAAEC,SAAS,GAAG,CACxC,KAAM,CAAEgB,cAAe,CAAC,CAAGrC,QAAQ,CACnCqC,cAAc,EACVA,cAAc,CAACtC,KAAK,CAAEc,UAAU,CAACuB,WAAW,CAAE,IAAI,CAACtB,OAAO,CAAC,CAAC,CAChE,IAAI,CAACwB,eAAe,CAAG/C,IAAI,CAACG,eAAe,CAAC,IAAI,CAACQ,aAAa,CAAE,aAAa,CAAE,IAAI,CAACwB,iBAAiB,CAAC,CAAEhC,eAAe,CAAC,IAAI,CAACQ,aAAa,CAAE,WAAW,CAAE,IAAI,CAAC2B,eAAe,CAAC,CAAEnC,eAAe,CAAC,IAAI,CAACQ,aAAa,CAAE,eAAe,CAAE,IAAI,CAAC2B,eAAe,CAAC,CAAC,CAC/P,CACAU,cAAcA,CAACvC,QAAQ,CAAE,CACrB,IAAI,CAACA,QAAQ,CAAGA,QAAQ,CAC5B,CACA8B,GAAGA,CAAA,CAAG,CACF,IAAI,CAACQ,eAAe,EAAI,IAAI,CAACA,eAAe,CAAC,CAAC,CAC9CjD,WAAW,CAAC,IAAI,CAACsB,WAAW,CAAC,CACjC,CACJ,CACA,QAAS,CAAAgB,cAAcA,CAACf,IAAI,CAAEX,kBAAkB,CAAE,CAC9C,MAAO,CAAAA,kBAAkB,CAAG,CAAEmB,KAAK,CAAEnB,kBAAkB,CAACW,IAAI,CAACQ,KAAK,CAAE,CAAC,CAAGR,IAAI,CAChF,CACA,QAAS,CAAA4B,aAAaA,CAACC,CAAC,CAAEC,CAAC,CAAE,CACzB,MAAO,CAAExB,CAAC,CAAEuB,CAAC,CAACvB,CAAC,CAAGwB,CAAC,CAACxB,CAAC,CAAEC,CAAC,CAAEsB,CAAC,CAACtB,CAAC,CAAGuB,CAAC,CAACvB,CAAE,CAAC,CACzC,CACA,QAAS,CAAAN,UAAUA,CAAA8B,IAAA,CAAY7B,OAAO,CAAE,IAApB,CAAEM,KAAM,CAAC,CAAAuB,IAAA,CACzB,MAAO,CACHvB,KAAK,CACLwB,KAAK,CAAEJ,aAAa,CAACpB,KAAK,CAAEyB,eAAe,CAAC/B,OAAO,CAAC,CAAC,CACrDG,MAAM,CAAEuB,aAAa,CAACpB,KAAK,CAAE0B,gBAAgB,CAAChC,OAAO,CAAC,CAAC,CACvDiC,QAAQ,CAAEC,WAAW,CAAClC,OAAO,CAAE,GAAG,CACtC,CAAC,CACL,CACA,QAAS,CAAAgC,gBAAgBA,CAAChC,OAAO,CAAE,CAC/B,MAAO,CAAAA,OAAO,CAAC,CAAC,CAAC,CACrB,CACA,QAAS,CAAA+B,eAAeA,CAAC/B,OAAO,CAAE,CAC9B,MAAO,CAAAA,OAAO,CAACA,OAAO,CAACT,MAAM,CAAG,CAAC,CAAC,CACtC,CACA,QAAS,CAAA2C,WAAWA,CAAClC,OAAO,CAAEmC,SAAS,CAAE,CACrC,GAAInC,OAAO,CAACT,MAAM,CAAG,CAAC,CAAE,CACpB,MAAO,CAAEa,CAAC,CAAE,CAAC,CAAEC,CAAC,CAAE,CAAE,CAAC,CACzB,CACA,GAAI,CAAA+B,CAAC,CAAGpC,OAAO,CAACT,MAAM,CAAG,CAAC,CAC1B,GAAI,CAAA8C,gBAAgB,CAAG,IAAI,CAC3B,KAAM,CAAAC,SAAS,CAAGP,eAAe,CAAC/B,OAAO,CAAC,CAC1C,MAAOoC,CAAC,EAAI,CAAC,CAAE,CACXC,gBAAgB,CAAGrC,OAAO,CAACoC,CAAC,CAAC,CAC7B,GAAIE,SAAS,CAAC/B,SAAS,CAAG8B,gBAAgB,CAAC9B,SAAS,CAChD7B,qBAAqB,CAACyD,SAAS,CAAC,CAAE,CAClC,MACJ,CACAC,CAAC,EAAE,CACP,CACA,GAAI,CAACC,gBAAgB,CAAE,CACnB,MAAO,CAAEjC,CAAC,CAAE,CAAC,CAAEC,CAAC,CAAE,CAAE,CAAC,CACzB,CACA,KAAM,CAAAkC,IAAI,CAAG5D,qBAAqB,CAAC2D,SAAS,CAAC/B,SAAS,CAAG8B,gBAAgB,CAAC9B,SAAS,CAAC,CACpF,GAAIgC,IAAI,GAAK,CAAC,CAAE,CACZ,MAAO,CAAEnC,CAAC,CAAE,CAAC,CAAEC,CAAC,CAAE,CAAE,CAAC,CACzB,CACA,KAAM,CAAAmC,eAAe,CAAG,CACpBpC,CAAC,CAAE,CAACkC,SAAS,CAAClC,CAAC,CAAGiC,gBAAgB,CAACjC,CAAC,EAAImC,IAAI,CAC5ClC,CAAC,CAAE,CAACiC,SAAS,CAACjC,CAAC,CAAGgC,gBAAgB,CAAChC,CAAC,EAAIkC,IAC5C,CAAC,CACD,GAAIC,eAAe,CAACpC,CAAC,GAAKqC,QAAQ,CAAE,CAChCD,eAAe,CAACpC,CAAC,CAAG,CAAC,CACzB,CACA,GAAIoC,eAAe,CAACnC,CAAC,GAAKoC,QAAQ,CAAE,CAChCD,eAAe,CAACnC,CAAC,CAAG,CAAC,CACzB,CACA,MAAO,CAAAmC,eAAe,CAC1B,CAEA,OAASzD,UAAU","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}