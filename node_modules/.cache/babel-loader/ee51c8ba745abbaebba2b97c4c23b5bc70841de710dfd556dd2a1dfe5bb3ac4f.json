{"ast":null,"code":"import{invariant,clamp,MotionGlobalConfig,noop,pipe,progress}from'motion-utils';import{mix}from'./mix/index.mjs';function createMixers(output,ease,customMixer){const mixers=[];const mixerFactory=customMixer||MotionGlobalConfig.mix||mix;const numMixers=output.length-1;for(let i=0;i<numMixers;i++){let mixer=mixerFactory(output[i],output[i+1]);if(ease){const easingFunction=Array.isArray(ease)?ease[i]||noop:ease;mixer=pipe(easingFunction,mixer);}mixers.push(mixer);}return mixers;}/**\n * Create a function that maps from a numerical input array to a generic output array.\n *\n * Accepts:\n *   - Numbers\n *   - Colors (hex, hsl, hsla, rgb, rgba)\n *   - Complex (combinations of one or more numbers or strings)\n *\n * ```jsx\n * const mixColor = interpolate([0, 1], ['#fff', '#000'])\n *\n * mixColor(0.5) // 'rgba(128, 128, 128, 1)'\n * ```\n *\n * TODO Revisit this approach once we've moved to data models for values,\n * probably not needed to pregenerate mixer functions.\n *\n * @public\n */function interpolate(input,output){let{clamp:isClamp=true,ease,mixer}=arguments.length>2&&arguments[2]!==undefined?arguments[2]:{};const inputLength=input.length;invariant(inputLength===output.length,\"Both input and output ranges must be the same length\");/**\n     * If we're only provided a single input, we can just make a function\n     * that returns the output.\n     */if(inputLength===1)return()=>output[0];if(inputLength===2&&output[0]===output[1])return()=>output[1];const isZeroDeltaRange=input[0]===input[1];// If input runs highest -> lowest, reverse both arrays\nif(input[0]>input[inputLength-1]){input=[...input].reverse();output=[...output].reverse();}const mixers=createMixers(output,ease,mixer);const numMixers=mixers.length;const interpolator=v=>{if(isZeroDeltaRange&&v<input[0])return output[0];let i=0;if(numMixers>1){for(;i<input.length-2;i++){if(v<input[i+1])break;}}const progressInRange=progress(input[i],input[i+1],v);return mixers[i](progressInRange);};return isClamp?v=>interpolator(clamp(input[0],input[inputLength-1],v)):interpolator;}export{interpolate};","map":{"version":3,"names":["invariant","clamp","MotionGlobalConfig","noop","pipe","progress","mix","createMixers","output","ease","customMixer","mixers","mixerFactory","numMixers","length","i","mixer","easingFunction","Array","isArray","push","interpolate","input","isClamp","arguments","undefined","inputLength","isZeroDeltaRange","reverse","interpolator","v","progressInRange"],"sources":["/home/antisyn/portfolio/src/components/node_modules/motion-dom/dist/es/utils/interpolate.mjs"],"sourcesContent":["import { invariant, clamp, MotionGlobalConfig, noop, pipe, progress } from 'motion-utils';\nimport { mix } from './mix/index.mjs';\n\nfunction createMixers(output, ease, customMixer) {\n    const mixers = [];\n    const mixerFactory = customMixer || MotionGlobalConfig.mix || mix;\n    const numMixers = output.length - 1;\n    for (let i = 0; i < numMixers; i++) {\n        let mixer = mixerFactory(output[i], output[i + 1]);\n        if (ease) {\n            const easingFunction = Array.isArray(ease) ? ease[i] || noop : ease;\n            mixer = pipe(easingFunction, mixer);\n        }\n        mixers.push(mixer);\n    }\n    return mixers;\n}\n/**\n * Create a function that maps from a numerical input array to a generic output array.\n *\n * Accepts:\n *   - Numbers\n *   - Colors (hex, hsl, hsla, rgb, rgba)\n *   - Complex (combinations of one or more numbers or strings)\n *\n * ```jsx\n * const mixColor = interpolate([0, 1], ['#fff', '#000'])\n *\n * mixColor(0.5) // 'rgba(128, 128, 128, 1)'\n * ```\n *\n * TODO Revisit this approach once we've moved to data models for values,\n * probably not needed to pregenerate mixer functions.\n *\n * @public\n */\nfunction interpolate(input, output, { clamp: isClamp = true, ease, mixer } = {}) {\n    const inputLength = input.length;\n    invariant(inputLength === output.length, \"Both input and output ranges must be the same length\");\n    /**\n     * If we're only provided a single input, we can just make a function\n     * that returns the output.\n     */\n    if (inputLength === 1)\n        return () => output[0];\n    if (inputLength === 2 && output[0] === output[1])\n        return () => output[1];\n    const isZeroDeltaRange = input[0] === input[1];\n    // If input runs highest -> lowest, reverse both arrays\n    if (input[0] > input[inputLength - 1]) {\n        input = [...input].reverse();\n        output = [...output].reverse();\n    }\n    const mixers = createMixers(output, ease, mixer);\n    const numMixers = mixers.length;\n    const interpolator = (v) => {\n        if (isZeroDeltaRange && v < input[0])\n            return output[0];\n        let i = 0;\n        if (numMixers > 1) {\n            for (; i < input.length - 2; i++) {\n                if (v < input[i + 1])\n                    break;\n            }\n        }\n        const progressInRange = progress(input[i], input[i + 1], v);\n        return mixers[i](progressInRange);\n    };\n    return isClamp\n        ? (v) => interpolator(clamp(input[0], input[inputLength - 1], v))\n        : interpolator;\n}\n\nexport { interpolate };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}