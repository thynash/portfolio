{"ast":null,"code":"import _objectSpread from\"/home/antisyn/portfolio/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";import{millisecondsToSeconds,secondsToMilliseconds,clamp}from'motion-utils';import{generateLinearEasing}from'../../waapi/utils/linear.mjs';import{calcGeneratorDuration,maxGeneratorDuration}from'../utils/calc-duration.mjs';import{createGeneratorEasing}from'../utils/create-generator-easing.mjs';import{calcGeneratorVelocity}from'../utils/velocity.mjs';import{springDefaults}from'./defaults.mjs';import{findSpring,calcAngularFreq}from'./find.mjs';const durationKeys=[\"duration\",\"bounce\"];const physicsKeys=[\"stiffness\",\"damping\",\"mass\"];function isSpringType(options,keys){return keys.some(key=>options[key]!==undefined);}function getSpringOptions(options){let springOptions=_objectSpread({velocity:springDefaults.velocity,stiffness:springDefaults.stiffness,damping:springDefaults.damping,mass:springDefaults.mass,isResolvedFromDuration:false},options);// stiffness/damping/mass overrides duration/bounce\nif(!isSpringType(options,physicsKeys)&&isSpringType(options,durationKeys)){if(options.visualDuration){const visualDuration=options.visualDuration;const root=2*Math.PI/(visualDuration*1.2);const stiffness=root*root;const damping=2*clamp(0.05,1,1-(options.bounce||0))*Math.sqrt(stiffness);springOptions=_objectSpread(_objectSpread({},springOptions),{},{mass:springDefaults.mass,stiffness,damping});}else{const derived=findSpring(options);springOptions=_objectSpread(_objectSpread(_objectSpread({},springOptions),derived),{},{mass:springDefaults.mass});springOptions.isResolvedFromDuration=true;}}return springOptions;}function spring(){let optionsOrVisualDuration=arguments.length>0&&arguments[0]!==undefined?arguments[0]:springDefaults.visualDuration;let bounce=arguments.length>1&&arguments[1]!==undefined?arguments[1]:springDefaults.bounce;const options=typeof optionsOrVisualDuration!==\"object\"?{visualDuration:optionsOrVisualDuration,keyframes:[0,1],bounce}:optionsOrVisualDuration;let{restSpeed,restDelta}=options;const origin=options.keyframes[0];const target=options.keyframes[options.keyframes.length-1];/**\n     * This is the Iterator-spec return value. We ensure it's mutable rather than using a generator\n     * to reduce GC during animation.\n     */const state={done:false,value:origin};const{stiffness,damping,mass,duration,velocity,isResolvedFromDuration}=getSpringOptions(_objectSpread(_objectSpread({},options),{},{velocity:-millisecondsToSeconds(options.velocity||0)}));const initialVelocity=velocity||0.0;const dampingRatio=damping/(2*Math.sqrt(stiffness*mass));const initialDelta=target-origin;const undampedAngularFreq=millisecondsToSeconds(Math.sqrt(stiffness/mass));/**\n     * If we're working on a granular scale, use smaller defaults for determining\n     * when the spring is finished.\n     *\n     * These defaults have been selected emprically based on what strikes a good\n     * ratio between feeling good and finishing as soon as changes are imperceptible.\n     */const isGranularScale=Math.abs(initialDelta)<5;restSpeed||(restSpeed=isGranularScale?springDefaults.restSpeed.granular:springDefaults.restSpeed.default);restDelta||(restDelta=isGranularScale?springDefaults.restDelta.granular:springDefaults.restDelta.default);let resolveSpring;if(dampingRatio<1){const angularFreq=calcAngularFreq(undampedAngularFreq,dampingRatio);// Underdamped spring\nresolveSpring=t=>{const envelope=Math.exp(-dampingRatio*undampedAngularFreq*t);return target-envelope*((initialVelocity+dampingRatio*undampedAngularFreq*initialDelta)/angularFreq*Math.sin(angularFreq*t)+initialDelta*Math.cos(angularFreq*t));};}else if(dampingRatio===1){// Critically damped spring\nresolveSpring=t=>target-Math.exp(-undampedAngularFreq*t)*(initialDelta+(initialVelocity+undampedAngularFreq*initialDelta)*t);}else{// Overdamped spring\nconst dampedAngularFreq=undampedAngularFreq*Math.sqrt(dampingRatio*dampingRatio-1);resolveSpring=t=>{const envelope=Math.exp(-dampingRatio*undampedAngularFreq*t);// When performing sinh or cosh values can hit Infinity so we cap them here\nconst freqForT=Math.min(dampedAngularFreq*t,300);return target-envelope*((initialVelocity+dampingRatio*undampedAngularFreq*initialDelta)*Math.sinh(freqForT)+dampedAngularFreq*initialDelta*Math.cosh(freqForT))/dampedAngularFreq;};}const generator={calculatedDuration:isResolvedFromDuration?duration||null:null,next:t=>{const current=resolveSpring(t);if(!isResolvedFromDuration){let currentVelocity=t===0?initialVelocity:0.0;/**\n                 * We only need to calculate velocity for under-damped springs\n                 * as over- and critically-damped springs can't overshoot, so\n                 * checking only for displacement is enough.\n                 */if(dampingRatio<1){currentVelocity=t===0?secondsToMilliseconds(initialVelocity):calcGeneratorVelocity(resolveSpring,t,current);}const isBelowVelocityThreshold=Math.abs(currentVelocity)<=restSpeed;const isBelowDisplacementThreshold=Math.abs(target-current)<=restDelta;state.done=isBelowVelocityThreshold&&isBelowDisplacementThreshold;}else{state.done=t>=duration;}state.value=state.done?target:current;return state;},toString:()=>{const calculatedDuration=Math.min(calcGeneratorDuration(generator),maxGeneratorDuration);const easing=generateLinearEasing(progress=>generator.next(calculatedDuration*progress).value,calculatedDuration,30);return calculatedDuration+\"ms \"+easing;},toTransition:()=>{}};return generator;}spring.applyToOptions=options=>{const generatorOptions=createGeneratorEasing(options,100,spring);options.ease=generatorOptions.ease;options.duration=secondsToMilliseconds(generatorOptions.duration);options.type=\"keyframes\";return options;};export{spring};","map":{"version":3,"names":["millisecondsToSeconds","secondsToMilliseconds","clamp","generateLinearEasing","calcGeneratorDuration","maxGeneratorDuration","createGeneratorEasing","calcGeneratorVelocity","springDefaults","findSpring","calcAngularFreq","durationKeys","physicsKeys","isSpringType","options","keys","some","key","undefined","getSpringOptions","springOptions","_objectSpread","velocity","stiffness","damping","mass","isResolvedFromDuration","visualDuration","root","Math","PI","bounce","sqrt","derived","spring","optionsOrVisualDuration","arguments","length","keyframes","restSpeed","restDelta","origin","target","state","done","value","duration","initialVelocity","dampingRatio","initialDelta","undampedAngularFreq","isGranularScale","abs","granular","default","resolveSpring","angularFreq","t","envelope","exp","sin","cos","dampedAngularFreq","freqForT","min","sinh","cosh","generator","calculatedDuration","next","current","currentVelocity","isBelowVelocityThreshold","isBelowDisplacementThreshold","toString","easing","progress","toTransition","applyToOptions","generatorOptions","ease","type"],"sources":["/home/antisyn/portfolio/src/components/node_modules/motion-dom/dist/es/animation/generators/spring/index.mjs"],"sourcesContent":["import { millisecondsToSeconds, secondsToMilliseconds, clamp } from 'motion-utils';\nimport { generateLinearEasing } from '../../waapi/utils/linear.mjs';\nimport { calcGeneratorDuration, maxGeneratorDuration } from '../utils/calc-duration.mjs';\nimport { createGeneratorEasing } from '../utils/create-generator-easing.mjs';\nimport { calcGeneratorVelocity } from '../utils/velocity.mjs';\nimport { springDefaults } from './defaults.mjs';\nimport { findSpring, calcAngularFreq } from './find.mjs';\n\nconst durationKeys = [\"duration\", \"bounce\"];\nconst physicsKeys = [\"stiffness\", \"damping\", \"mass\"];\nfunction isSpringType(options, keys) {\n    return keys.some((key) => options[key] !== undefined);\n}\nfunction getSpringOptions(options) {\n    let springOptions = {\n        velocity: springDefaults.velocity,\n        stiffness: springDefaults.stiffness,\n        damping: springDefaults.damping,\n        mass: springDefaults.mass,\n        isResolvedFromDuration: false,\n        ...options,\n    };\n    // stiffness/damping/mass overrides duration/bounce\n    if (!isSpringType(options, physicsKeys) &&\n        isSpringType(options, durationKeys)) {\n        if (options.visualDuration) {\n            const visualDuration = options.visualDuration;\n            const root = (2 * Math.PI) / (visualDuration * 1.2);\n            const stiffness = root * root;\n            const damping = 2 *\n                clamp(0.05, 1, 1 - (options.bounce || 0)) *\n                Math.sqrt(stiffness);\n            springOptions = {\n                ...springOptions,\n                mass: springDefaults.mass,\n                stiffness,\n                damping,\n            };\n        }\n        else {\n            const derived = findSpring(options);\n            springOptions = {\n                ...springOptions,\n                ...derived,\n                mass: springDefaults.mass,\n            };\n            springOptions.isResolvedFromDuration = true;\n        }\n    }\n    return springOptions;\n}\nfunction spring(optionsOrVisualDuration = springDefaults.visualDuration, bounce = springDefaults.bounce) {\n    const options = typeof optionsOrVisualDuration !== \"object\"\n        ? {\n            visualDuration: optionsOrVisualDuration,\n            keyframes: [0, 1],\n            bounce,\n        }\n        : optionsOrVisualDuration;\n    let { restSpeed, restDelta } = options;\n    const origin = options.keyframes[0];\n    const target = options.keyframes[options.keyframes.length - 1];\n    /**\n     * This is the Iterator-spec return value. We ensure it's mutable rather than using a generator\n     * to reduce GC during animation.\n     */\n    const state = { done: false, value: origin };\n    const { stiffness, damping, mass, duration, velocity, isResolvedFromDuration, } = getSpringOptions({\n        ...options,\n        velocity: -millisecondsToSeconds(options.velocity || 0),\n    });\n    const initialVelocity = velocity || 0.0;\n    const dampingRatio = damping / (2 * Math.sqrt(stiffness * mass));\n    const initialDelta = target - origin;\n    const undampedAngularFreq = millisecondsToSeconds(Math.sqrt(stiffness / mass));\n    /**\n     * If we're working on a granular scale, use smaller defaults for determining\n     * when the spring is finished.\n     *\n     * These defaults have been selected emprically based on what strikes a good\n     * ratio between feeling good and finishing as soon as changes are imperceptible.\n     */\n    const isGranularScale = Math.abs(initialDelta) < 5;\n    restSpeed || (restSpeed = isGranularScale\n        ? springDefaults.restSpeed.granular\n        : springDefaults.restSpeed.default);\n    restDelta || (restDelta = isGranularScale\n        ? springDefaults.restDelta.granular\n        : springDefaults.restDelta.default);\n    let resolveSpring;\n    if (dampingRatio < 1) {\n        const angularFreq = calcAngularFreq(undampedAngularFreq, dampingRatio);\n        // Underdamped spring\n        resolveSpring = (t) => {\n            const envelope = Math.exp(-dampingRatio * undampedAngularFreq * t);\n            return (target -\n                envelope *\n                    (((initialVelocity +\n                        dampingRatio * undampedAngularFreq * initialDelta) /\n                        angularFreq) *\n                        Math.sin(angularFreq * t) +\n                        initialDelta * Math.cos(angularFreq * t)));\n        };\n    }\n    else if (dampingRatio === 1) {\n        // Critically damped spring\n        resolveSpring = (t) => target -\n            Math.exp(-undampedAngularFreq * t) *\n                (initialDelta +\n                    (initialVelocity + undampedAngularFreq * initialDelta) * t);\n    }\n    else {\n        // Overdamped spring\n        const dampedAngularFreq = undampedAngularFreq * Math.sqrt(dampingRatio * dampingRatio - 1);\n        resolveSpring = (t) => {\n            const envelope = Math.exp(-dampingRatio * undampedAngularFreq * t);\n            // When performing sinh or cosh values can hit Infinity so we cap them here\n            const freqForT = Math.min(dampedAngularFreq * t, 300);\n            return (target -\n                (envelope *\n                    ((initialVelocity +\n                        dampingRatio * undampedAngularFreq * initialDelta) *\n                        Math.sinh(freqForT) +\n                        dampedAngularFreq *\n                            initialDelta *\n                            Math.cosh(freqForT))) /\n                    dampedAngularFreq);\n        };\n    }\n    const generator = {\n        calculatedDuration: isResolvedFromDuration ? duration || null : null,\n        next: (t) => {\n            const current = resolveSpring(t);\n            if (!isResolvedFromDuration) {\n                let currentVelocity = t === 0 ? initialVelocity : 0.0;\n                /**\n                 * We only need to calculate velocity for under-damped springs\n                 * as over- and critically-damped springs can't overshoot, so\n                 * checking only for displacement is enough.\n                 */\n                if (dampingRatio < 1) {\n                    currentVelocity =\n                        t === 0\n                            ? secondsToMilliseconds(initialVelocity)\n                            : calcGeneratorVelocity(resolveSpring, t, current);\n                }\n                const isBelowVelocityThreshold = Math.abs(currentVelocity) <= restSpeed;\n                const isBelowDisplacementThreshold = Math.abs(target - current) <= restDelta;\n                state.done =\n                    isBelowVelocityThreshold && isBelowDisplacementThreshold;\n            }\n            else {\n                state.done = t >= duration;\n            }\n            state.value = state.done ? target : current;\n            return state;\n        },\n        toString: () => {\n            const calculatedDuration = Math.min(calcGeneratorDuration(generator), maxGeneratorDuration);\n            const easing = generateLinearEasing((progress) => generator.next(calculatedDuration * progress).value, calculatedDuration, 30);\n            return calculatedDuration + \"ms \" + easing;\n        },\n        toTransition: () => { },\n    };\n    return generator;\n}\nspring.applyToOptions = (options) => {\n    const generatorOptions = createGeneratorEasing(options, 100, spring);\n    options.ease = generatorOptions.ease;\n    options.duration = secondsToMilliseconds(generatorOptions.duration);\n    options.type = \"keyframes\";\n    return options;\n};\n\nexport { spring };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}