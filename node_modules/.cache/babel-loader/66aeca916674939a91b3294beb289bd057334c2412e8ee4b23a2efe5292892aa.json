{"ast":null,"code":"import _objectSpread from\"/home/antisyn/portfolio/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";import{resolveElements,getValueTransition,getAnimationMap,animationMapKey,getComputedStyle,fillWildcards,applyPxDefaults,NativeAnimation}from'motion-dom';import{invariant,secondsToMilliseconds}from'motion-utils';function animateElements(elementOrSelector,keyframes,options,scope){const elements=resolveElements(elementOrSelector,scope);const numElements=elements.length;invariant(Boolean(numElements),\"No valid element provided.\");/**\n     * WAAPI doesn't support interrupting animations.\n     *\n     * Therefore, starting animations requires a three-step process:\n     * 1. Stop existing animations (write styles to DOM)\n     * 2. Resolve keyframes (read styles from DOM)\n     * 3. Create new animations (write styles to DOM)\n     *\n     * The hybrid `animate()` function uses AsyncAnimation to resolve\n     * keyframes before creating new animations, which removes style\n     * thrashing. Here, we have much stricter filesize constraints.\n     * Therefore we do this in a synchronous way that ensures that\n     * at least within `animate()` calls there is no style thrashing.\n     *\n     * In the motion-native-animate-mini-interrupt benchmark this\n     * was 80% faster than a single loop.\n     */const animationDefinitions=[];/**\n     * Step 1: Build options and stop existing animations (write)\n     */for(let i=0;i<numElements;i++){const element=elements[i];const elementTransition=_objectSpread({},options);/**\n         * Resolve stagger function if provided.\n         */if(typeof elementTransition.delay===\"function\"){elementTransition.delay=elementTransition.delay(i,numElements);}for(const valueName in keyframes){let valueKeyframes=keyframes[valueName];if(!Array.isArray(valueKeyframes)){valueKeyframes=[valueKeyframes];}const valueOptions=_objectSpread({},getValueTransition(elementTransition,valueName));valueOptions.duration&&(valueOptions.duration=secondsToMilliseconds(valueOptions.duration));valueOptions.delay&&(valueOptions.delay=secondsToMilliseconds(valueOptions.delay));/**\n             * If there's an existing animation playing on this element then stop it\n             * before creating a new one.\n             */const map=getAnimationMap(element);const key=animationMapKey(valueName,valueOptions.pseudoElement||\"\");const currentAnimation=map.get(key);currentAnimation&&currentAnimation.stop();animationDefinitions.push({map,key,unresolvedKeyframes:valueKeyframes,options:_objectSpread(_objectSpread({},valueOptions),{},{element,name:valueName,allowFlatten:!elementTransition.type&&!elementTransition.ease})});}}/**\n     * Step 2: Resolve keyframes (read)\n     */for(let i=0;i<animationDefinitions.length;i++){const{unresolvedKeyframes,options:animationOptions}=animationDefinitions[i];const{element,name,pseudoElement}=animationOptions;if(!pseudoElement&&unresolvedKeyframes[0]===null){unresolvedKeyframes[0]=getComputedStyle(element,name);}fillWildcards(unresolvedKeyframes);applyPxDefaults(unresolvedKeyframes,name);/**\n         * If we only have one keyframe, explicitly read the initial keyframe\n         * from the computed style. This is to ensure consistency with WAAPI behaviour\n         * for restarting animations, for instance .play() after finish, when it\n         * has one vs two keyframes.\n         */if(!pseudoElement&&unresolvedKeyframes.length<2){unresolvedKeyframes.unshift(getComputedStyle(element,name));}animationOptions.keyframes=unresolvedKeyframes;}/**\n     * Step 3: Create new animations (write)\n     */const animations=[];for(let i=0;i<animationDefinitions.length;i++){const{map,key,options:animationOptions}=animationDefinitions[i];const animation=new NativeAnimation(animationOptions);map.set(key,animation);animation.finished.finally(()=>map.delete(key));animations.push(animation);}return animations;}export{animateElements};","map":{"version":3,"names":["resolveElements","getValueTransition","getAnimationMap","animationMapKey","getComputedStyle","fillWildcards","applyPxDefaults","NativeAnimation","invariant","secondsToMilliseconds","animateElements","elementOrSelector","keyframes","options","scope","elements","numElements","length","Boolean","animationDefinitions","i","element","elementTransition","_objectSpread","delay","valueName","valueKeyframes","Array","isArray","valueOptions","duration","map","key","pseudoElement","currentAnimation","get","stop","push","unresolvedKeyframes","name","allowFlatten","type","ease","animationOptions","unshift","animations","animation","set","finished","finally","delete"],"sources":["/home/antisyn/portfolio/src/components/node_modules/framer-motion/dist/es/animation/animators/waapi/animate-elements.mjs"],"sourcesContent":["import { resolveElements, getValueTransition, getAnimationMap, animationMapKey, getComputedStyle, fillWildcards, applyPxDefaults, NativeAnimation } from 'motion-dom';\nimport { invariant, secondsToMilliseconds } from 'motion-utils';\n\nfunction animateElements(elementOrSelector, keyframes, options, scope) {\n    const elements = resolveElements(elementOrSelector, scope);\n    const numElements = elements.length;\n    invariant(Boolean(numElements), \"No valid element provided.\");\n    /**\n     * WAAPI doesn't support interrupting animations.\n     *\n     * Therefore, starting animations requires a three-step process:\n     * 1. Stop existing animations (write styles to DOM)\n     * 2. Resolve keyframes (read styles from DOM)\n     * 3. Create new animations (write styles to DOM)\n     *\n     * The hybrid `animate()` function uses AsyncAnimation to resolve\n     * keyframes before creating new animations, which removes style\n     * thrashing. Here, we have much stricter filesize constraints.\n     * Therefore we do this in a synchronous way that ensures that\n     * at least within `animate()` calls there is no style thrashing.\n     *\n     * In the motion-native-animate-mini-interrupt benchmark this\n     * was 80% faster than a single loop.\n     */\n    const animationDefinitions = [];\n    /**\n     * Step 1: Build options and stop existing animations (write)\n     */\n    for (let i = 0; i < numElements; i++) {\n        const element = elements[i];\n        const elementTransition = { ...options };\n        /**\n         * Resolve stagger function if provided.\n         */\n        if (typeof elementTransition.delay === \"function\") {\n            elementTransition.delay = elementTransition.delay(i, numElements);\n        }\n        for (const valueName in keyframes) {\n            let valueKeyframes = keyframes[valueName];\n            if (!Array.isArray(valueKeyframes)) {\n                valueKeyframes = [valueKeyframes];\n            }\n            const valueOptions = {\n                ...getValueTransition(elementTransition, valueName),\n            };\n            valueOptions.duration && (valueOptions.duration = secondsToMilliseconds(valueOptions.duration));\n            valueOptions.delay && (valueOptions.delay = secondsToMilliseconds(valueOptions.delay));\n            /**\n             * If there's an existing animation playing on this element then stop it\n             * before creating a new one.\n             */\n            const map = getAnimationMap(element);\n            const key = animationMapKey(valueName, valueOptions.pseudoElement || \"\");\n            const currentAnimation = map.get(key);\n            currentAnimation && currentAnimation.stop();\n            animationDefinitions.push({\n                map,\n                key,\n                unresolvedKeyframes: valueKeyframes,\n                options: {\n                    ...valueOptions,\n                    element,\n                    name: valueName,\n                    allowFlatten: !elementTransition.type && !elementTransition.ease,\n                },\n            });\n        }\n    }\n    /**\n     * Step 2: Resolve keyframes (read)\n     */\n    for (let i = 0; i < animationDefinitions.length; i++) {\n        const { unresolvedKeyframes, options: animationOptions } = animationDefinitions[i];\n        const { element, name, pseudoElement } = animationOptions;\n        if (!pseudoElement && unresolvedKeyframes[0] === null) {\n            unresolvedKeyframes[0] = getComputedStyle(element, name);\n        }\n        fillWildcards(unresolvedKeyframes);\n        applyPxDefaults(unresolvedKeyframes, name);\n        /**\n         * If we only have one keyframe, explicitly read the initial keyframe\n         * from the computed style. This is to ensure consistency with WAAPI behaviour\n         * for restarting animations, for instance .play() after finish, when it\n         * has one vs two keyframes.\n         */\n        if (!pseudoElement && unresolvedKeyframes.length < 2) {\n            unresolvedKeyframes.unshift(getComputedStyle(element, name));\n        }\n        animationOptions.keyframes = unresolvedKeyframes;\n    }\n    /**\n     * Step 3: Create new animations (write)\n     */\n    const animations = [];\n    for (let i = 0; i < animationDefinitions.length; i++) {\n        const { map, key, options: animationOptions } = animationDefinitions[i];\n        const animation = new NativeAnimation(animationOptions);\n        map.set(key, animation);\n        animation.finished.finally(() => map.delete(key));\n        animations.push(animation);\n    }\n    return animations;\n}\n\nexport { animateElements };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}