{"ast":null,"code":"import _objectSpread from\"/home/antisyn/portfolio/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";import _objectWithoutProperties from\"/home/antisyn/portfolio/node_modules/@babel/runtime/helpers/esm/objectWithoutProperties.js\";const _excluded=[\"root\"];/**\n * Map an IntersectionHandler callback to an element. We only ever make one handler for one\n * element, so even though these handlers might all be triggered by different\n * observers, we can keep them in the same map.\n */const observerCallbacks=new WeakMap();/**\n * Multiple observers can be created for multiple element/document roots. Each with\n * different settings. So here we store dictionaries of observers to each root,\n * using serialised settings (threshold/margin) as lookup keys.\n */const observers=new WeakMap();const fireObserverCallback=entry=>{const callback=observerCallbacks.get(entry.target);callback&&callback(entry);};const fireAllObserverCallbacks=entries=>{entries.forEach(fireObserverCallback);};function initIntersectionObserver(_ref){let{root}=_ref,options=_objectWithoutProperties(_ref,_excluded);const lookupRoot=root||document;/**\n     * If we don't have an observer lookup map for this root, create one.\n     */if(!observers.has(lookupRoot)){observers.set(lookupRoot,{});}const rootObservers=observers.get(lookupRoot);const key=JSON.stringify(options);/**\n     * If we don't have an observer for this combination of root and settings,\n     * create one.\n     */if(!rootObservers[key]){rootObservers[key]=new IntersectionObserver(fireAllObserverCallbacks,_objectSpread({root},options));}return rootObservers[key];}function observeIntersection(element,options,callback){const rootInteresectionObserver=initIntersectionObserver(options);observerCallbacks.set(element,callback);rootInteresectionObserver.observe(element);return()=>{observerCallbacks.delete(element);rootInteresectionObserver.unobserve(element);};}export{observeIntersection};","map":{"version":3,"names":["observerCallbacks","WeakMap","observers","fireObserverCallback","entry","callback","get","target","fireAllObserverCallbacks","entries","forEach","initIntersectionObserver","_ref","root","options","_objectWithoutProperties","_excluded","lookupRoot","document","has","set","rootObservers","key","JSON","stringify","IntersectionObserver","_objectSpread","observeIntersection","element","rootInteresectionObserver","observe","delete","unobserve"],"sources":["/home/antisyn/portfolio/src/components/node_modules/framer-motion/dist/es/motion/features/viewport/observers.mjs"],"sourcesContent":["/**\n * Map an IntersectionHandler callback to an element. We only ever make one handler for one\n * element, so even though these handlers might all be triggered by different\n * observers, we can keep them in the same map.\n */\nconst observerCallbacks = new WeakMap();\n/**\n * Multiple observers can be created for multiple element/document roots. Each with\n * different settings. So here we store dictionaries of observers to each root,\n * using serialised settings (threshold/margin) as lookup keys.\n */\nconst observers = new WeakMap();\nconst fireObserverCallback = (entry) => {\n    const callback = observerCallbacks.get(entry.target);\n    callback && callback(entry);\n};\nconst fireAllObserverCallbacks = (entries) => {\n    entries.forEach(fireObserverCallback);\n};\nfunction initIntersectionObserver({ root, ...options }) {\n    const lookupRoot = root || document;\n    /**\n     * If we don't have an observer lookup map for this root, create one.\n     */\n    if (!observers.has(lookupRoot)) {\n        observers.set(lookupRoot, {});\n    }\n    const rootObservers = observers.get(lookupRoot);\n    const key = JSON.stringify(options);\n    /**\n     * If we don't have an observer for this combination of root and settings,\n     * create one.\n     */\n    if (!rootObservers[key]) {\n        rootObservers[key] = new IntersectionObserver(fireAllObserverCallbacks, { root, ...options });\n    }\n    return rootObservers[key];\n}\nfunction observeIntersection(element, options, callback) {\n    const rootInteresectionObserver = initIntersectionObserver(options);\n    observerCallbacks.set(element, callback);\n    rootInteresectionObserver.observe(element);\n    return () => {\n        observerCallbacks.delete(element);\n        rootInteresectionObserver.unobserve(element);\n    };\n}\n\nexport { observeIntersection };\n"],"mappings":"sQAAA;AACA;AACA;AACA;AACA,GACA,KAAM,CAAAA,iBAAiB,CAAG,GAAI,CAAAC,OAAO,CAAC,CAAC,CACvC;AACA;AACA;AACA;AACA,GACA,KAAM,CAAAC,SAAS,CAAG,GAAI,CAAAD,OAAO,CAAC,CAAC,CAC/B,KAAM,CAAAE,oBAAoB,CAAIC,KAAK,EAAK,CACpC,KAAM,CAAAC,QAAQ,CAAGL,iBAAiB,CAACM,GAAG,CAACF,KAAK,CAACG,MAAM,CAAC,CACpDF,QAAQ,EAAIA,QAAQ,CAACD,KAAK,CAAC,CAC/B,CAAC,CACD,KAAM,CAAAI,wBAAwB,CAAIC,OAAO,EAAK,CAC1CA,OAAO,CAACC,OAAO,CAACP,oBAAoB,CAAC,CACzC,CAAC,CACD,QAAS,CAAAQ,wBAAwBA,CAAAC,IAAA,CAAuB,IAAtB,CAAEC,IAAiB,CAAC,CAAAD,IAAA,CAATE,OAAO,CAAAC,wBAAA,CAAAH,IAAA,CAAAI,SAAA,EAChD,KAAM,CAAAC,UAAU,CAAGJ,IAAI,EAAIK,QAAQ,CACnC;AACJ;AACA,OACI,GAAI,CAAChB,SAAS,CAACiB,GAAG,CAACF,UAAU,CAAC,CAAE,CAC5Bf,SAAS,CAACkB,GAAG,CAACH,UAAU,CAAE,CAAC,CAAC,CAAC,CACjC,CACA,KAAM,CAAAI,aAAa,CAAGnB,SAAS,CAACI,GAAG,CAACW,UAAU,CAAC,CAC/C,KAAM,CAAAK,GAAG,CAAGC,IAAI,CAACC,SAAS,CAACV,OAAO,CAAC,CACnC;AACJ;AACA;AACA,OACI,GAAI,CAACO,aAAa,CAACC,GAAG,CAAC,CAAE,CACrBD,aAAa,CAACC,GAAG,CAAC,CAAG,GAAI,CAAAG,oBAAoB,CAACjB,wBAAwB,CAAAkB,aAAA,EAAIb,IAAI,EAAKC,OAAO,CAAE,CAAC,CACjG,CACA,MAAO,CAAAO,aAAa,CAACC,GAAG,CAAC,CAC7B,CACA,QAAS,CAAAK,mBAAmBA,CAACC,OAAO,CAAEd,OAAO,CAAET,QAAQ,CAAE,CACrD,KAAM,CAAAwB,yBAAyB,CAAGlB,wBAAwB,CAACG,OAAO,CAAC,CACnEd,iBAAiB,CAACoB,GAAG,CAACQ,OAAO,CAAEvB,QAAQ,CAAC,CACxCwB,yBAAyB,CAACC,OAAO,CAACF,OAAO,CAAC,CAC1C,MAAO,IAAM,CACT5B,iBAAiB,CAAC+B,MAAM,CAACH,OAAO,CAAC,CACjCC,yBAAyB,CAACG,SAAS,CAACJ,OAAO,CAAC,CAChD,CAAC,CACL,CAEA,OAASD,mBAAmB","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}