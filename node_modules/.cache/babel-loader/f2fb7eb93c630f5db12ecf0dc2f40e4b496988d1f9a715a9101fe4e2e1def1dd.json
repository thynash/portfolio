{"ast":null,"code":"import{noop}from'../noop.mjs';/*\n  Bezier function generator\n  This has been modified from Gaëtan Renaudeau's BezierEasing\n  https://github.com/gre/bezier-easing/blob/master/src/index.js\n  https://github.com/gre/bezier-easing/blob/master/LICENSE\n  \n  I've removed the newtonRaphsonIterate algo because in benchmarking it\n  wasn't noticiably faster than binarySubdivision, indeed removing it\n  usually improved times, depending on the curve.\n  I also removed the lookup table, as for the added bundle size and loop we're\n  only cutting ~4 or so subdivision iterations. I bumped the max iterations up\n  to 12 to compensate and this still tended to be faster for no perceivable\n  loss in accuracy.\n  Usage\n    const easeOut = cubicBezier(.17,.67,.83,.67);\n    const x = easeOut(0.5); // returns 0.627...\n*/// Returns x(t) given t, x1, and x2, or y(t) given t, y1, and y2.\nconst calcBezier=(t,a1,a2)=>(((1.0-3.0*a2+3.0*a1)*t+(3.0*a2-6.0*a1))*t+3.0*a1)*t;const subdivisionPrecision=0.0000001;const subdivisionMaxIterations=12;function binarySubdivide(x,lowerBound,upperBound,mX1,mX2){let currentX;let currentT;let i=0;do{currentT=lowerBound+(upperBound-lowerBound)/2.0;currentX=calcBezier(currentT,mX1,mX2)-x;if(currentX>0.0){upperBound=currentT;}else{lowerBound=currentT;}}while(Math.abs(currentX)>subdivisionPrecision&&++i<subdivisionMaxIterations);return currentT;}function cubicBezier(mX1,mY1,mX2,mY2){// If this is a linear gradient, return linear easing\nif(mX1===mY1&&mX2===mY2)return noop;const getTForX=aX=>binarySubdivide(aX,0,1,mX1,mX2);// If animation is at start/end, return t without easing\nreturn t=>t===0||t===1?t:calcBezier(getTForX(t),mY1,mY2);}export{cubicBezier};","map":{"version":3,"names":["noop","calcBezier","t","a1","a2","subdivisionPrecision","subdivisionMaxIterations","binarySubdivide","x","lowerBound","upperBound","mX1","mX2","currentX","currentT","i","Math","abs","cubicBezier","mY1","mY2","getTForX","aX"],"sources":["/home/antisyn/portfolio/src/components/node_modules/motion-utils/dist/es/easing/cubic-bezier.mjs"],"sourcesContent":["import { noop } from '../noop.mjs';\n\n/*\n  Bezier function generator\n  This has been modified from Gaëtan Renaudeau's BezierEasing\n  https://github.com/gre/bezier-easing/blob/master/src/index.js\n  https://github.com/gre/bezier-easing/blob/master/LICENSE\n  \n  I've removed the newtonRaphsonIterate algo because in benchmarking it\n  wasn't noticiably faster than binarySubdivision, indeed removing it\n  usually improved times, depending on the curve.\n  I also removed the lookup table, as for the added bundle size and loop we're\n  only cutting ~4 or so subdivision iterations. I bumped the max iterations up\n  to 12 to compensate and this still tended to be faster for no perceivable\n  loss in accuracy.\n  Usage\n    const easeOut = cubicBezier(.17,.67,.83,.67);\n    const x = easeOut(0.5); // returns 0.627...\n*/\n// Returns x(t) given t, x1, and x2, or y(t) given t, y1, and y2.\nconst calcBezier = (t, a1, a2) => (((1.0 - 3.0 * a2 + 3.0 * a1) * t + (3.0 * a2 - 6.0 * a1)) * t + 3.0 * a1) *\n    t;\nconst subdivisionPrecision = 0.0000001;\nconst subdivisionMaxIterations = 12;\nfunction binarySubdivide(x, lowerBound, upperBound, mX1, mX2) {\n    let currentX;\n    let currentT;\n    let i = 0;\n    do {\n        currentT = lowerBound + (upperBound - lowerBound) / 2.0;\n        currentX = calcBezier(currentT, mX1, mX2) - x;\n        if (currentX > 0.0) {\n            upperBound = currentT;\n        }\n        else {\n            lowerBound = currentT;\n        }\n    } while (Math.abs(currentX) > subdivisionPrecision &&\n        ++i < subdivisionMaxIterations);\n    return currentT;\n}\nfunction cubicBezier(mX1, mY1, mX2, mY2) {\n    // If this is a linear gradient, return linear easing\n    if (mX1 === mY1 && mX2 === mY2)\n        return noop;\n    const getTForX = (aX) => binarySubdivide(aX, 0, 1, mX1, mX2);\n    // If animation is at start/end, return t without easing\n    return (t) => t === 0 || t === 1 ? t : calcBezier(getTForX(t), mY1, mY2);\n}\n\nexport { cubicBezier };\n"],"mappings":"AAAA,OAASA,IAAI,KAAQ,aAAa,CAElC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EACA;AACA,KAAM,CAAAC,UAAU,CAAGA,CAACC,CAAC,CAAEC,EAAE,CAAEC,EAAE,GAAK,CAAC,CAAC,CAAC,GAAG,CAAG,GAAG,CAAGA,EAAE,CAAG,GAAG,CAAGD,EAAE,EAAID,CAAC,EAAI,GAAG,CAAGE,EAAE,CAAG,GAAG,CAAGD,EAAE,CAAC,EAAID,CAAC,CAAG,GAAG,CAAGC,EAAE,EACvGD,CAAC,CACL,KAAM,CAAAG,oBAAoB,CAAG,SAAS,CACtC,KAAM,CAAAC,wBAAwB,CAAG,EAAE,CACnC,QAAS,CAAAC,eAAeA,CAACC,CAAC,CAAEC,UAAU,CAAEC,UAAU,CAAEC,GAAG,CAAEC,GAAG,CAAE,CAC1D,GAAI,CAAAC,QAAQ,CACZ,GAAI,CAAAC,QAAQ,CACZ,GAAI,CAAAC,CAAC,CAAG,CAAC,CACT,EAAG,CACCD,QAAQ,CAAGL,UAAU,CAAG,CAACC,UAAU,CAAGD,UAAU,EAAI,GAAG,CACvDI,QAAQ,CAAGZ,UAAU,CAACa,QAAQ,CAAEH,GAAG,CAAEC,GAAG,CAAC,CAAGJ,CAAC,CAC7C,GAAIK,QAAQ,CAAG,GAAG,CAAE,CAChBH,UAAU,CAAGI,QAAQ,CACzB,CAAC,IACI,CACDL,UAAU,CAAGK,QAAQ,CACzB,CACJ,CAAC,MAAQE,IAAI,CAACC,GAAG,CAACJ,QAAQ,CAAC,CAAGR,oBAAoB,EAC9C,EAAEU,CAAC,CAAGT,wBAAwB,EAClC,MAAO,CAAAQ,QAAQ,CACnB,CACA,QAAS,CAAAI,WAAWA,CAACP,GAAG,CAAEQ,GAAG,CAAEP,GAAG,CAAEQ,GAAG,CAAE,CACrC;AACA,GAAIT,GAAG,GAAKQ,GAAG,EAAIP,GAAG,GAAKQ,GAAG,CAC1B,MAAO,CAAApB,IAAI,CACf,KAAM,CAAAqB,QAAQ,CAAIC,EAAE,EAAKf,eAAe,CAACe,EAAE,CAAE,CAAC,CAAE,CAAC,CAAEX,GAAG,CAAEC,GAAG,CAAC,CAC5D;AACA,MAAQ,CAAAV,CAAC,EAAKA,CAAC,GAAK,CAAC,EAAIA,CAAC,GAAK,CAAC,CAAGA,CAAC,CAAGD,UAAU,CAACoB,QAAQ,CAACnB,CAAC,CAAC,CAAEiB,GAAG,CAAEC,GAAG,CAAC,CAC5E,CAEA,OAASF,WAAW","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}