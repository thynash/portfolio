{"ast":null,"code":"import{positionalKeys}from'../../render/utils/keys-position.mjs';import{findDimensionValueType}from'../../value/types/dimensions.mjs';import{getVariableValue}from'../utils/css-variables-conversion.mjs';import{isCSSVariableToken}from'../utils/is-css-variable.mjs';import{KeyframeResolver}from'./KeyframesResolver.mjs';import{isNone}from'./utils/is-none.mjs';import{makeNoneKeyframesAnimatable}from'./utils/make-none-animatable.mjs';import{isNumOrPxType,positionalValues}from'./utils/unit-conversion.mjs';class DOMKeyframesResolver extends KeyframeResolver{constructor(unresolvedKeyframes,onComplete,name,motionValue,element){super(unresolvedKeyframes,onComplete,name,motionValue,element,true);}readKeyframes(){const{unresolvedKeyframes,element,name}=this;if(!element||!element.current)return;super.readKeyframes();/**\n         * If any keyframe is a CSS variable, we need to find its value by sampling the element\n         */for(let i=0;i<unresolvedKeyframes.length;i++){let keyframe=unresolvedKeyframes[i];if(typeof keyframe===\"string\"){keyframe=keyframe.trim();if(isCSSVariableToken(keyframe)){const resolved=getVariableValue(keyframe,element.current);if(resolved!==undefined){unresolvedKeyframes[i]=resolved;}if(i===unresolvedKeyframes.length-1){this.finalKeyframe=keyframe;}}}}/**\n         * Resolve \"none\" values. We do this potentially twice - once before and once after measuring keyframes.\n         * This could be seen as inefficient but it's a trade-off to avoid measurements in more situations, which\n         * have a far bigger performance impact.\n         */this.resolveNoneKeyframes();/**\n         * Check to see if unit type has changed. If so schedule jobs that will\n         * temporarily set styles to the destination keyframes.\n         * Skip if we have more than two keyframes or this isn't a positional value.\n         * TODO: We can throw if there are multiple keyframes and the value type changes.\n         */if(!positionalKeys.has(name)||unresolvedKeyframes.length!==2){return;}const[origin,target]=unresolvedKeyframes;const originType=findDimensionValueType(origin);const targetType=findDimensionValueType(target);/**\n         * Either we don't recognise these value types or we can animate between them.\n         */if(originType===targetType)return;/**\n         * If both values are numbers or pixels, we can animate between them by\n         * converting them to numbers.\n         */if(isNumOrPxType(originType)&&isNumOrPxType(targetType)){for(let i=0;i<unresolvedKeyframes.length;i++){const value=unresolvedKeyframes[i];if(typeof value===\"string\"){unresolvedKeyframes[i]=parseFloat(value);}}}else if(positionalValues[name]){/**\n             * Else, the only way to resolve this is by measuring the element.\n             */this.needsMeasurement=true;}}resolveNoneKeyframes(){const{unresolvedKeyframes,name}=this;const noneKeyframeIndexes=[];for(let i=0;i<unresolvedKeyframes.length;i++){if(unresolvedKeyframes[i]===null||isNone(unresolvedKeyframes[i])){noneKeyframeIndexes.push(i);}}if(noneKeyframeIndexes.length){makeNoneKeyframesAnimatable(unresolvedKeyframes,noneKeyframeIndexes,name);}}measureInitialState(){const{element,unresolvedKeyframes,name}=this;if(!element||!element.current)return;if(name===\"height\"){this.suspendedScrollY=window.pageYOffset;}this.measuredOrigin=positionalValues[name](element.measureViewportBox(),window.getComputedStyle(element.current));unresolvedKeyframes[0]=this.measuredOrigin;// Set final key frame to measure after next render\nconst measureKeyframe=unresolvedKeyframes[unresolvedKeyframes.length-1];if(measureKeyframe!==undefined){element.getValue(name,measureKeyframe).jump(measureKeyframe,false);}}measureEndState(){var _this$removedTransfor;const{element,name,unresolvedKeyframes}=this;if(!element||!element.current)return;const value=element.getValue(name);value&&value.jump(this.measuredOrigin,false);const finalKeyframeIndex=unresolvedKeyframes.length-1;const finalKeyframe=unresolvedKeyframes[finalKeyframeIndex];unresolvedKeyframes[finalKeyframeIndex]=positionalValues[name](element.measureViewportBox(),window.getComputedStyle(element.current));if(finalKeyframe!==null&&this.finalKeyframe===undefined){this.finalKeyframe=finalKeyframe;}// If we removed transform values, reapply them before the next render\nif((_this$removedTransfor=this.removedTransforms)!==null&&_this$removedTransfor!==void 0&&_this$removedTransfor.length){this.removedTransforms.forEach(_ref=>{let[unsetTransformName,unsetTransformValue]=_ref;element.getValue(unsetTransformName).set(unsetTransformValue);});}this.resolveNoneKeyframes();}}export{DOMKeyframesResolver};","map":{"version":3,"names":["positionalKeys","findDimensionValueType","getVariableValue","isCSSVariableToken","KeyframeResolver","isNone","makeNoneKeyframesAnimatable","isNumOrPxType","positionalValues","DOMKeyframesResolver","constructor","unresolvedKeyframes","onComplete","name","motionValue","element","readKeyframes","current","i","length","keyframe","trim","resolved","undefined","finalKeyframe","resolveNoneKeyframes","has","origin","target","originType","targetType","value","parseFloat","needsMeasurement","noneKeyframeIndexes","push","measureInitialState","suspendedScrollY","window","pageYOffset","measuredOrigin","measureViewportBox","getComputedStyle","measureKeyframe","getValue","jump","measureEndState","_this$removedTransfor","finalKeyframeIndex","removedTransforms","forEach","_ref","unsetTransformName","unsetTransformValue","set"],"sources":["/home/antisyn/portfolio/src/components/node_modules/motion-dom/dist/es/animation/keyframes/DOMKeyframesResolver.mjs"],"sourcesContent":["import { positionalKeys } from '../../render/utils/keys-position.mjs';\nimport { findDimensionValueType } from '../../value/types/dimensions.mjs';\nimport { getVariableValue } from '../utils/css-variables-conversion.mjs';\nimport { isCSSVariableToken } from '../utils/is-css-variable.mjs';\nimport { KeyframeResolver } from './KeyframesResolver.mjs';\nimport { isNone } from './utils/is-none.mjs';\nimport { makeNoneKeyframesAnimatable } from './utils/make-none-animatable.mjs';\nimport { isNumOrPxType, positionalValues } from './utils/unit-conversion.mjs';\n\nclass DOMKeyframesResolver extends KeyframeResolver {\n    constructor(unresolvedKeyframes, onComplete, name, motionValue, element) {\n        super(unresolvedKeyframes, onComplete, name, motionValue, element, true);\n    }\n    readKeyframes() {\n        const { unresolvedKeyframes, element, name } = this;\n        if (!element || !element.current)\n            return;\n        super.readKeyframes();\n        /**\n         * If any keyframe is a CSS variable, we need to find its value by sampling the element\n         */\n        for (let i = 0; i < unresolvedKeyframes.length; i++) {\n            let keyframe = unresolvedKeyframes[i];\n            if (typeof keyframe === \"string\") {\n                keyframe = keyframe.trim();\n                if (isCSSVariableToken(keyframe)) {\n                    const resolved = getVariableValue(keyframe, element.current);\n                    if (resolved !== undefined) {\n                        unresolvedKeyframes[i] = resolved;\n                    }\n                    if (i === unresolvedKeyframes.length - 1) {\n                        this.finalKeyframe = keyframe;\n                    }\n                }\n            }\n        }\n        /**\n         * Resolve \"none\" values. We do this potentially twice - once before and once after measuring keyframes.\n         * This could be seen as inefficient but it's a trade-off to avoid measurements in more situations, which\n         * have a far bigger performance impact.\n         */\n        this.resolveNoneKeyframes();\n        /**\n         * Check to see if unit type has changed. If so schedule jobs that will\n         * temporarily set styles to the destination keyframes.\n         * Skip if we have more than two keyframes or this isn't a positional value.\n         * TODO: We can throw if there are multiple keyframes and the value type changes.\n         */\n        if (!positionalKeys.has(name) || unresolvedKeyframes.length !== 2) {\n            return;\n        }\n        const [origin, target] = unresolvedKeyframes;\n        const originType = findDimensionValueType(origin);\n        const targetType = findDimensionValueType(target);\n        /**\n         * Either we don't recognise these value types or we can animate between them.\n         */\n        if (originType === targetType)\n            return;\n        /**\n         * If both values are numbers or pixels, we can animate between them by\n         * converting them to numbers.\n         */\n        if (isNumOrPxType(originType) && isNumOrPxType(targetType)) {\n            for (let i = 0; i < unresolvedKeyframes.length; i++) {\n                const value = unresolvedKeyframes[i];\n                if (typeof value === \"string\") {\n                    unresolvedKeyframes[i] = parseFloat(value);\n                }\n            }\n        }\n        else if (positionalValues[name]) {\n            /**\n             * Else, the only way to resolve this is by measuring the element.\n             */\n            this.needsMeasurement = true;\n        }\n    }\n    resolveNoneKeyframes() {\n        const { unresolvedKeyframes, name } = this;\n        const noneKeyframeIndexes = [];\n        for (let i = 0; i < unresolvedKeyframes.length; i++) {\n            if (unresolvedKeyframes[i] === null ||\n                isNone(unresolvedKeyframes[i])) {\n                noneKeyframeIndexes.push(i);\n            }\n        }\n        if (noneKeyframeIndexes.length) {\n            makeNoneKeyframesAnimatable(unresolvedKeyframes, noneKeyframeIndexes, name);\n        }\n    }\n    measureInitialState() {\n        const { element, unresolvedKeyframes, name } = this;\n        if (!element || !element.current)\n            return;\n        if (name === \"height\") {\n            this.suspendedScrollY = window.pageYOffset;\n        }\n        this.measuredOrigin = positionalValues[name](element.measureViewportBox(), window.getComputedStyle(element.current));\n        unresolvedKeyframes[0] = this.measuredOrigin;\n        // Set final key frame to measure after next render\n        const measureKeyframe = unresolvedKeyframes[unresolvedKeyframes.length - 1];\n        if (measureKeyframe !== undefined) {\n            element.getValue(name, measureKeyframe).jump(measureKeyframe, false);\n        }\n    }\n    measureEndState() {\n        const { element, name, unresolvedKeyframes } = this;\n        if (!element || !element.current)\n            return;\n        const value = element.getValue(name);\n        value && value.jump(this.measuredOrigin, false);\n        const finalKeyframeIndex = unresolvedKeyframes.length - 1;\n        const finalKeyframe = unresolvedKeyframes[finalKeyframeIndex];\n        unresolvedKeyframes[finalKeyframeIndex] = positionalValues[name](element.measureViewportBox(), window.getComputedStyle(element.current));\n        if (finalKeyframe !== null && this.finalKeyframe === undefined) {\n            this.finalKeyframe = finalKeyframe;\n        }\n        // If we removed transform values, reapply them before the next render\n        if (this.removedTransforms?.length) {\n            this.removedTransforms.forEach(([unsetTransformName, unsetTransformValue]) => {\n                element\n                    .getValue(unsetTransformName)\n                    .set(unsetTransformValue);\n            });\n        }\n        this.resolveNoneKeyframes();\n    }\n}\n\nexport { DOMKeyframesResolver };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}