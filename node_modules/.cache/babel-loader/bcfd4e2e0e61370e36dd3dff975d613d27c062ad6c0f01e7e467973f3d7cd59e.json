{"ast":null,"code":"import{statsBuffer}from'../stats/buffer.mjs';function createRenderStep(runNextFrame,stepName){/**\n     * We create and reuse two queues, one to queue jobs for the current frame\n     * and one for the next. We reuse to avoid triggering GC after x frames.\n     */let thisFrame=new Set();let nextFrame=new Set();/**\n     * Track whether we're currently processing jobs in this step. This way\n     * we can decide whether to schedule new jobs for this frame or next.\n     */let isProcessing=false;let flushNextFrame=false;/**\n     * A set of processes which were marked keepAlive when scheduled.\n     */const toKeepAlive=new WeakSet();let latestFrameData={delta:0.0,timestamp:0.0,isProcessing:false};let numCalls=0;function triggerCallback(callback){if(toKeepAlive.has(callback)){step.schedule(callback);runNextFrame();}numCalls++;callback(latestFrameData);}const step={/**\n         * Schedule a process to run on the next frame.\n         */schedule:function(callback){let keepAlive=arguments.length>1&&arguments[1]!==undefined?arguments[1]:false;let immediate=arguments.length>2&&arguments[2]!==undefined?arguments[2]:false;const addToCurrentFrame=immediate&&isProcessing;const queue=addToCurrentFrame?thisFrame:nextFrame;if(keepAlive)toKeepAlive.add(callback);if(!queue.has(callback))queue.add(callback);return callback;},/**\n         * Cancel the provided callback from running on the next frame.\n         */cancel:callback=>{nextFrame.delete(callback);toKeepAlive.delete(callback);},/**\n         * Execute all schedule callbacks.\n         */process:frameData=>{latestFrameData=frameData;/**\n             * If we're already processing we've probably been triggered by a flushSync\n             * inside an existing process. Instead of executing, mark flushNextFrame\n             * as true and ensure we flush the following frame at the end of this one.\n             */if(isProcessing){flushNextFrame=true;return;}isProcessing=true;[thisFrame,nextFrame]=[nextFrame,thisFrame];// Execute this frame\nthisFrame.forEach(triggerCallback);/**\n             * If we're recording stats then\n             */if(stepName&&statsBuffer.value){statsBuffer.value.frameloop[stepName].push(numCalls);}numCalls=0;// Clear the frame so no callbacks remain. This is to avoid\n// memory leaks should this render step not run for a while.\nthisFrame.clear();isProcessing=false;if(flushNextFrame){flushNextFrame=false;step.process(frameData);}}};return step;}export{createRenderStep};","map":{"version":3,"names":["statsBuffer","createRenderStep","runNextFrame","stepName","thisFrame","Set","nextFrame","isProcessing","flushNextFrame","toKeepAlive","WeakSet","latestFrameData","delta","timestamp","numCalls","triggerCallback","callback","has","step","schedule","keepAlive","arguments","length","undefined","immediate","addToCurrentFrame","queue","add","cancel","delete","process","frameData","forEach","value","frameloop","push","clear"],"sources":["/home/antisyn/portfolio/src/components/node_modules/motion-dom/dist/es/frameloop/render-step.mjs"],"sourcesContent":["import { statsBuffer } from '../stats/buffer.mjs';\n\nfunction createRenderStep(runNextFrame, stepName) {\n    /**\n     * We create and reuse two queues, one to queue jobs for the current frame\n     * and one for the next. We reuse to avoid triggering GC after x frames.\n     */\n    let thisFrame = new Set();\n    let nextFrame = new Set();\n    /**\n     * Track whether we're currently processing jobs in this step. This way\n     * we can decide whether to schedule new jobs for this frame or next.\n     */\n    let isProcessing = false;\n    let flushNextFrame = false;\n    /**\n     * A set of processes which were marked keepAlive when scheduled.\n     */\n    const toKeepAlive = new WeakSet();\n    let latestFrameData = {\n        delta: 0.0,\n        timestamp: 0.0,\n        isProcessing: false,\n    };\n    let numCalls = 0;\n    function triggerCallback(callback) {\n        if (toKeepAlive.has(callback)) {\n            step.schedule(callback);\n            runNextFrame();\n        }\n        numCalls++;\n        callback(latestFrameData);\n    }\n    const step = {\n        /**\n         * Schedule a process to run on the next frame.\n         */\n        schedule: (callback, keepAlive = false, immediate = false) => {\n            const addToCurrentFrame = immediate && isProcessing;\n            const queue = addToCurrentFrame ? thisFrame : nextFrame;\n            if (keepAlive)\n                toKeepAlive.add(callback);\n            if (!queue.has(callback))\n                queue.add(callback);\n            return callback;\n        },\n        /**\n         * Cancel the provided callback from running on the next frame.\n         */\n        cancel: (callback) => {\n            nextFrame.delete(callback);\n            toKeepAlive.delete(callback);\n        },\n        /**\n         * Execute all schedule callbacks.\n         */\n        process: (frameData) => {\n            latestFrameData = frameData;\n            /**\n             * If we're already processing we've probably been triggered by a flushSync\n             * inside an existing process. Instead of executing, mark flushNextFrame\n             * as true and ensure we flush the following frame at the end of this one.\n             */\n            if (isProcessing) {\n                flushNextFrame = true;\n                return;\n            }\n            isProcessing = true;\n            [thisFrame, nextFrame] = [nextFrame, thisFrame];\n            // Execute this frame\n            thisFrame.forEach(triggerCallback);\n            /**\n             * If we're recording stats then\n             */\n            if (stepName && statsBuffer.value) {\n                statsBuffer.value.frameloop[stepName].push(numCalls);\n            }\n            numCalls = 0;\n            // Clear the frame so no callbacks remain. This is to avoid\n            // memory leaks should this render step not run for a while.\n            thisFrame.clear();\n            isProcessing = false;\n            if (flushNextFrame) {\n                flushNextFrame = false;\n                step.process(frameData);\n            }\n        },\n    };\n    return step;\n}\n\nexport { createRenderStep };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}