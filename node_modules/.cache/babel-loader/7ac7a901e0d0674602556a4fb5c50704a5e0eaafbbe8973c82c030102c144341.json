{"ast":null,"code":"import{invariant}from'motion-utils';import{setTarget}from'../../render/utils/setters.mjs';import{animateVisualElement}from'../interfaces/visual-element.mjs';function stopAnimation(visualElement){visualElement.values.forEach(value=>value.stop());}function setVariants(visualElement,variantLabels){const reversedLabels=[...variantLabels].reverse();reversedLabels.forEach(key=>{const variant=visualElement.getVariant(key);variant&&setTarget(visualElement,variant);if(visualElement.variantChildren){visualElement.variantChildren.forEach(child=>{setVariants(child,variantLabels);});}});}function setValues(visualElement,definition){if(Array.isArray(definition)){return setVariants(visualElement,definition);}else if(typeof definition===\"string\"){return setVariants(visualElement,[definition]);}else{setTarget(visualElement,definition);}}/**\n * @public\n */function animationControls(){/**\n     * Track whether the host component has mounted.\n     */let hasMounted=false;/**\n     * A collection of linked component animation controls.\n     */const subscribers=new Set();const controls={subscribe(visualElement){subscribers.add(visualElement);return()=>void subscribers.delete(visualElement);},start(definition,transitionOverride){invariant(hasMounted,\"controls.start() should only be called after a component has mounted. Consider calling within a useEffect hook.\");const animations=[];subscribers.forEach(visualElement=>{animations.push(animateVisualElement(visualElement,definition,{transitionOverride}));});return Promise.all(animations);},set(definition){invariant(hasMounted,\"controls.set() should only be called after a component has mounted. Consider calling within a useEffect hook.\");return subscribers.forEach(visualElement=>{setValues(visualElement,definition);});},stop(){subscribers.forEach(visualElement=>{stopAnimation(visualElement);});},mount(){hasMounted=true;return()=>{hasMounted=false;controls.stop();};}};return controls;}export{animationControls,setValues};","map":{"version":3,"names":["invariant","setTarget","animateVisualElement","stopAnimation","visualElement","values","forEach","value","stop","setVariants","variantLabels","reversedLabels","reverse","key","variant","getVariant","variantChildren","child","setValues","definition","Array","isArray","animationControls","hasMounted","subscribers","Set","controls","subscribe","add","delete","start","transitionOverride","animations","push","Promise","all","set","mount"],"sources":["/home/antisyn/portfolio/src/components/node_modules/framer-motion/dist/es/animation/hooks/animation-controls.mjs"],"sourcesContent":["import { invariant } from 'motion-utils';\nimport { setTarget } from '../../render/utils/setters.mjs';\nimport { animateVisualElement } from '../interfaces/visual-element.mjs';\n\nfunction stopAnimation(visualElement) {\n    visualElement.values.forEach((value) => value.stop());\n}\nfunction setVariants(visualElement, variantLabels) {\n    const reversedLabels = [...variantLabels].reverse();\n    reversedLabels.forEach((key) => {\n        const variant = visualElement.getVariant(key);\n        variant && setTarget(visualElement, variant);\n        if (visualElement.variantChildren) {\n            visualElement.variantChildren.forEach((child) => {\n                setVariants(child, variantLabels);\n            });\n        }\n    });\n}\nfunction setValues(visualElement, definition) {\n    if (Array.isArray(definition)) {\n        return setVariants(visualElement, definition);\n    }\n    else if (typeof definition === \"string\") {\n        return setVariants(visualElement, [definition]);\n    }\n    else {\n        setTarget(visualElement, definition);\n    }\n}\n/**\n * @public\n */\nfunction animationControls() {\n    /**\n     * Track whether the host component has mounted.\n     */\n    let hasMounted = false;\n    /**\n     * A collection of linked component animation controls.\n     */\n    const subscribers = new Set();\n    const controls = {\n        subscribe(visualElement) {\n            subscribers.add(visualElement);\n            return () => void subscribers.delete(visualElement);\n        },\n        start(definition, transitionOverride) {\n            invariant(hasMounted, \"controls.start() should only be called after a component has mounted. Consider calling within a useEffect hook.\");\n            const animations = [];\n            subscribers.forEach((visualElement) => {\n                animations.push(animateVisualElement(visualElement, definition, {\n                    transitionOverride,\n                }));\n            });\n            return Promise.all(animations);\n        },\n        set(definition) {\n            invariant(hasMounted, \"controls.set() should only be called after a component has mounted. Consider calling within a useEffect hook.\");\n            return subscribers.forEach((visualElement) => {\n                setValues(visualElement, definition);\n            });\n        },\n        stop() {\n            subscribers.forEach((visualElement) => {\n                stopAnimation(visualElement);\n            });\n        },\n        mount() {\n            hasMounted = true;\n            return () => {\n                hasMounted = false;\n                controls.stop();\n            };\n        },\n    };\n    return controls;\n}\n\nexport { animationControls, setValues };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}