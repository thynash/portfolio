{"ast":null,"code":"import{spring}from'./spring/index.mjs';import{calcGeneratorVelocity}from'./utils/velocity.mjs';function inertia(_ref){let{keyframes,velocity=0.0,power=0.8,timeConstant=325,bounceDamping=10,bounceStiffness=500,modifyTarget,min,max,restDelta=0.5,restSpeed}=_ref;const origin=keyframes[0];const state={done:false,value:origin};const isOutOfBounds=v=>min!==undefined&&v<min||max!==undefined&&v>max;const nearestBoundary=v=>{if(min===undefined)return max;if(max===undefined)return min;return Math.abs(min-v)<Math.abs(max-v)?min:max;};let amplitude=power*velocity;const ideal=origin+amplitude;const target=modifyTarget===undefined?ideal:modifyTarget(ideal);/**\n     * If the target has changed we need to re-calculate the amplitude, otherwise\n     * the animation will start from the wrong position.\n     */if(target!==ideal)amplitude=target-origin;const calcDelta=t=>-amplitude*Math.exp(-t/timeConstant);const calcLatest=t=>target+calcDelta(t);const applyFriction=t=>{const delta=calcDelta(t);const latest=calcLatest(t);state.done=Math.abs(delta)<=restDelta;state.value=state.done?target:latest;};/**\n     * Ideally this would resolve for t in a stateless way, we could\n     * do that by always precalculating the animation but as we know\n     * this will be done anyway we can assume that spring will\n     * be discovered during that.\n     */let timeReachedBoundary;let spring$1;const checkCatchBoundary=t=>{if(!isOutOfBounds(state.value))return;timeReachedBoundary=t;spring$1=spring({keyframes:[state.value,nearestBoundary(state.value)],velocity:calcGeneratorVelocity(calcLatest,t,state.value),// TODO: This should be passing * 1000\ndamping:bounceDamping,stiffness:bounceStiffness,restDelta,restSpeed});};checkCatchBoundary(0);return{calculatedDuration:null,next:t=>{/**\n             * We need to resolve the friction to figure out if we need a\n             * spring but we don't want to do this twice per frame. So here\n             * we flag if we updated for this frame and later if we did\n             * we can skip doing it again.\n             */let hasUpdatedFrame=false;if(!spring$1&&timeReachedBoundary===undefined){hasUpdatedFrame=true;applyFriction(t);checkCatchBoundary(t);}/**\n             * If we have a spring and the provided t is beyond the moment the friction\n             * animation crossed the min/max boundary, use the spring.\n             */if(timeReachedBoundary!==undefined&&t>=timeReachedBoundary){return spring$1.next(t-timeReachedBoundary);}else{!hasUpdatedFrame&&applyFriction(t);return state;}}};}export{inertia};","map":{"version":3,"names":["spring","calcGeneratorVelocity","inertia","_ref","keyframes","velocity","power","timeConstant","bounceDamping","bounceStiffness","modifyTarget","min","max","restDelta","restSpeed","origin","state","done","value","isOutOfBounds","v","undefined","nearestBoundary","Math","abs","amplitude","ideal","target","calcDelta","t","exp","calcLatest","applyFriction","delta","latest","timeReachedBoundary","spring$1","checkCatchBoundary","damping","stiffness","calculatedDuration","next","hasUpdatedFrame"],"sources":["/home/antisyn/portfolio/src/components/node_modules/motion-dom/dist/es/animation/generators/inertia.mjs"],"sourcesContent":["import { spring } from './spring/index.mjs';\nimport { calcGeneratorVelocity } from './utils/velocity.mjs';\n\nfunction inertia({ keyframes, velocity = 0.0, power = 0.8, timeConstant = 325, bounceDamping = 10, bounceStiffness = 500, modifyTarget, min, max, restDelta = 0.5, restSpeed, }) {\n    const origin = keyframes[0];\n    const state = {\n        done: false,\n        value: origin,\n    };\n    const isOutOfBounds = (v) => (min !== undefined && v < min) || (max !== undefined && v > max);\n    const nearestBoundary = (v) => {\n        if (min === undefined)\n            return max;\n        if (max === undefined)\n            return min;\n        return Math.abs(min - v) < Math.abs(max - v) ? min : max;\n    };\n    let amplitude = power * velocity;\n    const ideal = origin + amplitude;\n    const target = modifyTarget === undefined ? ideal : modifyTarget(ideal);\n    /**\n     * If the target has changed we need to re-calculate the amplitude, otherwise\n     * the animation will start from the wrong position.\n     */\n    if (target !== ideal)\n        amplitude = target - origin;\n    const calcDelta = (t) => -amplitude * Math.exp(-t / timeConstant);\n    const calcLatest = (t) => target + calcDelta(t);\n    const applyFriction = (t) => {\n        const delta = calcDelta(t);\n        const latest = calcLatest(t);\n        state.done = Math.abs(delta) <= restDelta;\n        state.value = state.done ? target : latest;\n    };\n    /**\n     * Ideally this would resolve for t in a stateless way, we could\n     * do that by always precalculating the animation but as we know\n     * this will be done anyway we can assume that spring will\n     * be discovered during that.\n     */\n    let timeReachedBoundary;\n    let spring$1;\n    const checkCatchBoundary = (t) => {\n        if (!isOutOfBounds(state.value))\n            return;\n        timeReachedBoundary = t;\n        spring$1 = spring({\n            keyframes: [state.value, nearestBoundary(state.value)],\n            velocity: calcGeneratorVelocity(calcLatest, t, state.value), // TODO: This should be passing * 1000\n            damping: bounceDamping,\n            stiffness: bounceStiffness,\n            restDelta,\n            restSpeed,\n        });\n    };\n    checkCatchBoundary(0);\n    return {\n        calculatedDuration: null,\n        next: (t) => {\n            /**\n             * We need to resolve the friction to figure out if we need a\n             * spring but we don't want to do this twice per frame. So here\n             * we flag if we updated for this frame and later if we did\n             * we can skip doing it again.\n             */\n            let hasUpdatedFrame = false;\n            if (!spring$1 && timeReachedBoundary === undefined) {\n                hasUpdatedFrame = true;\n                applyFriction(t);\n                checkCatchBoundary(t);\n            }\n            /**\n             * If we have a spring and the provided t is beyond the moment the friction\n             * animation crossed the min/max boundary, use the spring.\n             */\n            if (timeReachedBoundary !== undefined && t >= timeReachedBoundary) {\n                return spring$1.next(t - timeReachedBoundary);\n            }\n            else {\n                !hasUpdatedFrame && applyFriction(t);\n                return state;\n            }\n        },\n    };\n}\n\nexport { inertia };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}