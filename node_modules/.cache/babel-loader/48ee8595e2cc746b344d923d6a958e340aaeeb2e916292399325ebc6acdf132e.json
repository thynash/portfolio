{"ast":null,"code":"import _objectSpread from\"/home/antisyn/portfolio/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";import{invariant,pipe,clamp,millisecondsToSeconds,secondsToMilliseconds}from'motion-utils';import{time}from'../frameloop/sync-time.mjs';import{activeAnimations}from'../stats/animation-count.mjs';import{mix}from'../utils/mix/index.mjs';import{frameloopDriver}from'./drivers/frame.mjs';import{inertia}from'./generators/inertia.mjs';import{keyframes}from'./generators/keyframes.mjs';import{calcGeneratorDuration}from'./generators/utils/calc-duration.mjs';import{getFinalKeyframe}from'./keyframes/get-final.mjs';import{replaceTransitionType}from'./utils/replace-transition-type.mjs';import{WithPromise}from'./utils/WithPromise.mjs';const percentToProgress=percent=>percent/100;class JSAnimation extends WithPromise{constructor(options){super();this.state=\"idle\";this.startTime=null;this.isStopped=false;/**\n         * The current time of the animation.\n         */this.currentTime=0;/**\n         * The time at which the animation was paused.\n         */this.holdTime=null;/**\n         * Playback speed as a factor. 0 would be stopped, -1 reverse and 2 double speed.\n         */this.playbackSpeed=1;/**\n         * This method is bound to the instance to fix a pattern where\n         * animation.stop is returned as a reference from a useEffect.\n         */this.stop=()=>{var _this$options$onStop,_this$options;const{motionValue}=this.options;if(motionValue&&motionValue.updatedAt!==time.now()){this.tick(time.now());}this.isStopped=true;if(this.state===\"idle\")return;this.teardown();(_this$options$onStop=(_this$options=this.options).onStop)===null||_this$options$onStop===void 0?void 0:_this$options$onStop.call(_this$options);};activeAnimations.mainThread++;this.options=options;this.initAnimation();this.play();if(options.autoplay===false)this.pause();}initAnimation(){const{options}=this;replaceTransitionType(options);const{type=keyframes,repeat=0,repeatDelay=0,repeatType,velocity=0}=options;let{keyframes:keyframes$1}=options;const generatorFactory=type||keyframes;if(process.env.NODE_ENV!==\"production\"&&generatorFactory!==keyframes){invariant(keyframes$1.length<=2,\"Only two keyframes currently supported with spring and inertia animations. Trying to animate \".concat(keyframes$1));}if(generatorFactory!==keyframes&&typeof keyframes$1[0]!==\"number\"){this.mixKeyframes=pipe(percentToProgress,mix(keyframes$1[0],keyframes$1[1]));keyframes$1=[0,100];}const generator=generatorFactory(_objectSpread(_objectSpread({},options),{},{keyframes:keyframes$1}));/**\n         * If we have a mirror repeat type we need to create a second generator that outputs the\n         * mirrored (not reversed) animation and later ping pong between the two generators.\n         */if(repeatType===\"mirror\"){this.mirroredGenerator=generatorFactory(_objectSpread(_objectSpread({},options),{},{keyframes:[...keyframes$1].reverse(),velocity:-velocity}));}/**\n         * If duration is undefined and we have repeat options,\n         * we need to calculate a duration from the generator.\n         *\n         * We set it to the generator itself to cache the duration.\n         * Any timeline resolver will need to have already precalculated\n         * the duration by this step.\n         */if(generator.calculatedDuration===null){generator.calculatedDuration=calcGeneratorDuration(generator);}const{calculatedDuration}=generator;this.calculatedDuration=calculatedDuration;this.resolvedDuration=calculatedDuration+repeatDelay;this.totalDuration=this.resolvedDuration*(repeat+1)-repeatDelay;this.generator=generator;}updateTime(timestamp){const animationTime=Math.round(timestamp-this.startTime)*this.playbackSpeed;// Update currentTime\nif(this.holdTime!==null){this.currentTime=this.holdTime;}else{// Rounding the time because floating point arithmetic is not always accurate, e.g. 3000.367 - 1000.367 =\n// 2000.0000000000002. This is a problem when we are comparing the currentTime with the duration, for\n// example.\nthis.currentTime=animationTime;}}tick(timestamp){let sample=arguments.length>1&&arguments[1]!==undefined?arguments[1]:false;const{generator,totalDuration,mixKeyframes,mirroredGenerator,resolvedDuration,calculatedDuration}=this;if(this.startTime===null)return generator.next(0);const{delay=0,keyframes,repeat,repeatType,repeatDelay,type,onUpdate,finalKeyframe}=this.options;/**\n         * requestAnimationFrame timestamps can come through as lower than\n         * the startTime as set by performance.now(). Here we prevent this,\n         * though in the future it could be possible to make setting startTime\n         * a pending operation that gets resolved here.\n         */if(this.speed>0){this.startTime=Math.min(this.startTime,timestamp);}else if(this.speed<0){this.startTime=Math.min(timestamp-totalDuration/this.speed,this.startTime);}if(sample){this.currentTime=timestamp;}else{this.updateTime(timestamp);}// Rebase on delay\nconst timeWithoutDelay=this.currentTime-delay*(this.playbackSpeed>=0?1:-1);const isInDelayPhase=this.playbackSpeed>=0?timeWithoutDelay<0:timeWithoutDelay>totalDuration;this.currentTime=Math.max(timeWithoutDelay,0);// If this animation has finished, set the current time  to the total duration.\nif(this.state===\"finished\"&&this.holdTime===null){this.currentTime=totalDuration;}let elapsed=this.currentTime;let frameGenerator=generator;if(repeat){/**\n             * Get the current progress (0-1) of the animation. If t is >\n             * than duration we'll get values like 2.5 (midway through the\n             * third iteration)\n             */const progress=Math.min(this.currentTime,totalDuration)/resolvedDuration;/**\n             * Get the current iteration (0 indexed). For instance the floor of\n             * 2.5 is 2.\n             */let currentIteration=Math.floor(progress);/**\n             * Get the current progress of the iteration by taking the remainder\n             * so 2.5 is 0.5 through iteration 2\n             */let iterationProgress=progress%1.0;/**\n             * If iteration progress is 1 we count that as the end\n             * of the previous iteration.\n             */if(!iterationProgress&&progress>=1){iterationProgress=1;}iterationProgress===1&&currentIteration--;currentIteration=Math.min(currentIteration,repeat+1);/**\n             * Reverse progress if we're not running in \"normal\" direction\n             */const isOddIteration=Boolean(currentIteration%2);if(isOddIteration){if(repeatType===\"reverse\"){iterationProgress=1-iterationProgress;if(repeatDelay){iterationProgress-=repeatDelay/resolvedDuration;}}else if(repeatType===\"mirror\"){frameGenerator=mirroredGenerator;}}elapsed=clamp(0,1,iterationProgress)*resolvedDuration;}/**\n         * If we're in negative time, set state as the initial keyframe.\n         * This prevents delay: x, duration: 0 animations from finishing\n         * instantly.\n         */const state=isInDelayPhase?{done:false,value:keyframes[0]}:frameGenerator.next(elapsed);if(mixKeyframes){state.value=mixKeyframes(state.value);}let{done}=state;if(!isInDelayPhase&&calculatedDuration!==null){done=this.playbackSpeed>=0?this.currentTime>=totalDuration:this.currentTime<=0;}const isAnimationFinished=this.holdTime===null&&(this.state===\"finished\"||this.state===\"running\"&&done);// TODO: The exception for inertia could be cleaner here\nif(isAnimationFinished&&type!==inertia){state.value=getFinalKeyframe(keyframes,this.options,finalKeyframe,this.speed);}if(onUpdate){onUpdate(state.value);}if(isAnimationFinished){this.finish();}return state;}/**\n     * Allows the returned animation to be awaited or promise-chained. Currently\n     * resolves when the animation finishes at all but in a future update could/should\n     * reject if its cancels.\n     */then(resolve,reject){return this.finished.then(resolve,reject);}get duration(){return millisecondsToSeconds(this.calculatedDuration);}get time(){return millisecondsToSeconds(this.currentTime);}set time(newTime){var _this$driver;newTime=secondsToMilliseconds(newTime);this.currentTime=newTime;if(this.startTime===null||this.holdTime!==null||this.playbackSpeed===0){this.holdTime=newTime;}else if(this.driver){this.startTime=this.driver.now()-newTime/this.playbackSpeed;}(_this$driver=this.driver)===null||_this$driver===void 0?void 0:_this$driver.start(false);}get speed(){return this.playbackSpeed;}set speed(newSpeed){this.updateTime(time.now());const hasChanged=this.playbackSpeed!==newSpeed;this.playbackSpeed=newSpeed;if(hasChanged){this.time=millisecondsToSeconds(this.currentTime);}}play(){var _this$options$onPlay,_this$options2;if(this.isStopped)return;const{driver=frameloopDriver,startTime}=this.options;if(!this.driver){this.driver=driver(timestamp=>this.tick(timestamp));}(_this$options$onPlay=(_this$options2=this.options).onPlay)===null||_this$options$onPlay===void 0?void 0:_this$options$onPlay.call(_this$options2);const now=this.driver.now();if(this.state===\"finished\"){this.updateFinished();this.startTime=now;}else if(this.holdTime!==null){this.startTime=now-this.holdTime;}else if(!this.startTime){this.startTime=startTime!==null&&startTime!==void 0?startTime:now;}if(this.state===\"finished\"&&this.speed<0){this.startTime+=this.calculatedDuration;}this.holdTime=null;/**\n         * Set playState to running only after we've used it in\n         * the previous logic.\n         */this.state=\"running\";this.driver.start();}pause(){this.state=\"paused\";this.updateTime(time.now());this.holdTime=this.currentTime;}complete(){if(this.state!==\"running\"){this.play();}this.state=\"finished\";this.holdTime=null;}finish(){var _this$options$onCompl,_this$options3;this.notifyFinished();this.teardown();this.state=\"finished\";(_this$options$onCompl=(_this$options3=this.options).onComplete)===null||_this$options$onCompl===void 0?void 0:_this$options$onCompl.call(_this$options3);}cancel(){var _this$options$onCance,_this$options4;this.holdTime=null;this.startTime=0;this.tick(0);this.teardown();(_this$options$onCance=(_this$options4=this.options).onCancel)===null||_this$options$onCance===void 0?void 0:_this$options$onCance.call(_this$options4);}teardown(){this.state=\"idle\";this.stopDriver();this.startTime=this.holdTime=null;activeAnimations.mainThread--;}stopDriver(){if(!this.driver)return;this.driver.stop();this.driver=undefined;}sample(sampleTime){this.startTime=0;return this.tick(sampleTime,true);}attachTimeline(timeline){var _this$driver2;if(this.options.allowFlatten){this.options.type=\"keyframes\";this.options.ease=\"linear\";this.initAnimation();}(_this$driver2=this.driver)===null||_this$driver2===void 0?void 0:_this$driver2.stop();return timeline.observe(this);}}// Legacy function support\nfunction animateValue(options){return new JSAnimation(options);}export{JSAnimation,animateValue};","map":{"version":3,"names":["invariant","pipe","clamp","millisecondsToSeconds","secondsToMilliseconds","time","activeAnimations","mix","frameloopDriver","inertia","keyframes","calcGeneratorDuration","getFinalKeyframe","replaceTransitionType","WithPromise","percentToProgress","percent","JSAnimation","constructor","options","state","startTime","isStopped","currentTime","holdTime","playbackSpeed","stop","_this$options$onStop","_this$options","motionValue","updatedAt","now","tick","teardown","onStop","call","mainThread","initAnimation","play","autoplay","pause","type","repeat","repeatDelay","repeatType","velocity","keyframes$1","generatorFactory","process","env","NODE_ENV","length","concat","mixKeyframes","generator","_objectSpread","mirroredGenerator","reverse","calculatedDuration","resolvedDuration","totalDuration","updateTime","timestamp","animationTime","Math","round","sample","arguments","undefined","next","delay","onUpdate","finalKeyframe","speed","min","timeWithoutDelay","isInDelayPhase","max","elapsed","frameGenerator","progress","currentIteration","floor","iterationProgress","isOddIteration","Boolean","done","value","isAnimationFinished","finish","then","resolve","reject","finished","duration","newTime","_this$driver","driver","start","newSpeed","hasChanged","_this$options$onPlay","_this$options2","onPlay","updateFinished","complete","_this$options$onCompl","_this$options3","notifyFinished","onComplete","cancel","_this$options$onCance","_this$options4","onCancel","stopDriver","sampleTime","attachTimeline","timeline","_this$driver2","allowFlatten","ease","observe","animateValue"],"sources":["/home/antisyn/portfolio/src/components/node_modules/motion-dom/dist/es/animation/JSAnimation.mjs"],"sourcesContent":["import { invariant, pipe, clamp, millisecondsToSeconds, secondsToMilliseconds } from 'motion-utils';\nimport { time } from '../frameloop/sync-time.mjs';\nimport { activeAnimations } from '../stats/animation-count.mjs';\nimport { mix } from '../utils/mix/index.mjs';\nimport { frameloopDriver } from './drivers/frame.mjs';\nimport { inertia } from './generators/inertia.mjs';\nimport { keyframes } from './generators/keyframes.mjs';\nimport { calcGeneratorDuration } from './generators/utils/calc-duration.mjs';\nimport { getFinalKeyframe } from './keyframes/get-final.mjs';\nimport { replaceTransitionType } from './utils/replace-transition-type.mjs';\nimport { WithPromise } from './utils/WithPromise.mjs';\n\nconst percentToProgress = (percent) => percent / 100;\nclass JSAnimation extends WithPromise {\n    constructor(options) {\n        super();\n        this.state = \"idle\";\n        this.startTime = null;\n        this.isStopped = false;\n        /**\n         * The current time of the animation.\n         */\n        this.currentTime = 0;\n        /**\n         * The time at which the animation was paused.\n         */\n        this.holdTime = null;\n        /**\n         * Playback speed as a factor. 0 would be stopped, -1 reverse and 2 double speed.\n         */\n        this.playbackSpeed = 1;\n        /**\n         * This method is bound to the instance to fix a pattern where\n         * animation.stop is returned as a reference from a useEffect.\n         */\n        this.stop = () => {\n            const { motionValue } = this.options;\n            if (motionValue && motionValue.updatedAt !== time.now()) {\n                this.tick(time.now());\n            }\n            this.isStopped = true;\n            if (this.state === \"idle\")\n                return;\n            this.teardown();\n            this.options.onStop?.();\n        };\n        activeAnimations.mainThread++;\n        this.options = options;\n        this.initAnimation();\n        this.play();\n        if (options.autoplay === false)\n            this.pause();\n    }\n    initAnimation() {\n        const { options } = this;\n        replaceTransitionType(options);\n        const { type = keyframes, repeat = 0, repeatDelay = 0, repeatType, velocity = 0, } = options;\n        let { keyframes: keyframes$1 } = options;\n        const generatorFactory = type || keyframes;\n        if (process.env.NODE_ENV !== \"production\" &&\n            generatorFactory !== keyframes) {\n            invariant(keyframes$1.length <= 2, `Only two keyframes currently supported with spring and inertia animations. Trying to animate ${keyframes$1}`);\n        }\n        if (generatorFactory !== keyframes &&\n            typeof keyframes$1[0] !== \"number\") {\n            this.mixKeyframes = pipe(percentToProgress, mix(keyframes$1[0], keyframes$1[1]));\n            keyframes$1 = [0, 100];\n        }\n        const generator = generatorFactory({ ...options, keyframes: keyframes$1 });\n        /**\n         * If we have a mirror repeat type we need to create a second generator that outputs the\n         * mirrored (not reversed) animation and later ping pong between the two generators.\n         */\n        if (repeatType === \"mirror\") {\n            this.mirroredGenerator = generatorFactory({\n                ...options,\n                keyframes: [...keyframes$1].reverse(),\n                velocity: -velocity,\n            });\n        }\n        /**\n         * If duration is undefined and we have repeat options,\n         * we need to calculate a duration from the generator.\n         *\n         * We set it to the generator itself to cache the duration.\n         * Any timeline resolver will need to have already precalculated\n         * the duration by this step.\n         */\n        if (generator.calculatedDuration === null) {\n            generator.calculatedDuration = calcGeneratorDuration(generator);\n        }\n        const { calculatedDuration } = generator;\n        this.calculatedDuration = calculatedDuration;\n        this.resolvedDuration = calculatedDuration + repeatDelay;\n        this.totalDuration = this.resolvedDuration * (repeat + 1) - repeatDelay;\n        this.generator = generator;\n    }\n    updateTime(timestamp) {\n        const animationTime = Math.round(timestamp - this.startTime) * this.playbackSpeed;\n        // Update currentTime\n        if (this.holdTime !== null) {\n            this.currentTime = this.holdTime;\n        }\n        else {\n            // Rounding the time because floating point arithmetic is not always accurate, e.g. 3000.367 - 1000.367 =\n            // 2000.0000000000002. This is a problem when we are comparing the currentTime with the duration, for\n            // example.\n            this.currentTime = animationTime;\n        }\n    }\n    tick(timestamp, sample = false) {\n        const { generator, totalDuration, mixKeyframes, mirroredGenerator, resolvedDuration, calculatedDuration, } = this;\n        if (this.startTime === null)\n            return generator.next(0);\n        const { delay = 0, keyframes, repeat, repeatType, repeatDelay, type, onUpdate, finalKeyframe, } = this.options;\n        /**\n         * requestAnimationFrame timestamps can come through as lower than\n         * the startTime as set by performance.now(). Here we prevent this,\n         * though in the future it could be possible to make setting startTime\n         * a pending operation that gets resolved here.\n         */\n        if (this.speed > 0) {\n            this.startTime = Math.min(this.startTime, timestamp);\n        }\n        else if (this.speed < 0) {\n            this.startTime = Math.min(timestamp - totalDuration / this.speed, this.startTime);\n        }\n        if (sample) {\n            this.currentTime = timestamp;\n        }\n        else {\n            this.updateTime(timestamp);\n        }\n        // Rebase on delay\n        const timeWithoutDelay = this.currentTime - delay * (this.playbackSpeed >= 0 ? 1 : -1);\n        const isInDelayPhase = this.playbackSpeed >= 0\n            ? timeWithoutDelay < 0\n            : timeWithoutDelay > totalDuration;\n        this.currentTime = Math.max(timeWithoutDelay, 0);\n        // If this animation has finished, set the current time  to the total duration.\n        if (this.state === \"finished\" && this.holdTime === null) {\n            this.currentTime = totalDuration;\n        }\n        let elapsed = this.currentTime;\n        let frameGenerator = generator;\n        if (repeat) {\n            /**\n             * Get the current progress (0-1) of the animation. If t is >\n             * than duration we'll get values like 2.5 (midway through the\n             * third iteration)\n             */\n            const progress = Math.min(this.currentTime, totalDuration) / resolvedDuration;\n            /**\n             * Get the current iteration (0 indexed). For instance the floor of\n             * 2.5 is 2.\n             */\n            let currentIteration = Math.floor(progress);\n            /**\n             * Get the current progress of the iteration by taking the remainder\n             * so 2.5 is 0.5 through iteration 2\n             */\n            let iterationProgress = progress % 1.0;\n            /**\n             * If iteration progress is 1 we count that as the end\n             * of the previous iteration.\n             */\n            if (!iterationProgress && progress >= 1) {\n                iterationProgress = 1;\n            }\n            iterationProgress === 1 && currentIteration--;\n            currentIteration = Math.min(currentIteration, repeat + 1);\n            /**\n             * Reverse progress if we're not running in \"normal\" direction\n             */\n            const isOddIteration = Boolean(currentIteration % 2);\n            if (isOddIteration) {\n                if (repeatType === \"reverse\") {\n                    iterationProgress = 1 - iterationProgress;\n                    if (repeatDelay) {\n                        iterationProgress -= repeatDelay / resolvedDuration;\n                    }\n                }\n                else if (repeatType === \"mirror\") {\n                    frameGenerator = mirroredGenerator;\n                }\n            }\n            elapsed = clamp(0, 1, iterationProgress) * resolvedDuration;\n        }\n        /**\n         * If we're in negative time, set state as the initial keyframe.\n         * This prevents delay: x, duration: 0 animations from finishing\n         * instantly.\n         */\n        const state = isInDelayPhase\n            ? { done: false, value: keyframes[0] }\n            : frameGenerator.next(elapsed);\n        if (mixKeyframes) {\n            state.value = mixKeyframes(state.value);\n        }\n        let { done } = state;\n        if (!isInDelayPhase && calculatedDuration !== null) {\n            done =\n                this.playbackSpeed >= 0\n                    ? this.currentTime >= totalDuration\n                    : this.currentTime <= 0;\n        }\n        const isAnimationFinished = this.holdTime === null &&\n            (this.state === \"finished\" || (this.state === \"running\" && done));\n        // TODO: The exception for inertia could be cleaner here\n        if (isAnimationFinished && type !== inertia) {\n            state.value = getFinalKeyframe(keyframes, this.options, finalKeyframe, this.speed);\n        }\n        if (onUpdate) {\n            onUpdate(state.value);\n        }\n        if (isAnimationFinished) {\n            this.finish();\n        }\n        return state;\n    }\n    /**\n     * Allows the returned animation to be awaited or promise-chained. Currently\n     * resolves when the animation finishes at all but in a future update could/should\n     * reject if its cancels.\n     */\n    then(resolve, reject) {\n        return this.finished.then(resolve, reject);\n    }\n    get duration() {\n        return millisecondsToSeconds(this.calculatedDuration);\n    }\n    get time() {\n        return millisecondsToSeconds(this.currentTime);\n    }\n    set time(newTime) {\n        newTime = secondsToMilliseconds(newTime);\n        this.currentTime = newTime;\n        if (this.startTime === null ||\n            this.holdTime !== null ||\n            this.playbackSpeed === 0) {\n            this.holdTime = newTime;\n        }\n        else if (this.driver) {\n            this.startTime = this.driver.now() - newTime / this.playbackSpeed;\n        }\n        this.driver?.start(false);\n    }\n    get speed() {\n        return this.playbackSpeed;\n    }\n    set speed(newSpeed) {\n        this.updateTime(time.now());\n        const hasChanged = this.playbackSpeed !== newSpeed;\n        this.playbackSpeed = newSpeed;\n        if (hasChanged) {\n            this.time = millisecondsToSeconds(this.currentTime);\n        }\n    }\n    play() {\n        if (this.isStopped)\n            return;\n        const { driver = frameloopDriver, startTime } = this.options;\n        if (!this.driver) {\n            this.driver = driver((timestamp) => this.tick(timestamp));\n        }\n        this.options.onPlay?.();\n        const now = this.driver.now();\n        if (this.state === \"finished\") {\n            this.updateFinished();\n            this.startTime = now;\n        }\n        else if (this.holdTime !== null) {\n            this.startTime = now - this.holdTime;\n        }\n        else if (!this.startTime) {\n            this.startTime = startTime ?? now;\n        }\n        if (this.state === \"finished\" && this.speed < 0) {\n            this.startTime += this.calculatedDuration;\n        }\n        this.holdTime = null;\n        /**\n         * Set playState to running only after we've used it in\n         * the previous logic.\n         */\n        this.state = \"running\";\n        this.driver.start();\n    }\n    pause() {\n        this.state = \"paused\";\n        this.updateTime(time.now());\n        this.holdTime = this.currentTime;\n    }\n    complete() {\n        if (this.state !== \"running\") {\n            this.play();\n        }\n        this.state = \"finished\";\n        this.holdTime = null;\n    }\n    finish() {\n        this.notifyFinished();\n        this.teardown();\n        this.state = \"finished\";\n        this.options.onComplete?.();\n    }\n    cancel() {\n        this.holdTime = null;\n        this.startTime = 0;\n        this.tick(0);\n        this.teardown();\n        this.options.onCancel?.();\n    }\n    teardown() {\n        this.state = \"idle\";\n        this.stopDriver();\n        this.startTime = this.holdTime = null;\n        activeAnimations.mainThread--;\n    }\n    stopDriver() {\n        if (!this.driver)\n            return;\n        this.driver.stop();\n        this.driver = undefined;\n    }\n    sample(sampleTime) {\n        this.startTime = 0;\n        return this.tick(sampleTime, true);\n    }\n    attachTimeline(timeline) {\n        if (this.options.allowFlatten) {\n            this.options.type = \"keyframes\";\n            this.options.ease = \"linear\";\n            this.initAnimation();\n        }\n        this.driver?.stop();\n        return timeline.observe(this);\n    }\n}\n// Legacy function support\nfunction animateValue(options) {\n    return new JSAnimation(options);\n}\n\nexport { JSAnimation, animateValue };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}