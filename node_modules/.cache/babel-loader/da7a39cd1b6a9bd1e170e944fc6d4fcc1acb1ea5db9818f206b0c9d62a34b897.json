{"ast":null,"code":"import{startWaapiAnimation}from'motion-dom';import{noop}from'motion-utils';import{optimizedAppearDataId}from'./data-id.mjs';import{getOptimisedAppearId}from'./get-appear-id.mjs';import{handoffOptimizedAppearAnimation}from'./handoff.mjs';import{appearAnimationStore,appearComplete}from'./store.mjs';import{appearStoreId}from'./store-id.mjs';/**\n * A single time to use across all animations to manually set startTime\n * and ensure they're all in sync.\n */let startFrameTime;/**\n * A dummy animation to detect when Chrome is ready to start\n * painting the page and hold off from triggering the real animation\n * until then. We only need one animation to detect paint ready.\n *\n * https://bugs.chromium.org/p/chromium/issues/detail?id=1406850\n */let readyAnimation;/**\n * Keep track of animations that were suspended vs cancelled so we\n * can easily resume them when we're done measuring layout.\n */const suspendedAnimations=new Set();function resumeSuspendedAnimations(){suspendedAnimations.forEach(data=>{data.animation.play();data.animation.startTime=data.startTime;});suspendedAnimations.clear();}function startOptimizedAppearAnimation(element,name,keyframes,options,onReady){// Prevent optimised appear animations if Motion has already started animating.\nif(window.MotionIsMounted){return;}const id=element.dataset[optimizedAppearDataId];if(!id)return;window.MotionHandoffAnimation=handoffOptimizedAppearAnimation;const storeId=appearStoreId(id,name);if(!readyAnimation){readyAnimation=startWaapiAnimation(element,name,[keyframes[0],keyframes[0]],/**\n         * 10 secs is basically just a super-safe duration to give Chrome\n         * long enough to get the animation ready.\n         */{duration:10000,ease:\"linear\"});appearAnimationStore.set(storeId,{animation:readyAnimation,startTime:null});/**\n         * If there's no readyAnimation then there's been no instantiation\n         * of handoff animations.\n         */window.MotionHandoffAnimation=handoffOptimizedAppearAnimation;window.MotionHasOptimisedAnimation=(elementId,valueName)=>{if(!elementId)return false;/**\n             * Keep a map of elementIds that have started animating. We check\n             * via ID instead of Element because of hydration errors and\n             * pre-hydration checks. We also actively record IDs as they start\n             * animating rather than simply checking for data-appear-id as\n             * this attrbute might be present but not lead to an animation, for\n             * instance if the element's appear animation is on a different\n             * breakpoint.\n             */if(!valueName){return appearComplete.has(elementId);}const animationId=appearStoreId(elementId,valueName);return Boolean(appearAnimationStore.get(animationId));};window.MotionHandoffMarkAsComplete=elementId=>{if(appearComplete.has(elementId)){appearComplete.set(elementId,true);}};window.MotionHandoffIsComplete=elementId=>{return appearComplete.get(elementId)===true;};/**\n         * We only need to cancel transform animations as\n         * they're the ones that will interfere with the\n         * layout animation measurements.\n         */window.MotionCancelOptimisedAnimation=(elementId,valueName,frame,canResume)=>{const animationId=appearStoreId(elementId,valueName);const data=appearAnimationStore.get(animationId);if(!data)return;if(frame&&canResume===undefined){/**\n                 * Wait until the end of the subsequent frame to cancel the animation\n                 * to ensure we don't remove the animation before the main thread has\n                 * had a chance to resolve keyframes and render.\n                 */frame.postRender(()=>{frame.postRender(()=>{data.animation.cancel();});});}else{data.animation.cancel();}if(frame&&canResume){suspendedAnimations.add(data);frame.render(resumeSuspendedAnimations);}else{appearAnimationStore.delete(animationId);/**\n                 * If there are no more animations left, we can remove the cancel function.\n                 * This will let us know when we can stop checking for conflicting layout animations.\n                 */if(!appearAnimationStore.size){window.MotionCancelOptimisedAnimation=undefined;}}};window.MotionCheckAppearSync=(visualElement,valueName,value)=>{var _window$MotionHasOpti,_window,_visualElement$props$;const appearId=getOptimisedAppearId(visualElement);if(!appearId)return;const valueIsOptimised=(_window$MotionHasOpti=(_window=window).MotionHasOptimisedAnimation)===null||_window$MotionHasOpti===void 0?void 0:_window$MotionHasOpti.call(_window,appearId,valueName);const externalAnimationValue=(_visualElement$props$=visualElement.props.values)===null||_visualElement$props$===void 0?void 0:_visualElement$props$[valueName];if(!valueIsOptimised||!externalAnimationValue)return;const removeSyncCheck=value.on(\"change\",latestValue=>{if(externalAnimationValue.get()!==latestValue){var _window$MotionCancelO,_window2;(_window$MotionCancelO=(_window2=window).MotionCancelOptimisedAnimation)===null||_window$MotionCancelO===void 0?void 0:_window$MotionCancelO.call(_window2,appearId,valueName);removeSyncCheck();}});return removeSyncCheck;};}const startAnimation=()=>{readyAnimation.cancel();const appearAnimation=startWaapiAnimation(element,name,keyframes,options);/**\n         * Record the time of the first started animation. We call performance.now() once\n         * here and once in handoff to ensure we're getting\n         * close to a frame-locked time. This keeps all animations in sync.\n         */if(startFrameTime===undefined){startFrameTime=performance.now();}appearAnimation.startTime=startFrameTime;appearAnimationStore.set(storeId,{animation:appearAnimation,startTime:startFrameTime});if(onReady)onReady(appearAnimation);};appearComplete.set(id,false);if(readyAnimation.ready){readyAnimation.ready.then(startAnimation).catch(noop);}else{startAnimation();}}export{startOptimizedAppearAnimation};","map":{"version":3,"names":["startWaapiAnimation","noop","optimizedAppearDataId","getOptimisedAppearId","handoffOptimizedAppearAnimation","appearAnimationStore","appearComplete","appearStoreId","startFrameTime","readyAnimation","suspendedAnimations","Set","resumeSuspendedAnimations","forEach","data","animation","play","startTime","clear","startOptimizedAppearAnimation","element","name","keyframes","options","onReady","window","MotionIsMounted","id","dataset","MotionHandoffAnimation","storeId","duration","ease","set","MotionHasOptimisedAnimation","elementId","valueName","has","animationId","Boolean","get","MotionHandoffMarkAsComplete","MotionHandoffIsComplete","MotionCancelOptimisedAnimation","frame","canResume","undefined","postRender","cancel","add","render","delete","size","MotionCheckAppearSync","visualElement","value","_window$MotionHasOpti","_window","_visualElement$props$","appearId","valueIsOptimised","call","externalAnimationValue","props","values","removeSyncCheck","on","latestValue","_window$MotionCancelO","_window2","startAnimation","appearAnimation","performance","now","ready","then","catch"],"sources":["/home/antisyn/portfolio/src/components/node_modules/framer-motion/dist/es/animation/optimized-appear/start.mjs"],"sourcesContent":["import { startWaapiAnimation } from 'motion-dom';\nimport { noop } from 'motion-utils';\nimport { optimizedAppearDataId } from './data-id.mjs';\nimport { getOptimisedAppearId } from './get-appear-id.mjs';\nimport { handoffOptimizedAppearAnimation } from './handoff.mjs';\nimport { appearAnimationStore, appearComplete } from './store.mjs';\nimport { appearStoreId } from './store-id.mjs';\n\n/**\n * A single time to use across all animations to manually set startTime\n * and ensure they're all in sync.\n */\nlet startFrameTime;\n/**\n * A dummy animation to detect when Chrome is ready to start\n * painting the page and hold off from triggering the real animation\n * until then. We only need one animation to detect paint ready.\n *\n * https://bugs.chromium.org/p/chromium/issues/detail?id=1406850\n */\nlet readyAnimation;\n/**\n * Keep track of animations that were suspended vs cancelled so we\n * can easily resume them when we're done measuring layout.\n */\nconst suspendedAnimations = new Set();\nfunction resumeSuspendedAnimations() {\n    suspendedAnimations.forEach((data) => {\n        data.animation.play();\n        data.animation.startTime = data.startTime;\n    });\n    suspendedAnimations.clear();\n}\nfunction startOptimizedAppearAnimation(element, name, keyframes, options, onReady) {\n    // Prevent optimised appear animations if Motion has already started animating.\n    if (window.MotionIsMounted) {\n        return;\n    }\n    const id = element.dataset[optimizedAppearDataId];\n    if (!id)\n        return;\n    window.MotionHandoffAnimation = handoffOptimizedAppearAnimation;\n    const storeId = appearStoreId(id, name);\n    if (!readyAnimation) {\n        readyAnimation = startWaapiAnimation(element, name, [keyframes[0], keyframes[0]], \n        /**\n         * 10 secs is basically just a super-safe duration to give Chrome\n         * long enough to get the animation ready.\n         */\n        { duration: 10000, ease: \"linear\" });\n        appearAnimationStore.set(storeId, {\n            animation: readyAnimation,\n            startTime: null,\n        });\n        /**\n         * If there's no readyAnimation then there's been no instantiation\n         * of handoff animations.\n         */\n        window.MotionHandoffAnimation = handoffOptimizedAppearAnimation;\n        window.MotionHasOptimisedAnimation = (elementId, valueName) => {\n            if (!elementId)\n                return false;\n            /**\n             * Keep a map of elementIds that have started animating. We check\n             * via ID instead of Element because of hydration errors and\n             * pre-hydration checks. We also actively record IDs as they start\n             * animating rather than simply checking for data-appear-id as\n             * this attrbute might be present but not lead to an animation, for\n             * instance if the element's appear animation is on a different\n             * breakpoint.\n             */\n            if (!valueName) {\n                return appearComplete.has(elementId);\n            }\n            const animationId = appearStoreId(elementId, valueName);\n            return Boolean(appearAnimationStore.get(animationId));\n        };\n        window.MotionHandoffMarkAsComplete = (elementId) => {\n            if (appearComplete.has(elementId)) {\n                appearComplete.set(elementId, true);\n            }\n        };\n        window.MotionHandoffIsComplete = (elementId) => {\n            return appearComplete.get(elementId) === true;\n        };\n        /**\n         * We only need to cancel transform animations as\n         * they're the ones that will interfere with the\n         * layout animation measurements.\n         */\n        window.MotionCancelOptimisedAnimation = (elementId, valueName, frame, canResume) => {\n            const animationId = appearStoreId(elementId, valueName);\n            const data = appearAnimationStore.get(animationId);\n            if (!data)\n                return;\n            if (frame && canResume === undefined) {\n                /**\n                 * Wait until the end of the subsequent frame to cancel the animation\n                 * to ensure we don't remove the animation before the main thread has\n                 * had a chance to resolve keyframes and render.\n                 */\n                frame.postRender(() => {\n                    frame.postRender(() => {\n                        data.animation.cancel();\n                    });\n                });\n            }\n            else {\n                data.animation.cancel();\n            }\n            if (frame && canResume) {\n                suspendedAnimations.add(data);\n                frame.render(resumeSuspendedAnimations);\n            }\n            else {\n                appearAnimationStore.delete(animationId);\n                /**\n                 * If there are no more animations left, we can remove the cancel function.\n                 * This will let us know when we can stop checking for conflicting layout animations.\n                 */\n                if (!appearAnimationStore.size) {\n                    window.MotionCancelOptimisedAnimation = undefined;\n                }\n            }\n        };\n        window.MotionCheckAppearSync = (visualElement, valueName, value) => {\n            const appearId = getOptimisedAppearId(visualElement);\n            if (!appearId)\n                return;\n            const valueIsOptimised = window.MotionHasOptimisedAnimation?.(appearId, valueName);\n            const externalAnimationValue = visualElement.props.values?.[valueName];\n            if (!valueIsOptimised || !externalAnimationValue)\n                return;\n            const removeSyncCheck = value.on(\"change\", (latestValue) => {\n                if (externalAnimationValue.get() !== latestValue) {\n                    window.MotionCancelOptimisedAnimation?.(appearId, valueName);\n                    removeSyncCheck();\n                }\n            });\n            return removeSyncCheck;\n        };\n    }\n    const startAnimation = () => {\n        readyAnimation.cancel();\n        const appearAnimation = startWaapiAnimation(element, name, keyframes, options);\n        /**\n         * Record the time of the first started animation. We call performance.now() once\n         * here and once in handoff to ensure we're getting\n         * close to a frame-locked time. This keeps all animations in sync.\n         */\n        if (startFrameTime === undefined) {\n            startFrameTime = performance.now();\n        }\n        appearAnimation.startTime = startFrameTime;\n        appearAnimationStore.set(storeId, {\n            animation: appearAnimation,\n            startTime: startFrameTime,\n        });\n        if (onReady)\n            onReady(appearAnimation);\n    };\n    appearComplete.set(id, false);\n    if (readyAnimation.ready) {\n        readyAnimation.ready.then(startAnimation).catch(noop);\n    }\n    else {\n        startAnimation();\n    }\n}\n\nexport { startOptimizedAppearAnimation };\n"],"mappings":"AAAA,OAASA,mBAAmB,KAAQ,YAAY,CAChD,OAASC,IAAI,KAAQ,cAAc,CACnC,OAASC,qBAAqB,KAAQ,eAAe,CACrD,OAASC,oBAAoB,KAAQ,qBAAqB,CAC1D,OAASC,+BAA+B,KAAQ,eAAe,CAC/D,OAASC,oBAAoB,CAAEC,cAAc,KAAQ,aAAa,CAClE,OAASC,aAAa,KAAQ,gBAAgB,CAE9C;AACA;AACA;AACA,GACA,GAAI,CAAAC,cAAc,CAClB;AACA;AACA;AACA;AACA;AACA;AACA,GACA,GAAI,CAAAC,cAAc,CAClB;AACA;AACA;AACA,GACA,KAAM,CAAAC,mBAAmB,CAAG,GAAI,CAAAC,GAAG,CAAC,CAAC,CACrC,QAAS,CAAAC,yBAAyBA,CAAA,CAAG,CACjCF,mBAAmB,CAACG,OAAO,CAAEC,IAAI,EAAK,CAClCA,IAAI,CAACC,SAAS,CAACC,IAAI,CAAC,CAAC,CACrBF,IAAI,CAACC,SAAS,CAACE,SAAS,CAAGH,IAAI,CAACG,SAAS,CAC7C,CAAC,CAAC,CACFP,mBAAmB,CAACQ,KAAK,CAAC,CAAC,CAC/B,CACA,QAAS,CAAAC,6BAA6BA,CAACC,OAAO,CAAEC,IAAI,CAAEC,SAAS,CAAEC,OAAO,CAAEC,OAAO,CAAE,CAC/E;AACA,GAAIC,MAAM,CAACC,eAAe,CAAE,CACxB,OACJ,CACA,KAAM,CAAAC,EAAE,CAAGP,OAAO,CAACQ,OAAO,CAAC1B,qBAAqB,CAAC,CACjD,GAAI,CAACyB,EAAE,CACH,OACJF,MAAM,CAACI,sBAAsB,CAAGzB,+BAA+B,CAC/D,KAAM,CAAA0B,OAAO,CAAGvB,aAAa,CAACoB,EAAE,CAAEN,IAAI,CAAC,CACvC,GAAI,CAACZ,cAAc,CAAE,CACjBA,cAAc,CAAGT,mBAAmB,CAACoB,OAAO,CAAEC,IAAI,CAAE,CAACC,SAAS,CAAC,CAAC,CAAC,CAAEA,SAAS,CAAC,CAAC,CAAC,CAAC,CAChF;AACR;AACA;AACA,WACQ,CAAES,QAAQ,CAAE,KAAK,CAAEC,IAAI,CAAE,QAAS,CAAC,CAAC,CACpC3B,oBAAoB,CAAC4B,GAAG,CAACH,OAAO,CAAE,CAC9Bf,SAAS,CAAEN,cAAc,CACzBQ,SAAS,CAAE,IACf,CAAC,CAAC,CACF;AACR;AACA;AACA,WACQQ,MAAM,CAACI,sBAAsB,CAAGzB,+BAA+B,CAC/DqB,MAAM,CAACS,2BAA2B,CAAG,CAACC,SAAS,CAAEC,SAAS,GAAK,CAC3D,GAAI,CAACD,SAAS,CACV,MAAO,MAAK,CAChB;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eACY,GAAI,CAACC,SAAS,CAAE,CACZ,MAAO,CAAA9B,cAAc,CAAC+B,GAAG,CAACF,SAAS,CAAC,CACxC,CACA,KAAM,CAAAG,WAAW,CAAG/B,aAAa,CAAC4B,SAAS,CAAEC,SAAS,CAAC,CACvD,MAAO,CAAAG,OAAO,CAAClC,oBAAoB,CAACmC,GAAG,CAACF,WAAW,CAAC,CAAC,CACzD,CAAC,CACDb,MAAM,CAACgB,2BAA2B,CAAIN,SAAS,EAAK,CAChD,GAAI7B,cAAc,CAAC+B,GAAG,CAACF,SAAS,CAAC,CAAE,CAC/B7B,cAAc,CAAC2B,GAAG,CAACE,SAAS,CAAE,IAAI,CAAC,CACvC,CACJ,CAAC,CACDV,MAAM,CAACiB,uBAAuB,CAAIP,SAAS,EAAK,CAC5C,MAAO,CAAA7B,cAAc,CAACkC,GAAG,CAACL,SAAS,CAAC,GAAK,IAAI,CACjD,CAAC,CACD;AACR;AACA;AACA;AACA,WACQV,MAAM,CAACkB,8BAA8B,CAAG,CAACR,SAAS,CAAEC,SAAS,CAAEQ,KAAK,CAAEC,SAAS,GAAK,CAChF,KAAM,CAAAP,WAAW,CAAG/B,aAAa,CAAC4B,SAAS,CAAEC,SAAS,CAAC,CACvD,KAAM,CAAAtB,IAAI,CAAGT,oBAAoB,CAACmC,GAAG,CAACF,WAAW,CAAC,CAClD,GAAI,CAACxB,IAAI,CACL,OACJ,GAAI8B,KAAK,EAAIC,SAAS,GAAKC,SAAS,CAAE,CAClC;AAChB;AACA;AACA;AACA,mBACgBF,KAAK,CAACG,UAAU,CAAC,IAAM,CACnBH,KAAK,CAACG,UAAU,CAAC,IAAM,CACnBjC,IAAI,CAACC,SAAS,CAACiC,MAAM,CAAC,CAAC,CAC3B,CAAC,CAAC,CACN,CAAC,CAAC,CACN,CAAC,IACI,CACDlC,IAAI,CAACC,SAAS,CAACiC,MAAM,CAAC,CAAC,CAC3B,CACA,GAAIJ,KAAK,EAAIC,SAAS,CAAE,CACpBnC,mBAAmB,CAACuC,GAAG,CAACnC,IAAI,CAAC,CAC7B8B,KAAK,CAACM,MAAM,CAACtC,yBAAyB,CAAC,CAC3C,CAAC,IACI,CACDP,oBAAoB,CAAC8C,MAAM,CAACb,WAAW,CAAC,CACxC;AAChB;AACA;AACA,mBACgB,GAAI,CAACjC,oBAAoB,CAAC+C,IAAI,CAAE,CAC5B3B,MAAM,CAACkB,8BAA8B,CAAGG,SAAS,CACrD,CACJ,CACJ,CAAC,CACDrB,MAAM,CAAC4B,qBAAqB,CAAG,CAACC,aAAa,CAAElB,SAAS,CAAEmB,KAAK,GAAK,KAAAC,qBAAA,CAAAC,OAAA,CAAAC,qBAAA,CAChE,KAAM,CAAAC,QAAQ,CAAGxD,oBAAoB,CAACmD,aAAa,CAAC,CACpD,GAAI,CAACK,QAAQ,CACT,OACJ,KAAM,CAAAC,gBAAgB,EAAAJ,qBAAA,CAAG,CAAAC,OAAA,CAAAhC,MAAM,EAACS,2BAA2B,UAAAsB,qBAAA,iBAAlCA,qBAAA,CAAAK,IAAA,CAAAJ,OAAA,CAAqCE,QAAQ,CAAEvB,SAAS,CAAC,CAClF,KAAM,CAAA0B,sBAAsB,EAAAJ,qBAAA,CAAGJ,aAAa,CAACS,KAAK,CAACC,MAAM,UAAAN,qBAAA,iBAA1BA,qBAAA,CAA6BtB,SAAS,CAAC,CACtE,GAAI,CAACwB,gBAAgB,EAAI,CAACE,sBAAsB,CAC5C,OACJ,KAAM,CAAAG,eAAe,CAAGV,KAAK,CAACW,EAAE,CAAC,QAAQ,CAAGC,WAAW,EAAK,CACxD,GAAIL,sBAAsB,CAACtB,GAAG,CAAC,CAAC,GAAK2B,WAAW,CAAE,KAAAC,qBAAA,CAAAC,QAAA,CAC9C,CAAAD,qBAAA,EAAAC,QAAA,CAAA5C,MAAM,EAACkB,8BAA8B,UAAAyB,qBAAA,iBAArCA,qBAAA,CAAAP,IAAA,CAAAQ,QAAA,CAAwCV,QAAQ,CAAEvB,SAAS,CAAC,CAC5D6B,eAAe,CAAC,CAAC,CACrB,CACJ,CAAC,CAAC,CACF,MAAO,CAAAA,eAAe,CAC1B,CAAC,CACL,CACA,KAAM,CAAAK,cAAc,CAAGA,CAAA,GAAM,CACzB7D,cAAc,CAACuC,MAAM,CAAC,CAAC,CACvB,KAAM,CAAAuB,eAAe,CAAGvE,mBAAmB,CAACoB,OAAO,CAAEC,IAAI,CAAEC,SAAS,CAAEC,OAAO,CAAC,CAC9E;AACR;AACA;AACA;AACA,WACQ,GAAIf,cAAc,GAAKsC,SAAS,CAAE,CAC9BtC,cAAc,CAAGgE,WAAW,CAACC,GAAG,CAAC,CAAC,CACtC,CACAF,eAAe,CAACtD,SAAS,CAAGT,cAAc,CAC1CH,oBAAoB,CAAC4B,GAAG,CAACH,OAAO,CAAE,CAC9Bf,SAAS,CAAEwD,eAAe,CAC1BtD,SAAS,CAAET,cACf,CAAC,CAAC,CACF,GAAIgB,OAAO,CACPA,OAAO,CAAC+C,eAAe,CAAC,CAChC,CAAC,CACDjE,cAAc,CAAC2B,GAAG,CAACN,EAAE,CAAE,KAAK,CAAC,CAC7B,GAAIlB,cAAc,CAACiE,KAAK,CAAE,CACtBjE,cAAc,CAACiE,KAAK,CAACC,IAAI,CAACL,cAAc,CAAC,CAACM,KAAK,CAAC3E,IAAI,CAAC,CACzD,CAAC,IACI,CACDqE,cAAc,CAAC,CAAC,CACpB,CACJ,CAEA,OAASnD,6BAA6B","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}